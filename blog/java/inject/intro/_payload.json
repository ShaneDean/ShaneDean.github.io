[{"data":1,"prerenderedAt":385},["Reactive",2],{"content-query-JAC0RuJmOg":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":380,"_id":381,"_source":382,"_file":383,"_extension":384},"/blog/java/inject/intro","inject",false,"","依赖注入","转载原文",{"type":11,"children":12,"toc":375},"root",[13,20,35,40,47,52,136,157,163,168,233,246,252,257,314,319,369],{"type":14,"tag":15,"props":16,"children":17},"element","h1",{"id":8},[18],{"type":19,"value":8},"text",{"type":14,"tag":21,"props":22,"children":23},"p",{},[24,26],{"type":19,"value":25},"转载",{"type":14,"tag":27,"props":28,"children":32},"a",{"href":29,"rel":30},"https://github.com/android-cn/blog/blob/master/java/dependency-injection/README.md",[31],"nofollow",[33],{"type":19,"value":34},"原文",{"type":14,"tag":15,"props":36,"children":38},{"id":37},"依赖注入-1",[39],{"type":19,"value":8},{"type":14,"tag":41,"props":42,"children":44},"h3",{"id":43},"_1-依赖",[45],{"type":19,"value":46},"1. 依赖",{"type":14,"tag":21,"props":48,"children":49},{},[50],{"type":19,"value":51},"如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。",{"type":14,"tag":53,"props":54,"children":58},"pre",{"className":55,"code":56,"language":57,"meta":7,"style":7},"language-java shiki shiki-themes github-dark","public class Human {\n    ...\n    Father father;\n    ...\n    public Human() {\n        father = new Father();\n    }\n}\n","java",[59],{"type":14,"tag":60,"props":61,"children":62},"code",{"__ignoreMap":7},[63,74,83,92,100,109,118,127],{"type":14,"tag":64,"props":65,"children":68},"span",{"class":66,"line":67},"line",1,[69],{"type":14,"tag":64,"props":70,"children":71},{},[72],{"type":19,"value":73},"public class Human {\n",{"type":14,"tag":64,"props":75,"children":77},{"class":66,"line":76},2,[78],{"type":14,"tag":64,"props":79,"children":80},{},[81],{"type":19,"value":82},"    ...\n",{"type":14,"tag":64,"props":84,"children":86},{"class":66,"line":85},3,[87],{"type":14,"tag":64,"props":88,"children":89},{},[90],{"type":19,"value":91},"    Father father;\n",{"type":14,"tag":64,"props":93,"children":95},{"class":66,"line":94},4,[96],{"type":14,"tag":64,"props":97,"children":98},{},[99],{"type":19,"value":82},{"type":14,"tag":64,"props":101,"children":103},{"class":66,"line":102},5,[104],{"type":14,"tag":64,"props":105,"children":106},{},[107],{"type":19,"value":108},"    public Human() {\n",{"type":14,"tag":64,"props":110,"children":112},{"class":66,"line":111},6,[113],{"type":14,"tag":64,"props":114,"children":115},{},[116],{"type":19,"value":117},"        father = new Father();\n",{"type":14,"tag":64,"props":119,"children":121},{"class":66,"line":120},7,[122],{"type":14,"tag":64,"props":123,"children":124},{},[125],{"type":19,"value":126},"    }\n",{"type":14,"tag":64,"props":128,"children":130},{"class":66,"line":129},8,[131],{"type":14,"tag":64,"props":132,"children":133},{},[134],{"type":19,"value":135},"}\n",{"type":14,"tag":21,"props":137,"children":138},{},[139,141,147,149,155],{"type":19,"value":140},"仔细看这段代码我们会发现存在一些问题：\n(1). 如果现在要改变 father 生成方式，如需要用",{"type":14,"tag":60,"props":142,"children":144},{"className":143},[],[145],{"type":19,"value":146},"new Father(String name)",{"type":19,"value":148},"初始化 father，需要修改 Human 代码；\n(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；\n(3). 如果",{"type":14,"tag":60,"props":150,"children":152},{"className":151},[],[153],{"type":19,"value":154},"new Father()",{"type":19,"value":156},"过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。",{"type":14,"tag":41,"props":158,"children":160},{"id":159},"_2-依赖注入",[161],{"type":19,"value":162},"2. 依赖注入",{"type":14,"tag":21,"props":164,"children":165},{},[166],{"type":19,"value":167},"上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：",{"type":14,"tag":53,"props":169,"children":171},{"className":55,"code":170,"language":57,"meta":7,"style":7},"public class Human {\n    ...\n    Father father;\n    ...\n    public Human(Father father) {\n        this.father = father;\n    }\n}\n",[172],{"type":14,"tag":60,"props":173,"children":174},{"__ignoreMap":7},[175,182,189,196,203,211,219,226],{"type":14,"tag":64,"props":176,"children":177},{"class":66,"line":67},[178],{"type":14,"tag":64,"props":179,"children":180},{},[181],{"type":19,"value":73},{"type":14,"tag":64,"props":183,"children":184},{"class":66,"line":76},[185],{"type":14,"tag":64,"props":186,"children":187},{},[188],{"type":19,"value":82},{"type":14,"tag":64,"props":190,"children":191},{"class":66,"line":85},[192],{"type":14,"tag":64,"props":193,"children":194},{},[195],{"type":19,"value":91},{"type":14,"tag":64,"props":197,"children":198},{"class":66,"line":94},[199],{"type":14,"tag":64,"props":200,"children":201},{},[202],{"type":19,"value":82},{"type":14,"tag":64,"props":204,"children":205},{"class":66,"line":102},[206],{"type":14,"tag":64,"props":207,"children":208},{},[209],{"type":19,"value":210},"    public Human(Father father) {\n",{"type":14,"tag":64,"props":212,"children":213},{"class":66,"line":111},[214],{"type":14,"tag":64,"props":215,"children":216},{},[217],{"type":19,"value":218},"        this.father = father;\n",{"type":14,"tag":64,"props":220,"children":221},{"class":66,"line":120},[222],{"type":14,"tag":64,"props":223,"children":224},{},[225],{"type":19,"value":126},{"type":14,"tag":64,"props":227,"children":228},{"class":66,"line":129},[229],{"type":14,"tag":64,"props":230,"children":231},{},[232],{"type":19,"value":135},{"type":14,"tag":21,"props":234,"children":235},{},[236,238,244],{"type":19,"value":237},"上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。",{"type":14,"tag":239,"props":240,"children":241},"strong",{},[242],{"type":19,"value":243},"像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。",{"type":19,"value":245},"\n现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：\n(1). 解耦，将依赖之间解耦。\n(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。",{"type":14,"tag":41,"props":247,"children":249},{"id":248},"_3-java-中的依赖注入",[250],{"type":19,"value":251},"3. Java 中的依赖注入",{"type":14,"tag":21,"props":253,"children":254},{},[255],{"type":19,"value":256},"依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。",{"type":14,"tag":53,"props":258,"children":260},{"className":55,"code":259,"language":57,"meta":7,"style":7},"public class Human {\n    ...\n    @Inject Father father;\n    ...\n    public Human() {\n    }\n}\n",[261],{"type":14,"tag":60,"props":262,"children":263},{"__ignoreMap":7},[264,271,278,286,293,300,307],{"type":14,"tag":64,"props":265,"children":266},{"class":66,"line":67},[267],{"type":14,"tag":64,"props":268,"children":269},{},[270],{"type":19,"value":73},{"type":14,"tag":64,"props":272,"children":273},{"class":66,"line":76},[274],{"type":14,"tag":64,"props":275,"children":276},{},[277],{"type":19,"value":82},{"type":14,"tag":64,"props":279,"children":280},{"class":66,"line":85},[281],{"type":14,"tag":64,"props":282,"children":283},{},[284],{"type":19,"value":285},"    @Inject Father father;\n",{"type":14,"tag":64,"props":287,"children":288},{"class":66,"line":94},[289],{"type":14,"tag":64,"props":290,"children":291},{},[292],{"type":19,"value":82},{"type":14,"tag":64,"props":294,"children":295},{"class":66,"line":102},[296],{"type":14,"tag":64,"props":297,"children":298},{},[299],{"type":19,"value":108},{"type":14,"tag":64,"props":301,"children":302},{"class":66,"line":111},[303],{"type":14,"tag":64,"props":304,"children":305},{},[306],{"type":19,"value":126},{"type":14,"tag":64,"props":308,"children":309},{"class":66,"line":120},[310],{"type":14,"tag":64,"props":311,"children":312},{},[313],{"type":19,"value":135},{"type":14,"tag":21,"props":315,"children":316},{},[317],{"type":19,"value":318},"上面这段代码看起来很神奇：只是增加了一个注解，\nFather 对象就能自动注入了？这个注入过程是怎么完成的？",{"type":14,"tag":21,"props":320,"children":321},{},[322,324,331,333,340,342,349,351,358,360,367],{"type":19,"value":323},"实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。\n现在 Java 语言中较流行的依赖注入框架有 ",{"type":14,"tag":27,"props":325,"children":328},{"href":326,"rel":327},"https://github.com/google/guice",[31],[329],{"type":19,"value":330},"Google Guice",{"type":19,"value":332},"、\n",{"type":14,"tag":27,"props":334,"children":337},{"href":335,"rel":336},"http://projects.spring.io/spring-framework/",[31],[338],{"type":19,"value":339},"Spring",{"type":19,"value":341}," 等，而在 Android 上比较流行的有\n",{"type":14,"tag":27,"props":343,"children":346},{"href":344,"rel":345},"https://github.com/roboguice/roboguice",[31],[347],{"type":19,"value":348},"RoboGuice",{"type":19,"value":350},"、",{"type":14,"tag":27,"props":352,"children":355},{"href":353,"rel":354},"http://square.github.io/dagger/",[31],[356],{"type":19,"value":357},"Dagger",{"type":19,"value":359}," 等。其中 Dagger 是我现在正在项目中使用的。\n如果感兴趣，你可以到 ",{"type":14,"tag":27,"props":361,"children":364},{"href":362,"rel":363},"https://github.com/android-cn/android-open-project-analysis/tree/master/dagger",[31],[365],{"type":19,"value":366},"Dagger 实现原理解析",{"type":19,"value":368}," 了解更多依赖注入和 Dagger 实现原理相关信息。",{"type":14,"tag":370,"props":371,"children":372},"style",{},[373],{"type":19,"value":374},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"title":7,"searchDepth":76,"depth":76,"links":376},[377,378,379],{"id":43,"depth":85,"text":46},{"id":159,"depth":85,"text":162},{"id":248,"depth":85,"text":251},"markdown","content:blog:java:inject:intro.md","content","blog/java/inject/intro.md","md",1718158598643]