[{"data":1,"prerenderedAt":636},["Reactive",2],{"content-query-wOhpi0zuJ1":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":631,"_id":632,"_source":633,"_file":634,"_extension":635},"/blog/cs/bpf","cs",false,"","BSD Packet Filter","The BSD Packet Filter: A New Architecture for User-level Packet Capture",{"type":11,"children":12,"toc":619},"root",[13,21,30,35,43,54,64,73,78,83,88,93,98,103,108,113,118,123,128,133,138,143,148,153,168,176,181,186,191,196,201,208,213,218,231,236,241,246,252,257,265,270,278,285,290,319,327,332,338,343,426,431,439,444,452,457,465,471,479,485,490,498,503,508,526,531,539,552,560,565,573,578,583,588,593,597,609],{"type":14,"tag":15,"props":16,"children":18},"element","h1",{"id":17},"bsd-packet-filter",[19],{"type":20,"value":8},"text",{"type":14,"tag":22,"props":23,"children":24},"p",{},[25],{"type":14,"tag":26,"props":27,"children":28},"strong",{},[29],{"type":20,"value":9},{"type":14,"tag":22,"props":31,"children":32},{},[33],{"type":20,"value":34},"The Network Tap",{"type":14,"tag":22,"props":36,"children":37},{},[38],{"type":14,"tag":26,"props":39,"children":40},{},[41],{"type":20,"value":42},"BPF有两个主要的概念",{"type":14,"tag":22,"props":44,"children":45},{},[46,48,52],{"type":20,"value":47},"network tap",{"type":14,"tag":49,"props":50,"children":51},"br",{},[],{"type":20,"value":53},"\n从网络设备驱动中收集packets的拷贝，并把他们出输给监听程序",{"type":14,"tag":22,"props":55,"children":56},{},[57,59,62],{"type":20,"value":58},"packet filter",{"type":14,"tag":49,"props":60,"children":61},{},[],{"type":20,"value":63},"\n如果某个packet应当被接受，它将决定这个packet要复制多少份给监听的应用",{"type":14,"tag":22,"props":65,"children":66},{},[67],{"type":14,"tag":68,"props":69,"children":72},"img",{"alt":70,"src":71},"bpf-overview","https://github.com/ShaneDean/file/blob/master/blog/linux/bpf-overview.png?raw=true",[],{"type":14,"tag":22,"props":74,"children":75},{},[76],{"type":20,"value":77},"图一 阐述了BPF接口的基本工作流程",{"type":14,"tag":22,"props":79,"children":80},{},[81],{"type":20,"value":82},"当一个packed到达网络接口时，链路层的设备驱动通常会发送到系统协议栈中。",{"type":14,"tag":22,"props":84,"children":85},{},[86],{"type":20,"value":87},"但是当BPF正在监听这个接口，这个需求将会先调用BPF。 用户定义的鼓励去确定是否一个包将被接受和每个包的多少字节应当被保存。对于每个接受packet的filter而言，BPF拷贝请求的大量数据给filter关联的buffer。然后设备驱动重新获得控制。",{"type":14,"tag":22,"props":89,"children":90},{},[91],{"type":20,"value":92},"如果packet不是本地主机的地址，驱动将会返回一个中断。其他情况下，正常的协议处理机进程继续工作自从进程可能需要看一下在网络上的每个packet，并且在两个packed的间隔时间可能就few microsseconds ，这样的话就不可能对每个packet去触发一个系统调用read，BPF就必须在几个packet中间收集数据，并且当monitoring程序需要的read的时候返回。",{"type":14,"tag":22,"props":94,"children":95},{},[96],{"type":20,"value":97},"To maintain packet boundaries，BPF encapsulate每个packet头中的一些数据，比如time stamp,length,and offsets for data alignment",{"type":14,"tag":22,"props":99,"children":100},{},[101],{"type":20,"value":102},"Packet  Filtering\n由于网络监控器只是网络traffic中很小的一个部分，令人惊奇的性能优势在过滤不想要的interrupt context中的packets过程中得到了体现。",{"type":14,"tag":22,"props":104,"children":105},{},[106],{"type":20,"value":107},"如何最小化的内存消耗是现代工作站中主要的瓶颈。packet should be filtered \"in place\"(eg where the network interface DMA engine put it) 而不是拷贝到其他的kernel buffer中区。因此如果packet被接受了，only those bytes that were needed by the filtering process are referenced by the host\n相反的案例，SunOS 就是拷贝packet在filtering之前，这样直接导致性能下降。",{"type":14,"tag":22,"props":109,"children":110},{},[111],{"type":20,"value":112},"（接下来就是SunOs STREAMS NIT机制的详细过程说明）",{"type":14,"tag":22,"props":114,"children":115},{},[116],{"type":20,"value":117},"Tap Performance Measurements\n在讨论packet filter细节之前，我们需要提出一些测量的指标。这些性能指标需要独立于packet filter机制。",{"type":14,"tag":22,"props":119,"children":120},{},[121],{"type":20,"value":122},"我们配置了BPF 和NIT(上文所提及) 在SunOS内核4.1.1中，并运行在Sparcstation2 工作中中。the measurements reflect the overhead incurred during the interrupt prcocessing.(how long it takes each system to stash the packet into a buffer)。",{"type":14,"tag":22,"props":124,"children":125},{},[126],{"type":20,"value":127},"对于BPF 我们简单地两区在调用bpf_tap()的前后的时间，使用Sparcstation的microsecond clock。对于NIT 我测量调用snit_intr()前后的时间并加上拷贝promiscuous packet到 mbufs的时间。",{"type":14,"tag":22,"props":129,"children":130},{},[131],{"type":20,"value":132},"（promiscuous packet指的是那些没有本地主机地址的）。换句话说我们包含了NIT在适当地方拿取not filtering packets的细嫩那个干扰。为了获取精确的时间，在 instrumented code segments时，我们锁住了系统终端。",{"type":14,"tag":22,"props":134,"children":135},{},[136],{"type":20,"value":137},"测试的数据集是一个处理不同packetlength的矩阵。我们约定处理每个packet使用2个配置，'accept all' filter,和 'reject all' filter",{"type":14,"tag":22,"props":139,"children":140},{},[141],{"type":20,"value":142},"中间的实验对比 略过",{"type":14,"tag":22,"props":144,"children":145},{},[146],{"type":20,"value":147},"The Filter Model\n一个packet filter是一个返回简单的boolean的函数。true，则kernel 拷贝packet给app； false则忽略这个packet。",{"type":14,"tag":22,"props":149,"children":150},{},[151],{"type":20,"value":152},"历史上有两种filter的抽象：",{"type":14,"tag":154,"props":155,"children":156},"ul",{},[157,163],{"type":14,"tag":158,"props":159,"children":160},"li",{},[161],{"type":20,"value":162},"一个布尔值的表达式树（使用CSPF）",{"type":14,"tag":158,"props":164,"children":165},{},[166],{"type":20,"value":167},"一个直接非循环的控制流图或CFG（第一次被NNStat使用，也被BPF使用）",{"type":14,"tag":22,"props":169,"children":170},{},[171],{"type":14,"tag":68,"props":172,"children":175},{"alt":173,"src":174},"filter-representations","https://github.com/ShaneDean/file/blob/master/blog/linux/filter-function-representations.png?raw=true",[],{"type":14,"tag":22,"props":177,"children":178},{},[179],{"type":20,"value":180},"例如，图四中的两种模型，识别网络上的 IP 或 ARP packet。",{"type":14,"tag":22,"props":182,"children":183},{},[184],{"type":20,"value":185},"在树的模型中，每个节点代表一个boolean值，同时叶子节点代表一个packet field的测试predicate.边则表示操作运算符的关系。",{"type":14,"tag":22,"props":187,"children":188},{},[189],{"type":20,"value":190},"在CFG模型中每个节点代表一个packet field predicate 并且 每个边代表控制传递。右边传递true，左边传递false。两个叶子节点表示整个filter的过滤结果。",{"type":14,"tag":22,"props":192,"children":193},{},[194],{"type":20,"value":195},"这两个模型在计算层面而言是一样的，任何过滤器可以同时被两种方案表示。",{"type":14,"tag":22,"props":197,"children":198},{},[199],{"type":20,"value":200},"但是在实现方面他们不一样， The tree model maps naturally into code for a stack machine while the CFG model maps naturally into code for a register machine。\n大多数的现代机器都是基于寄存器的，随意我们任务cfg可以有一个更有效的实现。",{"type":14,"tag":202,"props":203,"children":205},"h2",{"id":204},"cspftree-model",[206],{"type":20,"value":207},"CSPF(tree) Model",{"type":14,"tag":22,"props":209,"children":210},{},[211],{"type":20,"value":212},"CSPF过滤引擎基于operand stack。指令push 常数或packet数据在栈中，并且执行一个二进制或位操作在顶部的两个元素。过滤程序顺序的执行指令的列表。最终，如果栈顶是一个非空值并且站空了那么packet久被接受，否则的话就拒绝。",{"type":14,"tag":22,"props":214,"children":215},{},[216],{"type":20,"value":217},"这里有2个缺点在这种实现方法里面。",{"type":14,"tag":154,"props":219,"children":220},{},[221,226],{"type":14,"tag":158,"props":222,"children":223},{},[224],{"type":20,"value":225},"操作对象栈必须模仿",{"type":14,"tag":158,"props":227,"children":228},{},[229],{"type":20,"value":230},"树的模型经常有多余的没必要的计算。",{"type":14,"tag":22,"props":232,"children":233},{},[234],{"type":20,"value":235},"它的设计者还发现它还有一个问题，它不能解析变长的packet headers。（e.g., TCP headers encapsulated in a variable length IP header. Be- cause the CSPF instruction set didn’t include an indirection operator, only packet data at fixed offsets is accessible. Also, the CSPF model is restricted to a single sixteen bit data type which results in a doubling of the number of operations to manipulate 32 bit data such as Internet addresses or TCP se- quence numbers. Finally, the design does not permit access to the last byte of an odd-length packet.）",{"type":14,"tag":22,"props":237,"children":238},{},[239],{"type":20,"value":240},"尽管它有很多缺点，但是它也提供了一个通用的packet filtering思想： 提供一个过滤机制的语言的解释程序在kernel中，提供一个良好过滤机制的描述和实现。自从CSPF看待packet是一个简单的byte array ，过滤模型就和protocol完全独立。(The application that specifies the filter is responsible for encoding the filter appropriately for the underlying net- work media and protocols.)",{"type":14,"tag":22,"props":242,"children":243},{},[244],{"type":20,"value":245},"下一节描述BPF模型，",{"type":14,"tag":202,"props":247,"children":249},{"id":248},"the-bpf-model",[250],{"type":20,"value":251},"the BPF Model",{"type":14,"tag":22,"props":253,"children":254},{},[255],{"type":20,"value":256},"BPF使用CFG过滤器模型，相对于树模型有一个显著的性能提升。尽管树模型可能需要多次冗余地解析数据包，但CFG模型允许将解析信息“内置”到流程图中。也就是说，图中的数据包解析状态是'记住'的，因为你知道你必须经过哪些路径才能到达特定的节点，并且一旦子表达式被评估，就不需要重新计算它，因为控制流图总是可以 (重新)组织，以便仅在遵循原始计算的节点上使用该值。",{"type":14,"tag":22,"props":258,"children":259},{},[260],{"type":14,"tag":68,"props":261,"children":264},{"alt":262,"src":263},"figure 5","https://github.com/ShaneDean/file/blob/master/blog/linux/CFG-Filter-Function-for-host-foo.png?raw=true",[],{"type":14,"tag":22,"props":266,"children":267},{},[268],{"type":20,"value":269},"例如，图5展示了CFG filter function 接受所有来自网络地址 foo的 packets.\n我们考虑网络层协议是IP，ARP和反向ARP的情况，所有这些都包含源和目标Internet地址。过滤器应该捕获所有的情况。相应地，首先测试链路层类型字段。在IP数据包的情况下，IP主机地址字段被查询，而在ARP数据包的情况下使用ARP地址字段。请注意，一旦我们知道该数据包是IP，我们就不需要检查它可能是ARP还是RARP。在表达式树模型中，如图6所示，遍历整个树需要七个比较谓词和六个布尔操作。通过CFG的最长路径有五个比较操作，平均比较次数为三次。",{"type":14,"tag":22,"props":271,"children":272},{},[273],{"type":14,"tag":68,"props":274,"children":277},{"alt":275,"src":276},"figure 6","https://github.com/ShaneDean/file/blob/master/blog/linux/Tree-Filter-Function-for-host-foo.png?raw=true",[],{"type":14,"tag":279,"props":280,"children":282},"h3",{"id":281},"design-of-filter-pseudo-machine",[283],{"type":20,"value":284},"Design of filter pseudo-machine",{"type":14,"tag":22,"props":286,"children":287},{},[288],{"type":20,"value":289},"使用CFG而不是树表达式作为 filter pseudo-machine的理论基础是实现高效的必要步骤，但是这样还不够。在借助 CSPF和NNStat的pseudo-machine 模型经验的公式，BPF模型也经历几代的（几年）设计和测试。我们相信当前的模型能够在不牺牲性能的前提下提供足够的通用性。它的演变受到下面几个设计约束的限制。",{"type":14,"tag":291,"props":292,"children":293},"ol",{},[294,299,304,309,314],{"type":14,"tag":158,"props":295,"children":296},{},[297],{"type":20,"value":298},"必须协议独立。内核不应该通过修改来适应新的协议支持。",{"type":14,"tag":158,"props":300,"children":301},{},[302],{"type":20,"value":303},"必须通用。指令集应该足够丰富，遗嘱里不可预见的用途。",{"type":14,"tag":158,"props":305,"children":306},{},[307],{"type":20,"value":308},"Packet 数据引用必须最小",{"type":14,"tag":158,"props":310,"children":311},{},[312],{"type":20,"value":313},"解码指令中必须包含单一的c语言开关语句",{"type":14,"tag":158,"props":315,"children":316},{},[317],{"type":20,"value":318},"abstract machine寄存器必须存储在物理寄存器中",{"type":14,"tag":22,"props":320,"children":321},{},[322],{"type":14,"tag":68,"props":323,"children":326},{"alt":324,"src":325},"figure 7","https://github.com/ShaneDean/file/blob/master/blog/linux/bpf-program-for-host-foo.png?raw=true",[],{"type":14,"tag":22,"props":328,"children":329},{},[330],{"type":20,"value":331},"图7是对应使用了BPF 指令集的 图5",{"type":14,"tag":202,"props":333,"children":335},{"id":334},"the-bpf-pseudo-machine",[336],{"type":20,"value":337},"The BPF Pseudo-Machine",{"type":14,"tag":22,"props":339,"children":340},{},[341],{"type":20,"value":342},"BPF machine由  accumulator , index register , scratch memory store 和 implicit program counter组成，它们相关的操作可以分成下面几组",{"type":14,"tag":291,"props":344,"children":345},{},[346,361,374,387,400,413],{"type":14,"tag":158,"props":347,"children":348},{},[349,351],{"type":20,"value":350},"LOAD INSTRUCTIONS",{"type":14,"tag":352,"props":353,"children":355},"pre",{"code":354},"将值复制到累加器或变址寄存器中。源可以是立即值，固定偏移量的数据包数据，可变偏移量的数据包数据，数据包长度或临时存储器。\n",[356],{"type":14,"tag":357,"props":358,"children":359},"code",{"__ignoreMap":7},[360],{"type":20,"value":354},{"type":14,"tag":158,"props":362,"children":363},{},[364,366],{"type":20,"value":365},"STORE INSTRUCTIONS",{"type":14,"tag":352,"props":367,"children":369},{"code":368}," 将累加器或索引寄存器复制到暂存存储器中。\n",[370],{"type":14,"tag":357,"props":371,"children":372},{"__ignoreMap":7},[373],{"type":20,"value":368},{"type":14,"tag":158,"props":375,"children":376},{},[377,379],{"type":20,"value":378},"ALU INSTRUCTIONS",{"type":14,"tag":352,"props":380,"children":382},{"code":381},"累加器使用索引寄存器或常量作为操作数。\n",[383],{"type":14,"tag":357,"props":384,"children":385},{"__ignoreMap":7},[386],{"type":20,"value":381},{"type":14,"tag":158,"props":388,"children":389},{},[390,392],{"type":20,"value":391},"BRANCH INSTRUCTIONS",{"type":14,"tag":352,"props":393,"children":395},{"code":394},"根据常数或x寄存器与累加器之间的比较测试改变控制流程。\n",[396],{"type":14,"tag":357,"props":397,"children":398},{"__ignoreMap":7},[399],{"type":20,"value":394},{"type":14,"tag":158,"props":401,"children":402},{},[403,405],{"type":20,"value":404},"RETURNINSTRUCTIONS",{"type":14,"tag":352,"props":406,"children":408},{"code":407},"终止封包，并指明要保存的数据包的哪一部分。如果过滤器返回0，则数据包完全被丢弃。\n",[409],{"type":14,"tag":357,"props":410,"children":411},{"__ignoreMap":7},[412],{"type":20,"value":407},{"type":14,"tag":158,"props":414,"children":415},{},[416,418],{"type":20,"value":417},"MISCELLANEOUS INSTRUCTIONS",{"type":14,"tag":352,"props":419,"children":421},{"code":420},"目前是 register transfer instructions\n",[422],{"type":14,"tag":357,"props":423,"children":424},{"__ignoreMap":7},[425],{"type":20,"value":420},{"type":14,"tag":22,"props":427,"children":428},{},[429],{"type":20,"value":430},"指令格式的定义如下",{"type":14,"tag":352,"props":432,"children":434},{"code":433},"    ---------------------------\n    | opcode:16 | jt:8 | jf:8 |\n    ---------------------------\n    |               k:32            |\n    ---------------------------\n\n    opcode 去顶指令和取址模式\n    jt 和 jf 用来进行条件跳转,t ture, f false\n    k是用于各种目的的通用字段\n    \n",[435],{"type":14,"tag":357,"props":436,"children":437},{"__ignoreMap":7},[438],{"type":20,"value":433},{"type":14,"tag":22,"props":440,"children":441},{},[442],{"type":20,"value":443},"详细的指令集\t见下表",{"type":14,"tag":22,"props":445,"children":446},{},[447],{"type":14,"tag":68,"props":448,"children":451},{"alt":449,"src":450},"table-1","https://github.com/ShaneDean/file/blob/master/blog/linux/table-BPF-instruction.png?raw=true",[],{"type":14,"tag":22,"props":453,"children":454},{},[455],{"type":20,"value":456},"寻址模式\t见下表",{"type":14,"tag":22,"props":458,"children":459},{},[460],{"type":14,"tag":68,"props":461,"children":464},{"alt":462,"src":463},"table-2","https://github.com/ShaneDean/file/blob/master/blog/linux/table-2-BPF-addressing-modes.png?raw=true",[],{"type":14,"tag":202,"props":466,"children":468},{"id":467},"examples",[469],{"type":20,"value":470},"Examples",{"type":14,"tag":352,"props":472,"children":474},{"code":473},"    //filter accepts all IP packets\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0\n\n\n\n    //accepts all ip packages except ,128.3.112 or 128.3.254\n    //mask=24\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L4\n        L1:     ld      [26]        \n                and     #0xffffff00\n                jeq     #0x80037000, L4, L2\n        L2:     jeq     #0x8003fe00, L4, L3\n        L3:     ret     #TRUE\n        L4:     ret     #0\n    \n    其中  #0x80037000 和 #0x8003fe00 就是对应的ip地址\n    \n",[475],{"type":14,"tag":357,"props":476,"children":477},{"__ignoreMap":7},[478],{"type":20,"value":473},{"type":14,"tag":202,"props":480,"children":482},{"id":481},"parsing-packet-headers",[483],{"type":20,"value":484},"Parsing Packet Headers",{"type":14,"tag":22,"props":486,"children":487},{},[488],{"type":20,"value":489},"上面是在假定了数据在packet固定的位置中，但是事实上TCP header是需要根据IP header来计算的。",{"type":14,"tag":352,"props":491,"children":493},{"code":492},"                ldb [14] \n                and #0xf \n                lsh #2\n",[494],{"type":14,"tag":357,"props":495,"children":496},{"__ignoreMap":7},[497],{"type":20,"value":492},{"type":14,"tag":22,"props":499,"children":500},{},[501],{"type":20,"value":502},"一旦IP头的长度算出来，那么TCP section可以被直接访问。",{"type":14,"tag":22,"props":504,"children":505},{},[506],{"type":20,"value":507},"Note that the effective offset has three components.",{"type":14,"tag":154,"props":509,"children":510},{},[511,516,521],{"type":14,"tag":158,"props":512,"children":513},{},[514],{"type":20,"value":515},"ip header length",{"type":14,"tag":158,"props":517,"children":518},{},[519],{"type":20,"value":520},"the link level header length",{"type":14,"tag":158,"props":522,"children":523},{},[524],{"type":20,"value":525},"the data offset relative to the TCP header",{"type":14,"tag":22,"props":527,"children":528},{},[529],{"type":20,"value":530},"假设部分数据 代码如下",{"type":14,"tag":352,"props":532,"children":534},{"code":533},"                ldb     [14] \n                and     #0xf \n                lsh     #2\n                tax\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0      \n",[535],{"type":14,"tag":357,"props":536,"children":537},{"__ignoreMap":7},[538],{"type":20,"value":533},{"type":14,"tag":22,"props":540,"children":541},{},[542,544,550],{"type":20,"value":543},"由于IP报头长度计算是一种常见的操作，因此引入了4 *（",{"type":14,"tag":545,"props":546,"children":547},"span",{},[548],{"type":20,"value":549},"k",{"type":20,"value":551},"＆0xf）寻址模式。用ldx指令代替将过滤器简化为：",{"type":14,"tag":352,"props":553,"children":555},{"code":554},"                ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0  \n",[556],{"type":14,"tag":357,"props":557,"children":558},{"__ignoreMap":7},[559],{"type":20,"value":554},{"type":14,"tag":22,"props":561,"children":562},{},[563],{"type":20,"value":564},"上面的代码我们已经假设了数据是tcp/ip header，现实情况下我们还需要检测  link layer type 是 IP， IP protocol  type是 TCP\t。并且TCP Header 只有第一个fragment包含，其他的包含第一个之后的fragment都会被拒绝。",{"type":14,"tag":352,"props":566,"children":568},{"code":567},"                ldh     [12]\n                jeq     #ETHERPROTO_IP, L1, L2\n        L1:     ldb     [23]\n                jeq     #IPPROTO_TCP, L2, L5\n        L2:     ldh     [20]\n                jset    #0x1fff, L5, L3\n        L3:     ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L4:     ret     #TRUE\n        L5:     ret     #0  \n",[569],{"type":14,"tag":357,"props":570,"children":571},{"__ignoreMap":7},[572],{"type":20,"value":567},{"type":14,"tag":22,"props":574,"children":575},{},[576],{"type":20,"value":577},"##Filter Performance Measurements",{"type":14,"tag":22,"props":579,"children":580},{},[581],{"type":20,"value":582},"略",{"type":14,"tag":202,"props":584,"children":586},{"id":585},"应用",[587],{"type":20,"value":585},{"type":14,"tag":22,"props":589,"children":590},{},[591],{"type":20,"value":592},"tcpdump",{"type":14,"tag":594,"props":595,"children":596},"hr",{},[],{"type":14,"tag":22,"props":598,"children":599},{},[600],{"type":14,"tag":601,"props":602,"children":606},"a",{"href":603,"rel":604},"https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html#icomments",[605],"nofollow",[607],{"type":20,"value":608},"扩展阅读-ebpf",{"type":14,"tag":22,"props":610,"children":611},{},[612],{"type":14,"tag":601,"props":613,"children":616},{"href":614,"rel":615},"https://en.wikipedia.org/wiki/P-code_machine",[605],[617],{"type":20,"value":618},"扩展阅读-pseudo-machine",{"title":7,"searchDepth":620,"depth":620,"links":621},2,[622,623,627,628,629,630],{"id":204,"depth":620,"text":207},{"id":248,"depth":620,"text":251,"children":624},[625],{"id":281,"depth":626,"text":284},3,{"id":334,"depth":620,"text":337},{"id":467,"depth":620,"text":470},{"id":481,"depth":620,"text":484},{"id":585,"depth":620,"text":585},"markdown","content:blog:cs:bpf.md","content","blog/cs/bpf.md","md",1718158598641]