[{"data":1,"prerenderedAt":57},["Reactive",2],{"content-query-jZbheyNvAI":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":52,"_id":53,"_source":54,"_file":55,"_extension":56},"/blog/linux/shell","linux",false,"","shell","参考：http://blog.csdn.net/u010861514/article/details/51028220",{"type":11,"children":12,"toc":49},"root",[13,20,34,39],{"type":14,"tag":15,"props":16,"children":17},"element","h1",{"id":8},[18],{"type":19,"value":8},"text",{"type":14,"tag":21,"props":22,"children":23},"p",{},[24,26],{"type":19,"value":25},"参考：",{"type":14,"tag":27,"props":28,"children":32},"a",{"href":29,"rel":30},"http://blog.csdn.net/u010861514/article/details/51028220",[31],"nofollow",[33],{"type":19,"value":29},{"type":14,"tag":21,"props":35,"children":36},{},[37],{"type":19,"value":38},"留作记录，方便以后查询",{"type":14,"tag":40,"props":41,"children":43},"pre",{"code":42},"shell 基础语法\n===============================================\n推荐：http://c.biancheng.net/cpp/shell/\n===============================================\n第一个Shell脚本\n===============================================\n格式：\n    （1）扩展名为sh（sh代表shell）\n                例如：bash.sh\n    （2）文件头（文件头固定格式）\n                如：#!/bin/bash\n\n作为可执行程序：\n    （1）使脚本具有执行权限\n        ~]# chmod +x ./test.sh\n    （2）执行脚本\n            1：可以不加执行权限\n                ~]$ bash abc.sh     （直接指明文件）\n                ~]$ bash ./abc.sh    （相对路径）\n                ~]$ bash /home/mdx/abc.sh （绝对路径）\n            2：必须加执行权限 （必须是绝对路径或者相对路径）\n                ~]# ./test.sh   （相对路径）\n                ~]$ /home/mdx/test.sh  （绝对路径）\n\n解释器参数（read）：\n        使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：\n        read   [option]  ...  A B\n           -p 'PROMPT'  提示符\n                ~] read -p \"提示符：\"     （接受其传入的参数）\n           -t    TIMEOUT\n\n===============================================\nShell变量\n===============================================\n定义：\n    （1）只能使用字母、数字和下划线；而且不能以数字开头。\n    （2）不能使用标点符号。\n    （3）不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n变量赋值：\n    （1）NAME=VALUE\n            =：赋值符号，两边不能有空格。把VALUE存储到NAME指向的内存空间中\n    （2）declare  命令\n                declare [-aAfFgilrtux] [-p] [name[=value] ...]\n                +:  指定变量的属性\n                -:  取消变量所设的属性\n                -a:  一个使名称索引的数组（如果支持的话）\n                -A:  一个使名称关联数组（如果支持）\n                -i:  “整数”属性\n                -l:  to convert NAMEs to lower case on assignment\n                -r:  名字只读\n                -t:   to make NAMEs have the 'trace' attribute\n                -u:  to convert NAMEs to upper case on assignment\n                -x:   to make NAMEs export\n\n重新赋值变量：\n    （1）NAME=VALUE（再次重新赋值）\n\n变量引用：\n    （1）${NAME}\n    （2）$NAME\n\n只读变量：\n    （1）readonly NAME（变量赋值后定义）\n\n删除变量：\n    （1）unset NAME\n\n变量类型：\n（1) 局部变量\n    局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n（2) 环境变量\n    所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n（3) shell变量\n    shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n===============================================\nShell特殊变量\n===============================================\n（1）$0：当前脚本的文件名\n                ~]# vi test.sh\n                        echo $0\n                ~]# ./test.sh\n                        ./test.sh\n（2）$n：传递给脚本或函数的参数。n 是一个数字，表示第几个参数。\n                ~]# ./test.sh param1 param2 param3 ......\n                ~]# vi test.sh\n                        echo $1 （param1：第1个参数）\n                        echo $2 （param2：第2个参数）\n                        echo $3 （param3：第3个参数）\n                        ......\n（3）$#：传递给脚本或函数的参数个数。\n                ~]# vi test.sh\n                        echo $#\n                ~]# ./test.sh param1 param2 param3 ......\n                        3\n（4）$*：传递给脚本或函数的所有参数。横向显示。\n                ~]# vi test.sh\n                       for var in \"$*\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1 param2 param3 ....\n（5）$@：传递给脚本或函数的所有参数。竖向显示。\n                ~]# vi test.sh\n                       for var in \"$@\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1\n                        param2\n                        param3\n                        ...\n（6）$?：上个命令的执行状态，或函数的返回值。\n                成功：0\n                失败：1-255\n（7）$$：当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。\n                ~]# vi test.sh\n                       echo $$\n                ~]# ./test.sh \n                        14781\n\n===============================================\nShell替换\n===============================================\n转义字符：\n    （1）\\\\  反斜杠\n    （2） \\a  警报，响铃\n    （3） \\b  退格（删除键）\n    （4） \\f  换页(FF)，将当前位置移到下页开头\n    （5） \\n  换行\n    （6） \\r  回车\n    （7） \\t  水平制表符（tab键）\n    （8） \\v  垂直制表符\n\n命令替换：\n    （1）：`command` 反引号\n    （2）：$(command)\n\n变量替换：\n    （1）${var}  变量本来的值\n    （2）${var:-word}    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n    （3）${var:=word}    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n    （4）${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n    （5）${var:+word}    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\n===============================================\nShell运算符\n===============================================\n 条件测试：\n    （1） test  EXPRESSION \n    （2）[ EXPRESSION ]\n    （3）[[ EXPRESSION ]]                       \n\n算术运算符\n    （1）+：加法\n    （2）-：减法\n    （3）*：乘法\n    （4）/：除法\n    （5）%：取余\n    （6）=：赋值\n    （7）==：相等\n    （8）!=：不相等\n\n    计算方式：\n        （1）expr\n                expr $a + $b\n                $(expr $a + $b)\n                `expr $a + $b`   （注意：这是反引号）\n                注意：符号号两边有空格\n        （2）$[$a+$b]\n        （3）let\n                let \"c = $a + $b\"  或者  let \"c=$a+$b\"  （注意：这是双引号）\n                let c=$a+$b （ 注意：符号号两边没有空格）\n        （4）$((expression))\n                c=$(( $a + $b ))\n                备注：空格可有可无\n\n数字运算符：\n    （1）-eq   是否等于  \n    （2）-ne   是否不等于\n    （3）-gt   是否大于\n    （4）-lt   小于    \n    （5）-ge  大于等于\n    （6）-le   是否小于等于 \n\n布尔运算符：\n        （1）-not  非运算。\n        （2）-o  或运算。\n        （3）-a  与运算。\n        （4）! 非运算。\n        （5）&& 与运算。\n        （6）||  或运算。\n\n字符串运算符：\n    （1）=  相等。\n    （2）!= 不相等。\n    （3）-z   判断字符串是否为空\n    （4）-n   判断字符串是否不为空\n    （5）str： 检测字符串是否为空。\n\n文件测试运算符：\n        -b file： 检测文件是否是块设备文件，\n        -c file： 检测文件是否是字符设备文件，\n        -d file： 检测文件是否是目录，\n        -f file： 检测文件是否是普通文件（既不是目录，也不是设备文件），\n        -g file： 检测文件是否设置了 SGID 位，\n        -k file： 检测文件是否设置了粘着位(Sticky Bit)，\n        -p file： 检测文件是否是具名管道，\n        -u file： 检测文件是否设置了 SUID 位，\n        -r file： 检测文件是否可读，\n        -w file： 检测文件是否可写，\n        -x file： 检测文件是否可执行，\n        -s file： 检测文件是否为空（文件大小是否大于0），不为空返回 true。\n        -a file： 检测文件（包括目录）是否存在，（-a 等同于 -e）\n        -e file： 检测文件（包括目录）是否存在，\n        -N  file   文件自从上一次读操作之后，是否被改过 \n        -O  file 当前用户是否为文件的属主\n        -G  file  当前用户是否为文件的属组\n\n      双目测试\n        FILE1 -ef FILE2  是否指向同一个文件系统的相同inode的硬链接\n        FILE1  -nt FILE2  FILE1文件，是否新于FILE2\n        FILE1 -ot  FILE2  FILE1文件，是否旧于FILE2\n\n其他运算符：\n    ?: 三元运算符\n    =~  左侧字符串是否能够被右侧的PATTERN所匹配 （说人话  包含）\n\n---------------------------------------------------------------------------------------\nlet 与 expr 语法详解\n---------------------------------------------------------------------------------------\nlet：评估算术表达式\n        id++, id--  variable post-increment, post-decrement\n        ++id, --id  variable pre-increment, pre-decrement\n        -, +        unary minus, plus\n        !, ~        logical and bitwise negation\n        **      exponentiation\n        *, /, %     multiplication, division, remainder\n        +, -        addition, subtraction\n        \u003C\u003C, >>      left and right bitwise shifts\n        \u003C=, >=, \u003C, >    comparison\n        ==, !=      equality, inequality\n        &       bitwise AND\n        ^       bitwise XOR\n        |       bitwise OR\n        &&      logical AND\n        ||      logical OR\n        expr ? expr : expr\n                conditional operator\n        =, *=, /=, %=,\n        +=, -=, \u003C\u003C=, >>=,\n        &=, ^=, |=  assignment\n---------------------------------------------------------------------------------------\nexpr：评价表达式 \n       ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n       ARG1 & ARG2  ARG1 if neither argument is null or 0, otherwise 0\n       ARG1 \u003C ARG2    ARG1 is less than ARG2\n       ARG1 \u003C= ARG2  ARG1 is less than or equal to ARG2\n       ARG1 = ARG2   ARG1 is equal to ARG2\n       ARG1 != ARG2   ARG1 is unequal to ARG2\n       ARG1 >= ARG2  ARG1 is greater than or equal to ARG2\n       ARG1 > ARG2  ARG1 is greater than ARG2\n       ARG1 + ARG2  arithmetic sum of ARG1 and ARG2\n       ARG1 - ARG2  arithmetic difference of ARG1 and ARG2\n       ARG1 * ARG2  arithmetic product of ARG1 and ARG2\n       ARG1 / ARG2  arithmetic quotient of ARG1 divided by ARG2\n       ARG1 % ARG2  arithmetic remainder of ARG1 divided by ARG2\n       STRING : REGEXP  anchored pattern match of REGEXP in STRING\n       match STRING REGEXP     same as STRING : REGEXP\n       substr STRING POS LENGTH  substring of STRING, POS counted from 1\n       index STRING CHARS   index in STRING where any CHARS is found, or 0\n       length STRING   length of STRING\n       + TOKEN\n              interpret TOKEN as a string, even if it is a\n              keyword like 'match' or an operator like '/'\n       ( EXPRESSION )\n              value of EXPRESSION\n---------------------------------------------------------------------------------------\n\n\n\n===============================================\nShell注释\n===============================================\n以“#”开头的行就是注释，会被解释器忽略。\n\n===============================================\nShell字符串\n===============================================\n单引号：str='this is a string'\n    注意：\n    单引号里的任何字符都会原样输出。\n双引号：your_name=\"qinj\"\n    注意：\n        双引号里变量正常输出\n---------------------------------------------------------------------------------------\n字符串切片：${var:offset:number}\n    示例：\n        1：取字符串的子串\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:3}\n            ~]# ./bash.sh\n            ~]# defg\n        2：${var:  -length}：取字符的最右侧的几个字符。\n            ~]# vi bash.sh \n                var='abcdefg'\n                echo ${var: -3}   #注意：冒号后必须有一个空白字符\n            ~]# ./bash.sh\n            ~]# efg\n        3：从左向右截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:2:2}\n            ~]# ./bash.sh\n            ~]# cd\n        4：从右向左截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var: -4:2}\n            ~]# ./bash.sh\n            ~]# de\n---------------------------------------------------------------------------------------\n基于模式取子串：\n    1：${var#*word}：删除字符串开头至此分隔符之间的所有字符。\n            示例：\n                ~]# vi bash.sh\n                    var='abc/de/fg'\n                    echo ${var#*/}\n                ~]# ./bash.sh \n                    de/fg\n\n    2：${var##*word}：删除字符串开头至此分隔符之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var##*/}\n            ~]# ./bash.sh \n                fg\n\n    3：${var%word*}：删除此分隔符至字符串尾部之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var%/*}\n            ~]# ./bash.sh \n                abc/de\n\n    4：${var%%word*}：删除此分隔符至字符串尾部之间的所有字符；\n            示例：\n                ~]# cat bash.sh \n                        var='abc/de/fg'\n                        echo ${var%%/*}\n                ~]# ./bash.sh \n                        abc\n---------------------------------------------------------------------------------------\n查找替换：（PATTERN中使用glob风格和通配符）\n    1：${var/PATTERN/SUBSTI}：查找var所表示的字符串中，第一次被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n            示例：\n                ~]# vi ./bash.sh \n                    var='aaabbbcccaaabbbccc'\n                    echo ${var/bbb/字符串}\n                ~]# ./bash.sh \n                    aaa字符串cccaaabbbccc\n\n    :2：${var//PATTERN/SUBSTI}：查找var所表示的字符串中，所有被PATTERN所匹配到的字符串，并将其全部替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var//bbb/字符串}\n            ~]# ./bash.sh \n                aaa字符串cccaaa字符串ccc\n\n    3：${var/#PATTERN/SUBSTI}：查找var所表示的字符串中，行首被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN/SUBSTI}：查找var所表示的字符串中，行尾被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n查找删除：\n    1：${var/PATTERN}：删除第一次的匹配；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/cc/字符串}\n            ~]# ./bash.sh \n                aaabbb字符串caaabbbccc\n\n    2：${var//PATERN}：删除最后一次匹配\n        示例：\n        ~]# vi bash.sh \n            var='aaabbbcccaaabbbccc'\n            echo ${var//cc/字符串}\n        ~]# ./bash.sh \n            aaabbb字符串caaabbb字符串c\n\n    3：${var/#PATTERN}：删除行首匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN}：删除行尾匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n字符大小写转换：\n    1：${var^^}：所有字符转换为大写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var^^}\n            ~]# ./bash.sh \n                AAABBBCCCAAABBBCCC\n\n    :2：${var,,}：所有字符转换为小写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var,,}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbccc\n---------------------------------------------------------------------------------------\n变量赋值：\n    1：${var:-VALUE}：如果var变量为空，或未设置，那么返回VALUE；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:-string}\n                echo ${ar:-string}\n            ~]# ./bash.sh \n                字符串\n                string\n\n    2：${var:=VALUE}：如果var变量为空，或未设置，那么返回VALUE，并将VALUE赋值给var变量；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:=string}\n                echo ${ar:=string}\n                echo $ar\n            ~]# ./bash.sh \n                字符串\n                string\n                string\n\n    3：${var:+VALUE}：如果var变量不为空，则返回VALUE；\n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:+string}\n            ~]# ./bash.sh \n                string\n\n    4：${var:?ERROR_INFO}：如果var为空，或未设置，那么返回ERROR_INFO为错误提示；否则，返回var值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:?string}\n                echo ${ar:?错误信息}\n            ~]# ./bash.sh \n                字符串\n                ./bash.sh: line 4: ar: 错误信息\n---------------------------------------------------------------------------------------\n拼接字符串\n    示例：\n        ~]# vi bash.sh\n            your_name=\"qinjx\"\n            greeting=\"hello, \"$your_name\" !\"\n            greeting_1=\"hello, ${your_name} !\"\n            echo $greeting $greeting_1\n        ~]# ./bash.sh\n            hello, qinjx ! hello, qinjx !\n---------------------------------------------------------------------------------------\n获取字符串长度：${#string}\n    示例：\n        ~]# vi bash.sh \n            string='abcd'\n            echo ${#string}\n            echo $(expr length $string)\n        ~]# ./bash.sh \n            4\n            4\n===============================================\nShell if else语句\n===============================================\n（1）单分支1\n        if CONDITION ; then\n            分支\n        fi\n（2）单分支2\n        if CONDITION ; then\n            分支1\n        else\n            分支2\n        fi\n（3）多分支1\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        elif CONDITION; then\n                分支n\n        fi\n（4）多分支2\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        else CONDITION; then\n                    分支n\n        fi\n\n语法：then可换行写，condition后面就不用加分号。\n        if CONDITION\n        then\n            分支\n        fi\n===============================================\nShell case esac语句\n===============================================\n（1）语法结构\n        case  $VARAIBLE  in  \n        PAT1)\n            分支1\n            ;;\n        PAT2)\n            分支2\n            ;;\n        ...\n        *)\n            分支n\n            ;;\n        esac\n\n示例：\n    value='c'\n    case $value in\n    a)\n        echo '这是a' # 可以是单引号或者双引号\n        ;;\n    b)\n        if [0 -le 18];then  # 可以是一段代码\n            echo '一个判断'\n        fi\n        ;;\n    c)\n        echo 这是c\n        ;; # 必须以;;为结束\n    *)\n        echo \"未匹配到上面的结果,在此可以执行一段代码或者不写 *) 这一部分\"\n        ;;\n    esac\n    \n    结果：\n        这是c\n===============================================\nShell for循环\n===============================================\n（1）语法结构\n    for 变量 in 列表; do\n        command\n    done\n\n示例：\n    1：详细输出，依次输出1,2,3,4,5 \n        for File in 1 2 3 4 5 \n        do \n            echo $File \n        done\n    2：输出某个目录下所有的文件或者匹配到的文件\n        for file in $HOME/.bash*; do        # 也可以写 $HOME/*\n            echo $file\n        done\n    3：{开始正整数..结束正整数}：注意：中间是两个点\n        for num in {1..5}; do\n            echo $num           # 输出数字 1-5 的正整数\n        done\n    4：((i=1; i\u003C=5; i++ ))：每次循环加1\n        for((i=1; i\u003C=5; i++ )); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    5：执行命令 seq：起始从1开始\n        for i in $(seq 5); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    6：执行命令\n        for i in $(ls /); do\n            echo $i\n        done\n\n语法：do可以换行写，那里就不需要分号了。\n===============================================\nShell while循环\n===============================================\n（1）语法结构\n        while  CONDITION; do\n            代码....\n        done\n\n        注意：\n        进入条件： CONDITION 测试为”真“\n        退出条件： CONDITION 测试为”假“\n\n示例：\n（1）\n    declare -i i=1\n    while [ $i -le 5 ]; do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    while (( $i \u003C= 5 )); do\n        echo $i\n        let i++\n    done\n\n===============================================\nShell until循环\n===============================================\n（1）语法结构\n        until  CONDITION; do\n            循环体\n            循环控制变量修正表达式\n        done\n\n        注意：\n        进入条件：CONDITION测试为”假“\n        退出条件：CONDITION测试为”真“    \n\n示例：\n    declare -i i=1\n    until (( $i > 5 )); do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    until [ $i -gt 5 ]; do\n        echo $i\n        let i++\n    done\n===============================================\nShell跳出循环\n===============================================\n（1）continue：跳过本次循环，执行下一次循环\n（2）break：退出循环\n\n===============================================\nShell函数\n===============================================\n（1）语法一：\n        function  f_name  {\n            ...函数体...\n        }\n            \n（2）语法二：\n        f_name()  {\n            ...函数体...\n        }\n\n执行函数：\n    f_name\n\n    示例：\n        1：    #函数的声明\n                function fname {\n                    echo '我是语法一函数'\n                }\n                # 执行函数\n                fname\n\n        2：   # 函数的声明\n            fname(){\n                echo '我是语法二函数'\n            }\n            # 执行函数\n            fname\n\n参数：\n    （1）$1，$2, ...\n    （2）$#   $@ $*\n        \n        示例：\n                function fname {\n                    echo \"第一个参数：$1\"\n                    echo \"第二个参数：$2\"\n                    # echo \"第N个参数：$n\"\n                    echo \"参数总数：$#\"\n                    echo \"参数字符串: $@\"\n                    echo \"参数字符串: $*\"\n                }\n                #执行函数，并传入参数\n                fname 1 2\n            结果：\n                第一个参数：1\n                第二个参数：2\n                参数总数：2\n                参数字符串: 1 2\n                参数字符串: 1 2\n\nreturn：返回退出状态码，shell不退出\n    示例：\n        function fname {\n            return 1\n        }\n        fname\n        echo $?\n    结果：\n        1\n\nexit：返回状态码并推出\n\n作用域：\n    （1）全局作用域：没有使用 local 关键字；语法：VARIABLE=VALUE\n    （2）局部作用域：函数内部声明并且使用 local 关键字，仅在函数内部有效：语法：local VARIABLE=VALUE\n\n        示例：\n            name=tom    # 全局作用域\n            setname() {\n                local name=jerry        # 局部作用域,仅在函数内部有效。\n                    echo \"局部: $name\"\n            }\n            setname         #执行函数\n            echo \"全局: $name\"\n===============================================\nShell数组\n===============================================\n声明数组：\n        declare  -a  NAME：声明索引数组；\n        declare  -A  NAME：声明关联数组；\n\n数组中元素的赋值方式：\n            (1) 一次只赋值一个元素；\n                ARRAY_NAME[INDEX]=value\n                示例：索引数组\n                    declare -a index_array;\n                    index_array[0]=0\n                    index_array[1]=1\n                    echo ${index_array[0]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name[aa]=aaaa\n                    array_name[bb]=bbbb\n                    echo ${array_name[aa]}\n            (2) 一次赋值全部元素；\n                ARRAY_NAME=(\"VAL1\"  \"VAL2\"  \"VAL3\"  ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=('val0' 'val1' 'val2')\n                    echo ${index_array[0]}\n\n            (3) 只赋值特定元素；\n                ARRAY_NAME=([0]=\"VAL1\"  [3]=\"VAL4\" ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=([0]='val0' [3]='val1' [6]='val2')\n                    echo ${index_array[6]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name=([aa]='aaaa' [bb]='bbbb')\n                    echo ${array_name[aa]}\n\n\n                注意：bash支持稀疏格式的数组；\n\n            (4) read  -a  ARRAY_NAME\n                示例：\n                    read -p \"输入参数: \" -a array_name\n                    echo ${array_name[0]}\n\n\n       （5） 引用数组中的元素：${ARRAY_NAME[INDEX]}\n        注意：引用时，只给数组名，表示引用下标为0的元素；\n\n        （6）数组的长度（数组中元素的个数）:\n            ${#ARRAY_NAME[*]}\n            ${#ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${#array_name[@]}\n                echo ${#array_name[*]}\n                结果：\n                    3\n                    3\n\n        （7）数组的参数（数组中所有的参数）：\n            ${ARRAY_NAME[*]}\n            ${ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${array_name[@]}\n                echo ${array_name[*]}\n            结果：\n                00000 1111 2222\n                00000 1111 2222\n===============================================\nShell输入输出重定向\n===============================================\n推荐：http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html\n\nlinux shell下常用输入输出操作符是：\n1.  标准输入   (stdin) ：代码为 0 ，使用 \u003C 或 \u003C\u003C ； /dev/stdin -> /proc/self/fd/0   0代表：/dev/stdin \n2.  标准输出   (stdout)：代码为 1 ，使用 > 或 >> ； /dev/stdout -> /proc/self/fd/1  1代表：/dev/stdout\n3.  标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ； /dev/stderr -> /proc/self/fd/2 2代表：/dev/stderr\n\n输出重定向：\n    1：重定向程序正常执行的结果\n    覆盖重定向：覆盖目标文件中的原有内容；\n        COMMAND >  /PATH/TO/SOMEFILE\n    追加重定向：追加新产生的内容至目标文件尾部；\n        COMMAND >> /PATH/TO/SOMEFILE\n\n    shell的一个功能开关：\n        # set -C\n            禁止覆盖输出重定向至已存在的文件；\n            注意：此时仍然可以使用“>|”至目标文件； \n        # set +C\n            关闭上述特性；\n                        \n错误重定向：\n                重定向错误的执行结果；\n                \n                    COMMAND 2>  /PATH/TO/SOMEFILE\n                        错误输出覆盖重定向；\n                    COMMAND 2>> /PATH/TO/SOMEFILE\n                        错误输出追加重定向；\n                        \n合并标准输出与错误输出流：\n                (1) &>, &>>\n                (2) COMMAND > /PATH/TO/SOMEFILE 2>&1\n                      COMMAND >> /PATH/TO/SOMEFILE 2>&1\n                      \n            特殊输出目标：/dev/null\n                位桶：bit bucket\n            特殊的输入文件：/dev/zero\n\n输入重定向：\n            COMMAND \u003C /PATH/FROM/SOMEFILE\n            COMMAND \u003C\u003C ：\n            Here Document\n\n            用法：\n                COMMAND \u003C\u003C EOF\n                COMMAND > /PATH/TO/SOMEFILE \u003C\u003C EOF\n===============================================\nShell文件包含  . 与 source\n===============================================\n文件包含：. （点） 与 source 都可以引入文件\n注意：\n    1：被引入的文件不需要执行权限\n    2：可以没有 #!/bin/bash\n    3：被引入程序当做一个可执行的脚本运行。\n\n示例：\n~]# vi bash.sh \n    #!/bin/bash\n    # 引入 config.sh 文件\n    . ./config.sh\n    # 引入 cfg 文件\n    source ./cfg\n    echo $string\n    echo $cfg\n~]# vi cfg\n    cfg='cfg文件'\n~]# vi config.sh \n    #!/bin/bash\n    string='config文件'\n~]# ./bash.sh\n    config文件\n    cfg文件\n",[44],{"type":14,"tag":45,"props":46,"children":47},"code",{"__ignoreMap":7},[48],{"type":19,"value":42},{"title":7,"searchDepth":50,"depth":50,"links":51},2,[],"markdown","content:blog:linux:shell.md","content","blog/linux/shell.md","md",1718158598646]