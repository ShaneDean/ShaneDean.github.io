[{"data":1,"prerenderedAt":284},["Reactive",2],{"content-query-r7eExnbmPy":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"body":9,"_type":279,"_id":280,"_source":281,"_file":282,"_extension":283},"/blog/linux/libseccomp","linux",false,"","libseccomp",{"type":10,"children":11,"toc":273},"root",[12,19,25,31,36,41,46,51,61,65,70,75,80,88,93,98,106,111,119,124,132,137,145,150,158,163,171,176,201,206,211,216,221,226,234,247,252,260,265],{"type":13,"tag":14,"props":15,"children":16},"element","h1",{"id":8},[17],{"type":18,"value":8},"text",{"type":13,"tag":20,"props":21,"children":23},"h2",{"id":22},"说明",[24],{"type":18,"value":22},{"type":13,"tag":26,"props":27,"children":28},"p",{},[29],{"type":18,"value":30},"seccomp(全称securecomputing mode) 是linuxkernel从2.6.23版本开始所支持的一种安全机制。",{"type":13,"tag":26,"props":32,"children":33},{},[34],{"type":18,"value":35},"在Linux系统里,大量的系统调用(systemcall)直接暴露给用户态程序。",{"type":13,"tag":26,"props":37,"children":38},{},[39],{"type":18,"value":40},"但是,并不是所有的系统调用都被需要,而且不安全的代码滥用系统调用会对系统造成安全威胁。",{"type":13,"tag":26,"props":42,"children":43},{},[44],{"type":18,"value":45},"通过seccomp,我们限制程序使用某些系统调用,这样可以减少系统的暴露面,同时是程序进入一种“安全”的状态。",{"type":13,"tag":20,"props":47,"children":49},{"id":48},"编译",[50],{"type":18,"value":48},{"type":13,"tag":52,"props":53,"children":55},"pre",{"code":54},"git clone https://github.com/seccomp/libseccomp.git\n//自己选择 tag 或 branch 默认最新\n./autogen.sh            //需要autoconf automake\n./configure\nmake V=1\nmake install\nmake check\n\n在构建完成之后，doc/man目录下面有可以参考的手册，通过man xxxx 来查询详细的使用用法\n\n其他的一些参考资料\nDocumentation/prctl/seccomp_filter.txt\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\nhttp://man7.org/linux/man-pages/man2/seccomp.2.html\n",[56],{"type":13,"tag":57,"props":58,"children":59},"code",{"__ignoreMap":7},[60],{"type":18,"value":54},{"type":13,"tag":62,"props":63,"children":64},"hr",{},[],{"type":13,"tag":20,"props":66,"children":68},{"id":67},"项目构建",[69],{"type":18,"value":67},{"type":13,"tag":26,"props":71,"children":72},{},[73],{"type":18,"value":74},"libseccomp是由 automake 组织构建的。",{"type":13,"tag":26,"props":76,"children":77},{},[78],{"type":18,"value":79},"先看 configure.ac文件",{"type":13,"tag":52,"props":81,"children":83},{"code":82},"\nAC_INIT([libseccomp], [2.3.3])      //定义了包名和版本号\n\nAC_CONFIG_AUX_DIR([build-aux])      //辅助工具的存放路径\n\nAC_CONFIG_HEADERS([configure.h])    //宏定义变量的变量集合\n\nAC_CONFIG_MACRO_DIR([m4])           //指定本地autoconf宏的位置,m4文件夹下定义了check-code-coverage\n\n\n//m4 中  define (name, [expansion])\nm4_define([serial_tests], [\n    //m4 中  esyscmd(shell-command)\n    m4_esyscmd([automake --version |\n                head -1 |\n                awk '{split ($NF,a,\".\"); if (a[1] == 1 && a[2] >= 12) { print \"serial-tests\" }}'\n    ])\n])\n//根据automake的版本去\n\n\nAM_INIT_AUTOMAKE(-Wall foreign subdir-objects tar-pax serial_tests)     //增加make  的 options\n\n\nAC_PROG_CC              //检查要使用的c编译器\nAM_PROG_CC_C_O          //测试上面的次编译器的 -c 和 -o\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([shared pic-only])      //启用libtool\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])       //减少构建输出\n\n\nAM_CPPFLAGS=\"-I\\${top_srcdir}/include\"      //cpp flags\nAM_CFLAGS=\"-Wall\"                           //c   flags\nAM_LDFLAGS=\"-Wl,-z -Wl,relro\"               //ld  flags\nAC_SUBST([AM_CPPFLAGS])             //加入变量\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n\nAC_CHECK_HEADERS_ONCE([linux/seccomp.h])        //检查下这个文件是否存在\n\n\n//获取版本信息\nVERSION_MAJOR=$(echo ${VERSION} | cut -d'.' -f 1)\nVERSION_MINOR=$(echo ${VERSION} | cut -d'.' -f 2)\nVERSION_MICRO=$(echo ${VERSION} | cut -d'.' -f 3)\nAC_SUBST([VERSION_MAJOR])\nAC_SUBST([VERSION_MINOR])\nAC_SUBST([VERSION_MICRO])\n\n// cython checks   略\n// python binding checks   略\n// coverity checks 略\n// code coverage checks\n\n//指明需要版本信息来生成的文件\nAC_CONFIG_FILES([\n    libseccomp.pc\n    include/seccomp.h\n])\n\n//指明需要生成的各级Makefile\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    src/Makefile\n    src/python/Makefile\n    tools/Makefile\n    tests/Makefile\n    doc/Makefile\n])\n\n",[84],{"type":13,"tag":57,"props":85,"children":86},{"__ignoreMap":7},[87],{"type":18,"value":82},{"type":13,"tag":26,"props":89,"children":90},{},[91],{"type":18,"value":92},"再看 makefile.am文件",{"type":13,"tag":26,"props":94,"children":95},{},[96],{"type":18,"value":97},"顶层目录的makefile",{"type":13,"tag":52,"props":99,"children":101},{"code":100},"    ACLOCAL_AMFLAGS =-I m4      //需要引用的宏的地址\n    SUBDIRS = include src tools tests doc   //下级 makefile.am地址\n    \n    pkgconfdir = ${libdir}/pkgconfig    \n    pkgconf_DATA = libseccomp.pc\n    \n    EXTRA_DIST = CHANGELOG CREDITS LICENSE README.md SUBMITTING_PATCHES     //规范中没有定义，但是选上的文件\n\n    \n    //配置静默安装\n    AM_MAKEFLAGS_0 = --quiet --no-print-directory\n    AM_MAKEFLAGS_1 =\n    AM_MAKEFLAGS_ = ${AM_MAKEFLAGS_0}\n    AM_MAKEFLAGS = ${AM_MAKEFLAGS_@AM_V@}\n    \n    \n    //切到src和tests中构建\n    check-build: all\n    ${MAKE} ${AM_MAKEFLAGS} -C src check-build      \n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-build\n    \n    check-syntax:\n    @./tools/check-syntax       //使用astyle来优化代码格式\n    \n    check-code-coverage: check-build\n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-code-coverage    \n    \n",[102],{"type":13,"tag":57,"props":103,"children":104},{"__ignoreMap":7},[105],{"type":18,"value":100},{"type":13,"tag":26,"props":107,"children":108},{},[109],{"type":18,"value":110},"按照SUBDIRS的顺序依次进入子目录， 首先是include。",{"type":13,"tag":52,"props":112,"children":114},{"code":113},"    include_HEADERS = seccomp.h\n",[115],{"type":13,"tag":57,"props":116,"children":117},{"__ignoreMap":7},[118],{"type":18,"value":113},{"type":13,"tag":26,"props":120,"children":121},{},[122],{"type":18,"value":123},"src目录",{"type":13,"tag":52,"props":125,"children":127},{"code":126},"    //看是否开启Python，开启的话则增加PYTHON到子目录中\n    SUBDIRS = .\n    if ENABLE_PYTHON\n    SUBDIRS += python\n    endif  \n    \n    SOURCE_ALL = ...    //所有的源文件\n    \n    EXTRA_DIST = arch-syscall-validate\n\n    TESTS = arch-syscall-check\n    \n    check_PROGRAMS = arch-syscall-check arch-syscall-dump   //指定系统的测试程序\n    \n    lib_LTLIBRARIES = libseccomp.la\n    \n    arch_syscall_dump_SOURCES = arch-syscall-dump.c ${SOURCES_ALL}\n\n    arch_syscall_check_SOURCES = arch-syscall-check.c ${SOURCES_ALL}\n\n    libseccomp_la_SOURCES = ${SOURCES_ALL}\n    libseccomp_la_CPPFLAGS = ${AM_CPPFLAGS} ${CODE_COVERAGE_CPPFLAGS} \\\n        -I${top_builddir}/include\n    libseccomp_la_CFLAGS = ${AM_CFLAGS} ${CODE_COVERAGE_CFLAGS} ${CFLAGS} \\\n        -fPIC -DPIC -fvisibility=hidden\n    libseccomp_la_LDFLAGS = ${AM_LDFLAGS} ${CODE_COVERAGE_LDFLAGS} ${LDFLAGS} \\\n        -version-number ${VERSION_MAJOR}:${VERSION_MINOR}:${VERSION_MICRO}\n    \n    check-build:\n        ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}       \n    \n",[128],{"type":13,"tag":57,"props":129,"children":130},{"__ignoreMap":7},[131],{"type":18,"value":126},{"type":13,"tag":26,"props":133,"children":134},{},[135],{"type":18,"value":136},"tools的makefile.am",{"type":13,"tag":52,"props":138,"children":140},{"code":139},"AM_CPPFLAGS = -I${top_builddir}/include\n\nnoinst_LTLIBRARIES = util.la        //lib_LTLIBRARIES\nutil_la_SOURCES = util.c util.h bpf.h\nutil_la_LDFLAGS = -module\n\n    //安装的程序\nbin_PROGRAMS = \\\n    scmp_sys_resolver\n    \n    //没有安装的程序\nnoinst_PROGRAMS = \\\n    scmp_arch_detect \\\n    scmp_bpf_disasm \\\n    scmp_bpf_sim\n    \nEXTRA_DIST = check-syntax scmp_app_inspector\n\nscmp_bpf_disasm_SOURCES = scmp_bpf_disasm.c bpf.h util.h\nscmp_bpf_sim_SOURCES = scmp_bpf_sim.c bpf.h util.h\n\nscmp_sys_resolver_LDADD = ../src/libseccomp.la\nscmp_sys_resolver_LDFLAGS = -static\nscmp_arch_detect_LDADD = ../src/libseccomp.la\nscmp_arch_detect_LDFLAGS = -static\nscmp_bpf_disasm_LDADD = util.la\nscmp_bpf_sim_LDADD = util.la\n\n\n",[141],{"type":13,"tag":57,"props":142,"children":143},{"__ignoreMap":7},[144],{"type":18,"value":139},{"type":13,"tag":26,"props":146,"children":147},{},[148],{"type":18,"value":149},"test中的makefile.am",{"type":13,"tag":52,"props":151,"children":153},{"code":152},"\n//code_coverage_rules  略\n\nLDADD = util.la ../src/libseccomp.la \n\ncheck_LTLIBRARIES = util.la\nutil_la_SOURCES = util.c util.h\nutil_la_LDFLAGS = -module\n\nTESTS = regression    //主体的测试程序\n\ncheck_PROGRAMS = ...\n\nEXTRA_DIST_TESTPYTHON = ...\n\nEXTRA_DIST_TESTCFGS = ...\n\nEXTRA_DIST_TESTSCRIPTS = regression testdiff testgen    // 3个测试脚本\n\nEXTRA_DIST_TESTVALGRIND = valgrind_test.supp\n\nnodist_00_test_SOURCES = 00-test.c\nEXTRA_PROGRAMS = 00-test\n\ncheck-build:\n    ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}\n\nclean-local:\n    ${RM} -f 00-test *.pyc\n\n",[154],{"type":13,"tag":57,"props":155,"children":156},{"__ignoreMap":7},[157],{"type":18,"value":152},{"type":13,"tag":26,"props":159,"children":160},{},[161],{"type":18,"value":162},"doc的就略过了，  筛选出关键的外部程序或脚本",{"type":13,"tag":52,"props":164,"children":166},{"code":165},"    regression \n    \n    testdiff \\ testgen   // compare test output from different test runs  \n\n    check-syntax   //  a basic C style/format checking tool\n    \n    scmp_app_inspector  //a simple syscall inspector based on strace\n\n    scmp_sys_resolver \\ scmp_arch_detect \\   scmp_bpf_disasm \\  scmp_bpf_sim\n    \n    arch-syscall-validate       //a simple syscall validation tool\n\n    \n",[167],{"type":13,"tag":57,"props":168,"children":169},{"__ignoreMap":7},[170],{"type":18,"value":165},{"type":13,"tag":26,"props":172,"children":173},{},[174],{"type":18,"value":175},"进入tests目录",{"type":13,"tag":26,"props":177,"children":178},{},[179,181,187,189,194,196],{"type":18,"value":180},"发现   ",{"type":13,"tag":182,"props":183,"children":184},"span",{},[185],{"type":18,"value":186},"数字",{"type":18,"value":188},"-",{"type":13,"tag":182,"props":190,"children":191},{},[192],{"type":18,"value":193},"名称",{"type":18,"value":195},".",{"type":13,"tag":182,"props":197,"children":198},{},[199],{"type":18,"value":200},"c\\py\\tests",{"type":13,"tag":26,"props":202,"children":203},{},[204],{"type":18,"value":205},"这是   regression脚本对上面的文件进行libseccomp的测试",{"type":13,"tag":26,"props":207,"children":208},{},[209],{"type":18,"value":210},"其中  .c和 .py是测试的主题逻辑",{"type":13,"tag":26,"props":212,"children":213},{},[214],{"type":18,"value":215},".test文件则是参与测试的样例数据",{"type":13,"tag":26,"props":217,"children":218},{},[219],{"type":18,"value":220},"其中主体的测试控制程序是 regression ， 可以通过 -h 来查看使用方法，默认不增加参数即可开启测试",{"type":13,"tag":26,"props":222,"children":223},{},[224],{"type":18,"value":225},"regression是一个shell程序，分析其代码：",{"type":13,"tag":52,"props":227,"children":229},{"code":228},"        run_tests\n        |-->    run_test $batch_name $testnum $line $test_type\n        |       //其中举例 01-sim-allow.tests\n        |       //         01-sim-allow  01 \"01-sim-allow   all  0-350  N   N   N   N   N   N   ALLOW\"  bpf-sim\n            |-->\n                    |       run_test_basic\n                    |       run_test_bpf_sim_fuzz\n                    |       run_test_bpf_valgrind\n                    |       run_test_live\n                    |-->    run_test_bpf_sim     01-sim-allow  01   \"01-sim-allow    all    0-350   N   N   N   N   N   N   ALLOW\" \n                            |--> run_test_command \"$testnumstr\" \"./$testname\" \"-b\" 4 \"\"\n                                    |-->  01-sim-allow\n\n",[230],{"type":13,"tag":57,"props":231,"children":232},{"__ignoreMap":7},[233],{"type":18,"value":228},{"type":13,"tag":26,"props":235,"children":236},{},[237,239,245],{"type":18,"value":238},"注意:由于参数较多，组合起来的测试方案多种多样，所以",{"type":13,"tag":240,"props":241,"children":242},"em",{},[243],{"type":18,"value":244},"xxxx.tests",{"type":18,"value":246},"文件中定义 range的模式，比0-300表示 0 到 300，regression会将这些表示拆开，然后分别执行，在对比日志的时候可以得到佐证。",{"type":13,"tag":26,"props":248,"children":249},{},[250],{"type":18,"value":251},"regression的最后通过调用 run_test_command 最后进入了 c的测试程序，在进入c的测试程序之前，我们需要熟悉下libseccomp 的一些api。",{"type":13,"tag":52,"props":253,"children":255},{"code":254},"        //初始化seccomp filter state\n        scmp_filter_ctx seccomp_init(uint32_t def_action);\n        int seccomp_reset(scmp_filter_ctx ctx, unit32_t def_action);\n            def_action：\n                SCMP_ACT_KILL , SCMP_ACT_TRAP , ACMP_ACT_ERRNO , SCMP_ACT_TRACE , SCMP_ACT_ALLOW\n                \n        //释放seccomp filter state  ,已经loaded into kernel不受影响\n        void seccomp_release(scmp_filter_ctx ctx);\n        //合并两个seccomp filter,src会被释放，不需要在调用 seccomp_release\n        //filter值需要一致，架构需要重叠\n        int seccomp_merge(scmp_filter_ctx dst, scmp_filter_ctx src);\n        \n        \n        //架构管理\n       uint32_t seccomp_arch_resolve_name(const char *arch_name);\n       uint32_t seccomp_arch_native();\n       int seccomp_arch_exist(const scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_add(scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_remove(scmp_filter_ctx ctx, uint32_t arch_token);\n        \n            uint32_t arch_token 由 SCMP_ARCH_* 定义的常量\n            SCMP_ARCH_NATIVE 常量总是指向本地编译的架构\n            当一个新的架构加进来的时候，老 的filter和它没关系，但是后面新增的filter都跟他相关。\n            \n        //属性管理\n        int seccomp_attr_set(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t value)\n        int seccomp_attr_get(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t *value)\n        \n            可选的scmp_filter_attr为\n            \n                SCMP_FLTATR_ACT_DEFAULT\n                    只读属性\n                SCMP_FLTATR_ACT_BADARCH     //def_action\n                    如果架构不匹配，那么默认 SCMP_ACT_KILL\n                SCMP_FLTATR_CTL_NNP         //boolean\n                    定义NO_NEW_PRIVS在filter加载到内核之前就应该被启动。如果这个为0，那么会去检查 CAP_SYS_ADMIN，不然失败。默认1。\n                SCMP_FLTATR_CTL_TSYNC       //boolean\n                    设置表示seccomp_load调用的时候需要全部同步filter\n                SCMP_FLTATR_ATL_TSKIP       //boolean\n                    设置表示可以创建 -1的syscall \n        //导出seccomp filter\n        int seccomp_export_bpf(const scmp_filter_ctx, int fd);      //bpf   --> Berkley Packet Filter\n        int seccomp_export_pfc(const scmp_filter_ctx, int fd);      //pfc  --> Pseudo Filter Code\n            \n        //装载filter到kernel中\n        int seccomp_load(scmp_filter_ctx ctx);  //成功的加载\n        \n        //增加 seccomp filter rule\n        int SCMP_SYS(syscall_name);\n        struct scmp_arg_cmp SCMP_CMP(unsigned int arg, enum scmp_compare op, ...);\n        struct scmp_arg_cmp SCMP_A0(enum scmp_compare op, ...);\n        ...\n        struct scmp_arg_cmp SCMP_A5(enum scmp_compare op, ...);\n        int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action , int syscall, unsigned int arg_cnt, ...);\n        int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,    int syscall, unsigned int arg_cnt, ...);\n        \n        int seccomp_rule_add_array(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        int seccomp_rule_add_exact_array(scmp_filter_ctx ctx, uint32_t action, int syscal, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        \n            新加入的filter rule需要load进 kernel才会生效\n            SCMP_CMP（） 和 SCMP_A{0-5}()宏 生成一个 scmp_arg_cmp结构用到上面的函数中。\n    \n        \n            //区分 seccomp filter 中的 syscall\n            int seccomp_syscall_priority(scmp_filter_ctx ctx, int syscall, uint8_t priority);\n            //解析syscall名称\n            int seccomp_syscall_resolve_name(const char *name);\n            int seccomp_syscall_resolve_name_arch(uint32_t arch_token, const char *name);\n            int seccomp_syscall_resolve_name_rewrite(uint32_t arch_token, const char *name);\n            char *seccomp_syscall_resolve_num_arch(uint32_t arch_torken, int num);\n",[256],{"type":13,"tag":57,"props":257,"children":258},{"__ignoreMap":7},[259],{"type":18,"value":254},{"type":13,"tag":26,"props":261,"children":262},{},[263],{"type":18,"value":264},"进入 01-sim-alloc.c 代码",{"type":13,"tag":52,"props":266,"children":268},{"code":267},"    ...\n    ctx = seccomp_init(SCMP_ACT_ALLOW);\n    ...\n    rc = util_filter_output(&opts,ctx);\n         |--> _ctx_valid(ctx)\n         |--> program = gen_bpf_generate((struct db_filter_col *) ctx);\n                |--> _gen_bpf_build_bpf(stcut bpf_state *state,const struct db_filter_col *col)\n                            |--> ???\n    \n",[269],{"type":13,"tag":57,"props":270,"children":271},{"__ignoreMap":7},[272],{"type":18,"value":267},{"title":7,"searchDepth":274,"depth":274,"links":275},2,[276,277,278],{"id":22,"depth":274,"text":22},{"id":48,"depth":274,"text":48},{"id":67,"depth":274,"text":67},"markdown","content:blog:linux:libseccomp.md","content","blog/linux/libseccomp.md","md",1718158598645]