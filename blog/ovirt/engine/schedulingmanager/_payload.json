[{"data":1,"prerenderedAt":387},["Reactive",2],{"content-query-PLcKRXQNtX":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"body":9,"_type":382,"_id":383,"_source":384,"_file":385,"_extension":386},"/blog/ovirt/engine/schedulingmanager","engine",false,"","ovirt-engine SchedulingManager",{"type":10,"children":11,"toc":367},"root",[12,20,26,32,37,57,62,67,72,82,87,100,108,114,119,125,133,138,146,152,157,162,196,202,210,216,222,227,235,240,268,273],{"type":13,"tag":14,"props":15,"children":17},"element","h1",{"id":16},"ovirt-engine-schedulingmanager",[18],{"type":19,"value":8},"text",{"type":13,"tag":21,"props":22,"children":24},"h2",{"id":23},"调度策略",[25],{"type":19,"value":23},{"type":13,"tag":27,"props":28,"children":29},"p",{},[30],{"type":19,"value":31},"管网文档定义：调度策略是一组规则，它定义了虚拟机在应用这个调度的集群中的主机间的分配逻辑。",{"type":13,"tag":27,"props":33,"children":34},{},[35],{"type":19,"value":36},"调度策略主要由下面三类对象组成。",{"type":13,"tag":38,"props":39,"children":40},"ul",{},[41,47,52],{"type":13,"tag":42,"props":43,"children":44},"li",{},[45],{"type":19,"value":46},"filter:用来过滤不符合条件的host",{"type":13,"tag":42,"props":48,"children":49},{},[50],{"type":19,"value":51},"weighting:用来增加符合条件的host的权重",{"type":13,"tag":42,"props":53,"children":54},{},[55],{"type":19,"value":56},"load balancing:上两者的集合，代表一个执行策略。",{"type":13,"tag":27,"props":58,"children":59},{},[60],{"type":19,"value":61},"以上的三类对象都由policyUnitImpl对象的子类来完成。\nfilter 的都是xxxUnit\nweighting 的都是xxxWightPolicyUnit\nload balancing的都是 xxxbalancePolicyUnit",{"type":13,"tag":27,"props":63,"children":64},{},[65],{"type":19,"value":66},"PolicyUnitImpl是一个abstract类，它有很多具体的实现子类。\n其中包括CpuPiningPolicyUnit,CompatibilityVersionFilterPolicyUnit等",{"type":13,"tag":27,"props":68,"children":69},{},[70],{"type":19,"value":71},"在InternalPolicyUnits内部定义internal的内可用的策略，放在enabledUnits中。\n并且ovirt定义了一个接口注解， SchedulingUnit ，用来标志policyUnit",{"type":13,"tag":73,"props":74,"children":76},"pre",{"code":75},"@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface SchedulingUnit {\n    String guid(); \n    \n    //每个unit名称，可以在手册中的1.5找到描述的功能说明\n    String name(); \n    PolicyUnitType type() default PolicyUnitType.FILTER;\n    \n    //每一个策略单元的具体功能可以通过这个属性来快速了解\n    String description() default \"\";\n    PolicyUnitParameter[] parameters() default {};\n}\n",[77],{"type":13,"tag":78,"props":79,"children":80},"code",{"__ignoreMap":7},[81],{"type":19,"value":75},{"type":13,"tag":27,"props":83,"children":84},{},[85],{"type":19,"value":86},"在InternalPolicyUnits.instantiate中检测了每一个policyUnit是否在InternalPolicyUnits.enabledUnits中定义、是否被SchedulingUnit注解标志出来",{"type":13,"tag":27,"props":88,"children":89},{},[90,92,98],{"type":19,"value":91},"调度策略对应的对象是",{"type":13,"tag":93,"props":94,"children":95},"strong",{},[96],{"type":19,"value":97},"ClusterPolicy",{"type":19,"value":99},"，负责保存主机选择和负载均衡的BE。",{"type":13,"tag":73,"props":101,"children":103},{"code":102},"private Guid id;\nprivate String name;\nprivate String description;\n\n//true表示是保留的内置策略\nprivate boolean locked;\n//true表示没有可用的特定policy，使用默认\nprivate boolean defaultPolicy;\n//可用的filters的id列表\nprivate ArrayList\u003CGuid> filters;\n //上面filter的对应顺序，可接受的value包括  first(-1) | last(1) | no position(0)\nprivate Map\u003CGuid, Integer> filterPositionMap;\n//定义了每个权重的分数\nprivate ArrayList\u003CPair\u003CGuid, Integer>> functions;\n//一个loadbalance\nprivate Guid balance;\n//提供的参数集\nprivate Map\u003CString, String> parameterMap;\n",[104],{"type":13,"tag":78,"props":105,"children":106},{"__ignoreMap":7},[107],{"type":19,"value":102},{"type":13,"tag":21,"props":109,"children":111},{"id":110},"schedulingmanager",[112],{"type":19,"value":113},"SchedulingManager",{"type":13,"tag":27,"props":115,"children":116},{},[117],{"type":19,"value":118},"继承自BackendService，主要作用于系统的集群调度策略。",{"type":13,"tag":120,"props":121,"children":123},"h3",{"id":122},"成员分析",[124],{"type":19,"value":122},{"type":13,"tag":73,"props":126,"children":128},{"code":127},"@Inject\nprivate AuditLogDirector auditLogDirector;\n@Inject\nprivate ResourceManager resourceManager;//todo\n@Inject\nprivate MigrationHandler migrationHandler;//todo\n@Inject\nprivate ExternalSchedulerDiscovery exSchedulerDiscovery;//用来发现外部的policy\n@Inject\nprivate DbFacade dbFacade;//用来返回vds\\cluster\\policyunit\\clusterpolicy等dao来查询数据库\n@Inject\nprivate NetworkDeviceHelper networkDeviceHelper;//todo\n@Inject\nprivate HostDeviceManager hostDeviceManager;//todo\n\nprivate PendingResourceManager pendingResourceManager;\n\n/**\n * [policy id, policy] map\n */\nprivate final ConcurrentHashMap\u003CGuid, ClusterPolicy> policyMap;\n/**\n * [policy unit id, policy unit] map\n */\nprivate volatile ConcurrentHashMap\u003CGuid, PolicyUnitImpl> policyUnits;\n\nprivate final Object policyUnitsLock = new Object();\n\nprivate final ConcurrentHashMap\u003CGuid, Semaphore> clusterLockMap = new ConcurrentHashMap\u003C>();\n\nprivate final VdsFreeMemoryChecker noWaitingMemoryChecker = new VdsFreeMemoryChecker(new NonWaitingDelayer());\n\nprivate final Map\u003CGuid, Boolean> clusterId2isHaReservationSafe = new HashMap\u003C>();\n\n",[129],{"type":13,"tag":78,"props":130,"children":131},{"__ignoreMap":7},[132],{"type":19,"value":127},{"type":13,"tag":120,"props":134,"children":136},{"id":135},"初始化分析",[137],{"type":19,"value":135},{"type":13,"tag":73,"props":139,"children":141},{"code":140},"    @PostConstruct\n    public void init() {\n        log.info(\"Initializing Scheduling manager\");\n        //负责获取各类变化的资源情况，操作对象是所有继承PendingResource类的资源类，比如CPU、内存等\n        initializePendingResourceManager();\n        //加载内部外部policyUnit;内部在enabledUnits里面定义;外部在db里面查询;\n        loadPolicyUnits();\n        //加载内部外部ClusterPolicies;内部由createBuilder构建;外部在db里面查询;\n        loadClusterPolicies();\n        //加载外部的scheduler,默认关闭;如果发现就重新加载policyUnit\n        loadExternalScheduler();\n        //启动loadBalance,默认开启;使用quartz定时器调用performLoadBalancing();\n        enableLoadBalancer();\n        //启用HA检查，默认开启;使用quartz定时器调用performHaResevationCheck();\n        enableHaReservationCheck();\n        log.info(\"Initialized Scheduling manager\");\n    }\n",[142],{"type":13,"tag":78,"props":143,"children":144},{"__ignoreMap":7},[145],{"type":19,"value":140},{"type":13,"tag":21,"props":147,"children":149},{"id":148},"pendingresource",[150],{"type":19,"value":151},"PendingResource",{"type":13,"tag":27,"props":153,"children":154},{},[155],{"type":19,"value":156},"用作所有trackable pending resource一个基础类模板\n实现一个静态方法给PendingResourceManager来调用，完成收集每台host和VM的数据信息。",{"type":13,"tag":27,"props":158,"children":159},{},[160],{"type":19,"value":161},"子类包括",{"type":13,"tag":38,"props":163,"children":164},{},[165,176,186,191],{"type":13,"tag":42,"props":166,"children":167},{},[168,170,174],{"type":19,"value":169},"PendingCpuCores",{"type":13,"tag":171,"props":172,"children":173},"br",{},[],{"type":19,"value":175},"\n核心数量",{"type":13,"tag":42,"props":177,"children":178},{},[179,181,184],{"type":19,"value":180},"PendingMemory",{"type":13,"tag":171,"props":182,"children":183},{},[],{"type":19,"value":185},"\nhost内存大小，单位MB",{"type":13,"tag":42,"props":187,"children":188},{},[189],{"type":19,"value":190},"PendingOvercommitMemory",{"type":13,"tag":42,"props":192,"children":193},{},[194],{"type":19,"value":195},"PendingVm",{"type":13,"tag":120,"props":197,"children":199},{"id":198},"pendingresourcemanager",[200],{"type":19,"value":201},"PendingResourceManager",{"type":13,"tag":73,"props":203,"children":205},{"code":204},"//Tracking service for all pending resources\npublic class PendingResourceManager{\n    ...\n    // All internal structures have to be thread-safe for concurrent access\n    private final Map\u003CGuid, Set\u003CPendingResource>> resourcesByHost = new ConcurrentHashMap\u003C>();\n    private final Map\u003CGuid, Set\u003CPendingResource>> resourcesByVm = new ConcurrentHashMap\u003C>();\n    private final Map\u003CPendingResource, PendingResource> pendingResources = new ConcurrentHashMap\u003C>();\n    \n    private final ResourceManager resourceManager;\n    \n    ...\n    \n    public void addPending(PendingResource resource) { ... }\n    \n    public void clearHost(VDS host) { ... }\n    \n    public void clearVm(VmStatic vm) { ... } \n    \n    public \u003CT extends PendingResource> Iterable\u003CT> pendingResources(Class\u003CT> type) { ... }\n    \n    public \u003CT extends PendingResource> Iterable\u003CT> pendingHostResources(Guid host, Class\u003CT> type) { ... }\n    \n    public \u003CT extends PendingResource> Iterable\u003CT> pendingVmResources(Guid vm, Class\u003CT> type) { ... } \n    \n    public void notifyHostManagers(Guid hostId) { ... }\n    \n    public \u003CT extends PendingResource> T getExactPendingResource(T template) { ... }\n}\n\n",[206],{"type":13,"tag":78,"props":207,"children":208},{"__ignoreMap":7},[209],{"type":19,"value":204},{"type":13,"tag":120,"props":211,"children":213},{"id":212},"internalpolicyunits",[214],{"type":19,"value":215},"InternalPolicyUnits",{"type":13,"tag":120,"props":217,"children":219},{"id":218},"internalclusterpolicies",[220],{"type":19,"value":221},"InternalClusterPolicies",{"type":13,"tag":27,"props":223,"children":224},{},[225],{"type":19,"value":226},"通过createBuilder来构建了5个预定义的集群策略。代码逻辑如下：",{"type":13,"tag":73,"props":228,"children":230},{"code":229},"createBuilder(\"xxxx-a7ac-4d5f-xxxx\")            //传入uuid\n    .name(\"NAME\")                               //传入集群策略名称\n    .isDefault()                                //制定当前策略是默认策略\n    .setBalancer(XXXBalancePolicyUnit.class)    //设置balancer\n\n    .addFilters(XXXPolicyUnit.class)            //设置filter\n    ...\n\n    .addFunction(1, xxxWeightPolicyUnit.class)  //设置weight和权重值\n    ...\n    \n    .set(PolicyUnitParameter.XXX , 'VALUE')     //设置调度策略的参数和值\n    \n    .register();                                //注册集群调度策略到InternalClusterPolicies里面内置的clusterPolicies中\n        \n",[231],{"type":13,"tag":78,"props":232,"children":233},{"__ignoreMap":7},[234],{"type":19,"value":229},{"type":13,"tag":27,"props":236,"children":237},{},[238],{"type":19,"value":239},"通过这种方式定义的集群调度策略有5个：",{"type":13,"tag":38,"props":241,"children":242},{},[243,248,253,258,263],{"type":13,"tag":42,"props":244,"children":245},{},[246],{"type":19,"value":247},"Evenly_Distributed",{"type":13,"tag":42,"props":249,"children":250},{},[251],{"type":19,"value":252},"InClusterUpgrade",{"type":13,"tag":42,"props":254,"children":255},{},[256],{"type":19,"value":257},"None",{"type":13,"tag":42,"props":259,"children":260},{},[261],{"type":19,"value":262},"Power_Saving",{"type":13,"tag":42,"props":264,"children":265},{},[266],{"type":19,"value":267},"VM_Evenly_Distributed",{"type":13,"tag":21,"props":269,"children":271},{"id":270},"涉及的entity",[272],{"type":19,"value":270},{"type":13,"tag":38,"props":274,"children":275},{},[276,299,317,330,349],{"type":13,"tag":42,"props":277,"children":278},{},[279,281],{"type":19,"value":280},"AffinityGroup ：\n",{"type":13,"tag":38,"props":282,"children":283},{},[284,289,294],{"type":13,"tag":42,"props":285,"children":286},{},[287],{"type":19,"value":288},"保留一些VMs和属性。",{"type":13,"tag":42,"props":290,"children":291},{},[292],{"type":19,"value":293},"每个VM可以关联几个AffinityGroup",{"type":13,"tag":42,"props":295,"children":296},{},[297],{"type":19,"value":298},"每个VM由调度逻辑取决于它所属的AffinityGroup的规则",{"type":13,"tag":42,"props":300,"children":301},{},[302,304],{"type":19,"value":303},"ClusterPolicy :\n",{"type":13,"tag":38,"props":305,"children":306},{},[307,312],{"type":13,"tag":42,"props":308,"children":309},{},[310],{"type":19,"value":311},"保存主机选择和load balancing的逻辑",{"type":13,"tag":42,"props":313,"children":314},{},[315],{"type":19,"value":316},"内部clusterPolicy是由ovirt内置存在的,用户可以自己添加外部的ClusterPolicy,由is_locked的字段来标识这个区别",{"type":13,"tag":42,"props":318,"children":319},{},[320,322],{"type":19,"value":321},"PolicyUnit\n",{"type":13,"tag":38,"props":323,"children":324},{},[325],{"type":13,"tag":42,"props":326,"children":327},{},[328],{"type":19,"value":329},"filter,weight,balance三类方法",{"type":13,"tag":42,"props":331,"children":332},{},[333,335],{"type":19,"value":334},"PerHostMessages\n",{"type":13,"tag":38,"props":336,"children":337},{},[338],{"type":13,"tag":42,"props":339,"children":340},{},[341],{"type":13,"tag":73,"props":342,"children":344},{"code":343},"  Map\u003CGuid, List\u003CString>> message; //保存各个host的消息list\n",[345],{"type":13,"tag":78,"props":346,"children":347},{"__ignoreMap":7},[348],{"type":19,"value":343},{"type":13,"tag":42,"props":350,"children":351},{},[352,354],{"type":19,"value":353},"OptimizationType\n",{"type":13,"tag":38,"props":355,"children":356},{},[357,362],{"type":13,"tag":42,"props":358,"children":359},{},[360],{"type":19,"value":361},"定义集群优化的三种方案：none,optimize_for_speed,allow_overbooking",{"type":13,"tag":42,"props":363,"children":364},{},[365],{"type":19,"value":366},"//TODO 三者区别",{"title":7,"searchDepth":368,"depth":368,"links":369},2,[370,371,376,381],{"id":23,"depth":368,"text":23},{"id":110,"depth":368,"text":113,"children":372},[373,375],{"id":122,"depth":374,"text":122},3,{"id":135,"depth":374,"text":135},{"id":148,"depth":368,"text":151,"children":377},[378,379,380],{"id":198,"depth":374,"text":201},{"id":212,"depth":374,"text":215},{"id":218,"depth":374,"text":221},{"id":270,"depth":368,"text":270},"markdown","content:blog:ovirt:engine:schedulingManager.md","content","blog/ovirt/engine/schedulingManager.md","md",1718158598650]