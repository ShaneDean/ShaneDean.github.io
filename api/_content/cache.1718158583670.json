{"generatedAt":1718158598373,"generateTime":279,"contents":[{"_path":"/blog/about","_dir":"blog","_draft":false,"_partial":false,"_locale":"","title":"联系我","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"联系我"},"children":[{"type":"text","value":"联系我"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"mail : nascos34#gmail.com"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"github : "},{"type":"element","tag":"a","props":{"href":"http://github.com/ShaneDean","rel":["nofollow"]},"children":[{"type":"text","value":"github"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:blog:about.md","_source":"content","_file":"blog/about.md","_extension":"md"},{"_path":"/blog/algorithm/toposort","_dir":"algorithm","_draft":false,"_partial":false,"_locale":"","title":"拓扑排序","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"拓扑排序"},"children":[{"type":"text","value":"拓扑排序"}]},{"type":"element","tag":"h2","props":{"id":"简介"},"children":[{"type":"text","value":"简介"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/wangdong20/article/details/83443250","rel":["nofollow"]},"children":[{"type":"text","value":"参考1"}]},{"type":"element","tag":"a","props":{"href":"http://www.csie.ntnu.edu.tw/~u91029/DirectedAcyclicGraph.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考2"}]},{"type":"element","tag":"a","props":{"href":"https://www.geeksforgeeks.org/topological-sorting/","rel":["nofollow"]},"children":[{"type":"text","value":"参考3"}]},{"type":"element","tag":"a","props":{"href":"https://oi-wiki.org/graph/topo/","rel":["nofollow"]},"children":[{"type":"text","value":"参考4"}]},{"type":"element","tag":"a","props":{"href":"https://blog.csdn.net/lisonglisonglisong/article/details/45543451","rel":["nofollow"]},"children":[{"type":"text","value":"参考5"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拓扑排序英文为Topological sorting，用于解决给一个图的所有节点排序的问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以用大学选课的例子来解释："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"cs_major","src":"https://github.com/ShaneDean/file/blob/master/blog/algorithm/algorithm_toposort_computer_science_major.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们要完成一系列任务，单个任务之间可能是依赖关系，比如要完成任务B的前提是完成任务A，每次只能开始能进行的任务。就像完成学校学位所需要完成的课程。拓扑排序就是通关计算机程序来寻找完成这些任务的顺序，还可以延伸到许多不同的问题"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设B任务必须依赖A才能完成，也就是说B一定在A之后完成，即(A,B)表示B依赖于A。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设我们有任务A B C D E F G"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"彼此之间的依赖关系为(A,B) (C,D) (A,C) (C,E) (E,G) (F,G) (B,E) (D,F)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以根据依赖做出如下的图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"abcdefg","src":"https://github.com/ShaneDean/file/blob/master/blog/algorithm/algorithm_toposort_abcdefg.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在需要计算机程序来输入这些任务以及依赖关系并计算出可行的完成任务顺序来完成所有的这些程序。"}]},{"type":"element","tag":"h2","props":{"id":"todo"},"children":[{"type":"text","value":"TODO"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"简介","depth":2,"text":"简介"},{"id":"todo","depth":2,"text":"TODO"}]}},"_type":"markdown","_id":"content:blog:algorithm:toposort.md","_source":"content","_file":"blog/algorithm/toposort.md","_extension":"md"},{"_path":"/blog/cs/bpf","_dir":"cs","_draft":false,"_partial":false,"_locale":"","title":"BSD Packet Filter","description":"The BSD Packet Filter: A New Architecture for User-level Packet Capture","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"bsd-packet-filter"},"children":[{"type":"text","value":"BSD Packet Filter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"The BSD Packet Filter: A New Architecture for User-level Packet Capture"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Network Tap"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"BPF有两个主要的概念"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"network tap"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n从网络设备驱动中收集packets的拷贝，并把他们出输给监听程序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"packet filter"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n如果某个packet应当被接受，它将决定这个packet要复制多少份给监听的应用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"bpf-overview","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/bpf-overview.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图一 阐述了BPF接口的基本工作流程"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当一个packed到达网络接口时，链路层的设备驱动通常会发送到系统协议栈中。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是当BPF正在监听这个接口，这个需求将会先调用BPF。 用户定义的鼓励去确定是否一个包将被接受和每个包的多少字节应当被保存。对于每个接受packet的filter而言，BPF拷贝请求的大量数据给filter关联的buffer。然后设备驱动重新获得控制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果packet不是本地主机的地址，驱动将会返回一个中断。其他情况下，正常的协议处理机进程继续工作自从进程可能需要看一下在网络上的每个packet，并且在两个packed的间隔时间可能就few microsseconds ，这样的话就不可能对每个packet去触发一个系统调用read，BPF就必须在几个packet中间收集数据，并且当monitoring程序需要的read的时候返回。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To maintain packet boundaries，BPF encapsulate每个packet头中的一些数据，比如time stamp,length,and offsets for data alignment"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Packet  Filtering\n由于网络监控器只是网络traffic中很小的一个部分，令人惊奇的性能优势在过滤不想要的interrupt context中的packets过程中得到了体现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如何最小化的内存消耗是现代工作站中主要的瓶颈。packet should be filtered \"in place\"(eg where the network interface DMA engine put it) 而不是拷贝到其他的kernel buffer中区。因此如果packet被接受了，only those bytes that were needed by the filtering process are referenced by the host\n相反的案例，SunOS 就是拷贝packet在filtering之前，这样直接导致性能下降。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（接下来就是SunOs STREAMS NIT机制的详细过程说明）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Tap Performance Measurements\n在讨论packet filter细节之前，我们需要提出一些测量的指标。这些性能指标需要独立于packet filter机制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们配置了BPF 和NIT(上文所提及) 在SunOS内核4.1.1中，并运行在Sparcstation2 工作中中。the measurements reflect the overhead incurred during the interrupt prcocessing.(how long it takes each system to stash the packet into a buffer)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于BPF 我们简单地两区在调用bpf_tap()的前后的时间，使用Sparcstation的microsecond clock。对于NIT 我测量调用snit_intr()前后的时间并加上拷贝promiscuous packet到 mbufs的时间。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"（promiscuous packet指的是那些没有本地主机地址的）。换句话说我们包含了NIT在适当地方拿取not filtering packets的细嫩那个干扰。为了获取精确的时间，在 instrumented code segments时，我们锁住了系统终端。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"测试的数据集是一个处理不同packetlength的矩阵。我们约定处理每个packet使用2个配置，'accept all' filter,和 'reject all' filter"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"中间的实验对比 略过"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Filter Model\n一个packet filter是一个返回简单的boolean的函数。true，则kernel 拷贝packet给app； false则忽略这个packet。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"历史上有两种filter的抽象："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个布尔值的表达式树（使用CSPF）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"一个直接非循环的控制流图或CFG（第一次被NNStat使用，也被BPF使用）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"filter-representations","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/filter-function-representations.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，图四中的两种模型，识别网络上的 IP 或 ARP packet。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在树的模型中，每个节点代表一个boolean值，同时叶子节点代表一个packet field的测试predicate.边则表示操作运算符的关系。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在CFG模型中每个节点代表一个packet field predicate 并且 每个边代表控制传递。右边传递true，左边传递false。两个叶子节点表示整个filter的过滤结果。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这两个模型在计算层面而言是一样的，任何过滤器可以同时被两种方案表示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是在实现方面他们不一样， The tree model maps naturally into code for a stack machine while the CFG model maps naturally into code for a register machine。\n大多数的现代机器都是基于寄存器的，随意我们任务cfg可以有一个更有效的实现。"}]},{"type":"element","tag":"h2","props":{"id":"cspftree-model"},"children":[{"type":"text","value":"CSPF(tree) Model"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CSPF过滤引擎基于operand stack。指令push 常数或packet数据在栈中，并且执行一个二进制或位操作在顶部的两个元素。过滤程序顺序的执行指令的列表。最终，如果栈顶是一个非空值并且站空了那么packet久被接受，否则的话就拒绝。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里有2个缺点在这种实现方法里面。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"操作对象栈必须模仿"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"树的模型经常有多余的没必要的计算。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"它的设计者还发现它还有一个问题，它不能解析变长的packet headers。（e.g., TCP headers encapsulated in a variable length IP header. Be- cause the CSPF instruction set didn’t include an indirection operator, only packet data at fixed offsets is accessible. Also, the CSPF model is restricted to a single sixteen bit data type which results in a doubling of the number of operations to manipulate 32 bit data such as Internet addresses or TCP se- quence numbers. Finally, the design does not permit access to the last byte of an odd-length packet.）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"尽管它有很多缺点，但是它也提供了一个通用的packet filtering思想： 提供一个过滤机制的语言的解释程序在kernel中，提供一个良好过滤机制的描述和实现。自从CSPF看待packet是一个简单的byte array ，过滤模型就和protocol完全独立。(The application that specifies the filter is responsible for encoding the filter appropriately for the underlying net- work media and protocols.)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下一节描述BPF模型，"}]},{"type":"element","tag":"h2","props":{"id":"the-bpf-model"},"children":[{"type":"text","value":"the BPF Model"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BPF使用CFG过滤器模型，相对于树模型有一个显著的性能提升。尽管树模型可能需要多次冗余地解析数据包，但CFG模型允许将解析信息“内置”到流程图中。也就是说，图中的数据包解析状态是'记住'的，因为你知道你必须经过哪些路径才能到达特定的节点，并且一旦子表达式被评估，就不需要重新计算它，因为控制流图总是可以 (重新)组织，以便仅在遵循原始计算的节点上使用该值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"figure 5","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/CFG-Filter-Function-for-host-foo.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如，图5展示了CFG filter function 接受所有来自网络地址 foo的 packets.\n我们考虑网络层协议是IP，ARP和反向ARP的情况，所有这些都包含源和目标Internet地址。过滤器应该捕获所有的情况。相应地，首先测试链路层类型字段。在IP数据包的情况下，IP主机地址字段被查询，而在ARP数据包的情况下使用ARP地址字段。请注意，一旦我们知道该数据包是IP，我们就不需要检查它可能是ARP还是RARP。在表达式树模型中，如图6所示，遍历整个树需要七个比较谓词和六个布尔操作。通过CFG的最长路径有五个比较操作，平均比较次数为三次。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"figure 6","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/Tree-Filter-Function-for-host-foo.png?raw=true"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"design-of-filter-pseudo-machine"},"children":[{"type":"text","value":"Design of filter pseudo-machine"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用CFG而不是树表达式作为 filter pseudo-machine的理论基础是实现高效的必要步骤，但是这样还不够。在借助 CSPF和NNStat的pseudo-machine 模型经验的公式，BPF模型也经历几代的（几年）设计和测试。我们相信当前的模型能够在不牺牲性能的前提下提供足够的通用性。它的演变受到下面几个设计约束的限制。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"必须协议独立。内核不应该通过修改来适应新的协议支持。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"必须通用。指令集应该足够丰富，遗嘱里不可预见的用途。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Packet 数据引用必须最小"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"解码指令中必须包含单一的c语言开关语句"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"abstract machine寄存器必须存储在物理寄存器中"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"figure 7","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/bpf-program-for-host-foo.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图7是对应使用了BPF 指令集的 图5"}]},{"type":"element","tag":"h2","props":{"id":"the-bpf-pseudo-machine"},"children":[{"type":"text","value":"The BPF Pseudo-Machine"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"BPF machine由  accumulator , index register , scratch memory store 和 implicit program counter组成，它们相关的操作可以分成下面几组"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"LOAD INSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":"将值复制到累加器或变址寄存器中。源可以是立即值，固定偏移量的数据包数据，可变偏移量的数据包数据，数据包长度或临时存储器。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"将值复制到累加器或变址寄存器中。源可以是立即值，固定偏移量的数据包数据，可变偏移量的数据包数据，数据包长度或临时存储器。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"STORE INSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":" 将累加器或索引寄存器复制到暂存存储器中。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" 将累加器或索引寄存器复制到暂存存储器中。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ALU INSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":"累加器使用索引寄存器或常量作为操作数。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"累加器使用索引寄存器或常量作为操作数。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BRANCH INSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":"根据常数或x寄存器与累加器之间的比较测试改变控制流程。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"根据常数或x寄存器与累加器之间的比较测试改变控制流程。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RETURNINSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":"终止封包，并指明要保存的数据包的哪一部分。如果过滤器返回0，则数据包完全被丢弃。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"终止封包，并指明要保存的数据包的哪一部分。如果过滤器返回0，则数据包完全被丢弃。\n"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MISCELLANEOUS INSTRUCTIONS"},{"type":"element","tag":"pre","props":{"code":"目前是 register transfer instructions\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"目前是 register transfer instructions\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"指令格式的定义如下"}]},{"type":"element","tag":"pre","props":{"code":"    ---------------------------\n    | opcode:16 | jt:8 | jf:8 |\n    ---------------------------\n    |               k:32            |\n    ---------------------------\n\n    opcode 去顶指令和取址模式\n    jt 和 jf 用来进行条件跳转,t ture, f false\n    k是用于各种目的的通用字段\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    ---------------------------\n    | opcode:16 | jt:8 | jf:8 |\n    ---------------------------\n    |               k:32            |\n    ---------------------------\n\n    opcode 去顶指令和取址模式\n    jt 和 jf 用来进行条件跳转,t ture, f false\n    k是用于各种目的的通用字段\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"详细的指令集\t见下表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"table-1","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/table-BPF-instruction.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"寻址模式\t见下表"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"table-2","src":"https://github.com/ShaneDean/file/blob/master/blog/linux/table-2-BPF-addressing-modes.png?raw=true"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"examples"},"children":[{"type":"text","value":"Examples"}]},{"type":"element","tag":"pre","props":{"code":"    //filter accepts all IP packets\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0\n\n\n\n    //accepts all ip packages except ,128.3.112 or 128.3.254\n    //mask=24\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L4\n        L1:     ld      [26]        \n                and     #0xffffff00\n                jeq     #0x80037000, L4, L2\n        L2:     jeq     #0x8003fe00, L4, L3\n        L3:     ret     #TRUE\n        L4:     ret     #0\n    \n    其中  #0x80037000 和 #0x8003fe00 就是对应的ip地址\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    //filter accepts all IP packets\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0\n\n\n\n    //accepts all ip packages except ,128.3.112 or 128.3.254\n    //mask=24\n                ldh     [12]\n                jeq     #ETHERTYPE_IP, L1, L4\n        L1:     ld      [26]        \n                and     #0xffffff00\n                jeq     #0x80037000, L4, L2\n        L2:     jeq     #0x8003fe00, L4, L3\n        L3:     ret     #TRUE\n        L4:     ret     #0\n    \n    其中  #0x80037000 和 #0x8003fe00 就是对应的ip地址\n    \n"}]}]},{"type":"element","tag":"h2","props":{"id":"parsing-packet-headers"},"children":[{"type":"text","value":"Parsing Packet Headers"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面是在假定了数据在packet固定的位置中，但是事实上TCP header是需要根据IP header来计算的。"}]},{"type":"element","tag":"pre","props":{"code":"                ldb [14] \n                and #0xf \n                lsh #2\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"                ldb [14] \n                and #0xf \n                lsh #2\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一旦IP头的长度算出来，那么TCP section可以被直接访问。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that the effective offset has three components."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ip header length"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"the link level header length"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"the data offset relative to the TCP header"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设部分数据 代码如下"}]},{"type":"element","tag":"pre","props":{"code":"                ldb     [14] \n                and     #0xf \n                lsh     #2\n                tax\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0      \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"                ldb     [14] \n                and     #0xf \n                lsh     #2\n                tax\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0      \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于IP报头长度计算是一种常见的操作，因此引入了4 *（"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"k"}]},{"type":"text","value":"＆0xf）寻址模式。用ldx指令代替将过滤器简化为："}]},{"type":"element","tag":"pre","props":{"code":"                ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0  \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"                ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L1:     ret     #TRUE\n        L2:     ret     #0  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面的代码我们已经假设了数据是tcp/ip header，现实情况下我们还需要检测  link layer type 是 IP， IP protocol  type是 TCP\t。并且TCP Header 只有第一个fragment包含，其他的包含第一个之后的fragment都会被拒绝。"}]},{"type":"element","tag":"pre","props":{"code":"                ldh     [12]\n                jeq     #ETHERPROTO_IP, L1, L2\n        L1:     ldb     [23]\n                jeq     #IPPROTO_TCP, L2, L5\n        L2:     ldh     [20]\n                jset    #0x1fff, L5, L3\n        L3:     ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L4:     ret     #TRUE\n        L5:     ret     #0  \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"                ldh     [12]\n                jeq     #ETHERPROTO_IP, L1, L2\n        L1:     ldb     [23]\n                jeq     #IPPROTO_TCP, L2, L5\n        L2:     ldh     [20]\n                jset    #0x1fff, L5, L3\n        L3:     ldx     4*([14]&0xf)\n                ldh     [x + 16]\n                jeq     #N, L1, L2\n        L4:     ret     #TRUE\n        L5:     ret     #0  \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"##Filter Performance Measurements"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"略"}]},{"type":"element","tag":"h2","props":{"id":"应用"},"children":[{"type":"text","value":"应用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"tcpdump"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html#icomments","rel":["nofollow"]},"children":[{"type":"text","value":"扩展阅读-ebpf"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/P-code_machine","rel":["nofollow"]},"children":[{"type":"text","value":"扩展阅读-pseudo-machine"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"cspftree-model","depth":2,"text":"CSPF(tree) Model"},{"id":"the-bpf-model","depth":2,"text":"the BPF Model","children":[{"id":"design-of-filter-pseudo-machine","depth":3,"text":"Design of filter pseudo-machine"}]},{"id":"the-bpf-pseudo-machine","depth":2,"text":"The BPF Pseudo-Machine"},{"id":"examples","depth":2,"text":"Examples"},{"id":"parsing-packet-headers","depth":2,"text":"Parsing Packet Headers"},{"id":"应用","depth":2,"text":"应用"}]}},"_type":"markdown","_id":"content:blog:cs:bpf.md","_source":"content","_file":"blog/cs/bpf.md","_extension":"md"},{"_path":"/blog/cs/cryptology","_dir":"cs","_draft":false,"_partial":false,"_locale":"","title":"图解密码学","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"图解密码学"},"children":[{"type":"text","value":"图解密码学"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文是对《"},{"type":"element","tag":"a","props":{"href":"https://item.jd.com/11942019.html","rel":["nofollow"]},"children":[{"type":"text","value":"图解密码技术"}]},{"type":"text","value":"》厚到薄的阅读总结。"}]},{"type":"element","tag":"h2","props":{"id":"密码学家的6个工具箱"},"children":[{"type":"text","value":"密码学家的6个工具箱"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对称密码\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过相同的密钥来对目标信息进行加密解密"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"加密解密的过程就是执行异或操作，因为第一次执行异或操作等于加密，第二次执行异或操作等于解密。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"密码算法可以分为分组密码和流密码两种：流密码是对一串数据进行连续处理，因此需要保持内部状态（一次性密码）；而分组密码处理完一个分组就结束了了，不需要通过内部状态来记录加密的进度（DES、三重DES、AES）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分组密码迭代的方法就是分组密码的模式，包括ECB、CBC、CFB、OFB、CTR。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对称密码是一种用相同的密钥进行加密和解密的技术，用于确保消息的机密性。在对称密码的算法方面，目前主要使用的是AES。尽管对称密码能够确保消息的机密性，但需要解决将解密密钥配送给接收者的密钥配送问题。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"公钥密码\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"公钥用来加密，私钥用来解密。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"公钥密码的运行速度远远低于对称密码，一般的通信过程会组合使用公钥密码和私钥。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对称密码用来加解密数据，公钥密码用来传输对称密钥。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用接收者的公钥来加密对称密钥并发送；只有接收者拥有该公钥对应的私钥并能成功解密获得对称密钥。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"公钥密码是一种用不同的密钥进行加密和解密的技术，和对称密码一样用于确保消息的机密性。使用最广泛的一种公钥密码算法RSA。和对称密码相比，公钥密码的速度非常慢，因此一般会和对称密码组合成混合密码系统来使用。公钥密码能够解决对称面中的密钥交换的问题，但存在通过中间人攻击被伪装的风险，因此需要对带有数字签名的公钥进行认证"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"单向散列函数\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"输入消息和输出散列值，单向散列函数所输出的散列值的长度是固定的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"具备抗碰撞性、具备单向性、"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"单向散列函数是一种将长消息转换为短散列值的技术，用于保证消息的完整性。目前广泛使用SHA-2，存在全新结构的SHA-3算法。单向散列函数可以单独使用，也可以用作消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"消息认证码\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，他可以输出固定长度的值，这个数据称为MAC值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"是一种与密钥相关的单向散列函数"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"确保不能根据MAC值来推测出双方通信的密钥"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"消息认证码时一种能够识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。消息认证码能够对通信对象进行认证，但无法对第三方进行认证。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"数字签名\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"用私钥加密来生成签名，用公钥解密来验证签名。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"签名针对单向散列函数的散列值。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这里用来代表一种只有只有该密钥的人才能够生成的信息。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"数字签名是一种能够对第三方进行消息认证，并能够防止通信对象作出否认的认证技术。公钥基础设施（PKI）中使用的证书，技术在对公钥加上认证机构的数字签名所构成的。需要验证公钥的数字签名，需要通过某种途径获取认证机构自身的合法公钥。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伪随机数生成器\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"随机数性质分为：随机性、不可预测性、不可重现性。逐步严格。分别命名为弱伪随机数、强伪随机数和真随机数。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据传感器收集的热量、声音的变化等事实上无法预测和重现的自然现象来生产的随机数列的硬件被称为随机数生成器"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生成随机数的软件称为伪随机数生成器。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"伪随机数生成器具有内部状态，需要种子（seed）来进行内部的初始化。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"java.util.Random不能用于安全相关用途，使用java.security.SecureRandom的类。"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"随机数生成器是一种能够生成不可预测的比特序列的技术，由密码和单向散列函数技术构成。伪随机数生成器用于生成密钥、初始化向量和nonce（用于避免重放攻击只是用一次的数字）等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些工具箱的作用如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"作用","src":"https://github.com/ShaneDean/file/blob/master/blog/sec/sec_threaten_and_cryptographic_technique.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"工具箱","src":"https://github.com/ShaneDean/file/blob/master/blog/sec/sec-tool-kit.png?raw=true"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"对比"},"children":[{"type":"text","value":"对比"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对称密码和公钥密码的对比"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"\\"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"对称密码"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"公钥密码"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"发送者"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"共享密钥加密"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用公钥加密"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"接收者"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"共享密钥解密"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用私钥解密"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"密钥配送问题"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"存在"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"不存在，单公钥需要另外认证"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"机密性"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"公钥密码和数字签名的对比"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"\\"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"私钥"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"公钥"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"公钥密码"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"接收者解密时候使用"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"发送者加密时候使用"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"数字签名"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"签名者生成签名时使用"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"验证者验证签名时使用"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"谁持有密钥"}]},{"type":"text","value":"？"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"个人持有"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"任何人都可以持有"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"消息认证码和数字签名对比"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"\\"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"消息认证码"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"数字签名"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"发送者"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用共享密钥计算MAC值"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用私钥生成签名"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"接收者"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用共享密钥计算MAC值"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"用公钥验证签名"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"密钥配送问题"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"存在"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"不存在，单公钥需要另外认证"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"完整性"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"认证"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足（仅限通信双方）"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足（可使用于任何第三方）"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"防止否认"}]}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"不满足"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"满足"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"其他"},"children":[{"type":"text","value":"其他"}]},{"type":"element","tag":"h3","props":{"id":"证书"},"children":[{"type":"text","value":"证书"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"证书是用来对公钥的合法性进行证明的技术。 公钥证书包含姓名、组织、邮箱、地址等个人星系，以及属于此人的公钥，并由认证机构追加数字签名。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"认证机构是能够认定“公钥确实属于此人”并能够生成数字签名的个人活组织。认证机构中有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的一般企业。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"证书标准规范：X.509"}]},{"type":"element","tag":"h3","props":{"id":"pki"},"children":[{"type":"text","value":"PKI"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"公钥基础设施（Public-Key Infrastructure)是为了能够更好地运用公钥而制定的一些列规范和规格的总称。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"主要包含3个要素：用户（使用PKI的人）、认证机构（颁发证书的人）、仓库（保存证书的数据库）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"关系如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"pki元素","src":"https://github.com/ShaneDean/file/blob/master/blog/sec/sec_elements_of_pki.png?raw=true"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"密钥"},"children":[{"type":"text","value":"密钥"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"密钥就是一个十分巨大的数字，密钥空间是密钥的长度，它的大小决定了可能出现的密钥的总数量和暴力破解的难度。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"密钥和明文是等价的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"生成密钥的最好方法是使用随机数。密码学用途的伪随机数生成器必须专门针对密码学用途而设计。"}]},{"type":"element","tag":"h3","props":{"id":"pgp"},"children":[{"type":"text","value":"PGP"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"提供现代密码软件所必需的几乎全部所有功能，如：对称密码、公钥密码、数字签名、单向散列函数、证书、压缩、文本和二进制转换、大文件的拆分与合并、钥匙串管理。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"密码学家的6个工具箱","depth":2,"text":"密码学家的6个工具箱"},{"id":"对比","depth":2,"text":"对比"},{"id":"其他","depth":2,"text":"其他","children":[{"id":"证书","depth":3,"text":"证书"},{"id":"pki","depth":3,"text":"PKI"},{"id":"密钥","depth":3,"text":"密钥"},{"id":"pgp","depth":3,"text":"PGP"}]}]}},"_type":"markdown","_id":"content:blog:cs:cryptology.md","_source":"content","_file":"blog/cs/cryptology.md","_extension":"md"},{"_path":"/blog/java/inject/intro","_dir":"inject","_draft":false,"_partial":false,"_locale":"","title":"依赖注入","description":"转载原文","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"依赖注入"},"children":[{"type":"text","value":"依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转载"},{"type":"element","tag":"a","props":{"href":"https://github.com/android-cn/blog/blob/master/java/dependency-injection/README.md","rel":["nofollow"]},"children":[{"type":"text","value":"原文"}]}]},{"type":"element","tag":"h1","props":{"id":"依赖注入-1"},"children":[{"type":"text","value":"依赖注入"}]},{"type":"element","tag":"h3","props":{"id":"_1-依赖"},"children":[{"type":"text","value":"1. 依赖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。"}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    Father father;\n    ...\n    public Human() {\n        father = new Father();\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human() {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"        father = new Father();\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":8},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"仔细看这段代码我们会发现存在一些问题：\n(1). 如果现在要改变 father 生成方式，如需要用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new Father(String name)"}]},{"type":"text","value":"初始化 father，需要修改 Human 代码；\n(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；\n(3). 如果"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new Father()"}]},{"type":"text","value":"过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。"}]},{"type":"element","tag":"h3","props":{"id":"_2-依赖注入"},"children":[{"type":"text","value":"2. 依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下："}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    Father father;\n    ...\n    public Human(Father father) {\n        this.father = father;\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human(Father father) {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"        this.father = father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":8},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。"}]},{"type":"text","value":"\n现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：\n(1). 解耦，将依赖之间解耦。\n(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。"}]},{"type":"element","tag":"h3","props":{"id":"_3-java-中的依赖注入"},"children":[{"type":"text","value":"3. Java 中的依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。"}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    @Inject Father father;\n    ...\n    public Human() {\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    @Inject Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human() {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面这段代码看起来很神奇：只是增加了一个注解，\nFather 对象就能自动注入了？这个注入过程是怎么完成的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。\n现在 Java 语言中较流行的依赖注入框架有 "},{"type":"element","tag":"a","props":{"href":"https://github.com/google/guice","rel":["nofollow"]},"children":[{"type":"text","value":"Google Guice"}]},{"type":"text","value":"、\n"},{"type":"element","tag":"a","props":{"href":"http://projects.spring.io/spring-framework/","rel":["nofollow"]},"children":[{"type":"text","value":"Spring"}]},{"type":"text","value":" 等，而在 Android 上比较流行的有\n"},{"type":"element","tag":"a","props":{"href":"https://github.com/roboguice/roboguice","rel":["nofollow"]},"children":[{"type":"text","value":"RoboGuice"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"http://square.github.io/dagger/","rel":["nofollow"]},"children":[{"type":"text","value":"Dagger"}]},{"type":"text","value":" 等。其中 Dagger 是我现在正在项目中使用的。\n如果感兴趣，你可以到 "},{"type":"element","tag":"a","props":{"href":"https://github.com/android-cn/android-open-project-analysis/tree/master/dagger","rel":["nofollow"]},"children":[{"type":"text","value":"Dagger 实现原理解析"}]},{"type":"text","value":" 了解更多依赖注入和 Dagger 实现原理相关信息。"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-依赖","depth":3,"text":"1. 依赖"},{"id":"_2-依赖注入","depth":3,"text":"2. 依赖注入"},{"id":"_3-java-中的依赖注入","depth":3,"text":"3. Java 中的依赖注入"}]}},"_type":"markdown","_id":"content:blog:java:inject:intro.md","_source":"content","_file":"blog/java/inject/intro.md","_extension":"md"},{"_path":"/blog/linux/autoconf_automake","_dir":"linux","_draft":false,"_partial":false,"_locale":"","title":"autoconf 和 automake","description":"只使用autoconf来构建","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"autoconf-和-automake"},"children":[{"type":"text","value":"autoconf 和 automake"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"只使用autoconf来构建"}]},{"type":"element","tag":"pre","props":{"code":"your source files --> [autoscan*] --> [configure.scan] --> configure.ac\n \n configure.ac --.\n                |   .------> autoconf* -----> configure\n [aclocal.m4] --+---+\n                |   `-----> [autoheader*] --> [config.h.in]\n [acsite.m4] ---'\n \n Makefile.in\n \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"your source files --> [autoscan*] --> [configure.scan] --> configure.ac\n \n configure.ac --.\n                |   .------> autoconf* -----> configure\n [aclocal.m4] --+---+\n                |   `-----> [autoheader*] --> [config.h.in]\n [acsite.m4] ---'\n \n Makefile.in\n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果增加使用automake来构建"}]},{"type":"element","tag":"pre","props":{"code":" [acinclude.m4] --.\n                  |\n [local macros] --+--> aclocal* --> aclocal.m4\n                  |\n configure.ac ----'\n \n configure.ac --.\n                +--> automake* --> Makefile.in\n Makefile.am ---'\n \n \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" [acinclude.m4] --.\n                  |\n [local macros] --+--> aclocal* --> aclocal.m4\n                  |\n configure.ac ----'\n \n configure.ac --.\n                +--> automake* --> Makefile.in\n Makefile.am ---'\n \n \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用到配置软件包中的文件"}]},{"type":"element","tag":"pre","props":{"code":"图：\n                        .-------------> [config.cache]\n configure* ------------+-------------> config.log\n                        |\n [config.h.in] -.       v            .-> [config.h] -.\n                +--> config.status* -+               +--> make*\n Makefile.in ---'                    `-> Makefile ---'\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"图：\n                        .-------------> [config.cache]\n configure* ------------+-------------> config.log\n                        |\n [config.h.in] -.       v            .-> [config.h] -.\n                +--> config.status* -+               +--> make*\n Makefile.in ---'                    `-> Makefile ---'\n"}]}]},{"type":"element","tag":"h1","props":{"id":"automake"},"children":[{"type":"text","value":"automake"}]},{"type":"element","tag":"h2","props":{"id":"标准的makefile目标"},"children":[{"type":"text","value":"标准的makefile目标"}]},{"type":"element","tag":"pre","props":{"code":"all         默认执行的目标，编译文件\ninstall     安装文件，兵拷贝包内文件\ninstall-trip    没有调试信息的install\nuninstall   卸载文件\nclean       清空 make all的文件\ndistclean   在clean的基础上再清除 ./configure创建的文件\ncheck       跑测试套件\ninstallcheck     检查已安装的程序或库文件\ndist        用源码重新创建package-version.tar.gz文件\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"all         默认执行的目标，编译文件\ninstall     安装文件，兵拷贝包内文件\ninstall-trip    没有调试信息的install\nuninstall   卸载文件\nclean       清空 make all的文件\ndistclean   在clean的基础上再清除 ./configure创建的文件\ncheck       跑测试套件\ninstallcheck     检查已安装的程序或库文件\ndist        用源码重新创建package-version.tar.gz文件\n"}]}]},{"type":"element","tag":"h2","props":{"id":"标准的安装步骤"},"children":[{"type":"text","value":"标准的安装步骤"}]},{"type":"element","tag":"pre","props":{"code":"./configure \nmake\nmake install\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"./configure \nmake\nmake install\n"}]}]},{"type":"element","tag":"h2","props":{"id":"标准目录变量"},"children":[{"type":"text","value":"标准目录变量"}]},{"type":"element","tag":"pre","props":{"code":"prefix          /usr/local\nbindir          ${prefix}/bin\nlibdir          ${prefix}/lib\nincludedir      ${prefix}/include\ndatarootdir     ${prefix}/share\nmandir          ${datarootdir}/man\ninfodir         ${datarootdir}/info\ndocdir          ${datarootdir}/doc/${PACKAGE}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"prefix          /usr/local\nbindir          ${prefix}/bin\nlibdir          ${prefix}/lib\nincludedir      ${prefix}/include\ndatarootdir     ${prefix}/share\nmandir          ${datarootdir}/man\ninfodir         ${datarootdir}/info\ndocdir          ${datarootdir}/doc/${PACKAGE}\n"}]}]},{"type":"element","tag":"h2","props":{"id":"标准配置变量"},"children":[{"type":"text","value":"标准配置变量"}]},{"type":"element","tag":"pre","props":{"code":"CC              c编译器的命令\nCFLAGS          c编译器的参数\nCXX             c++编译器命令\nCXXFLAGS        c++编译器参数\nLDFLAGS         链接器的参数\nCPPFLAGS        c/c++预处理器参数\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"CC              c编译器的命令\nCFLAGS          c编译器的参数\nCXX             c++编译器命令\nCXXFLAGS        c++编译器参数\nLDFLAGS         链接器的参数\nCPPFLAGS        c/c++预处理器参数\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"标准的makefile目标","depth":2,"text":"标准的makefile目标"},{"id":"标准的安装步骤","depth":2,"text":"标准的安装步骤"},{"id":"标准目录变量","depth":2,"text":"标准目录变量"},{"id":"标准配置变量","depth":2,"text":"标准配置变量"}]}},"_type":"markdown","_id":"content:blog:linux:autoconf_automake.md","_source":"content","_file":"blog/linux/autoconf_automake.md","_extension":"md"},{"_path":"/blog/linux/kbuild","_dir":"linux","_draft":false,"_partial":false,"_locale":"","title":"kbuild","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"kbuild"},"children":[{"type":"text","value":"kbuild"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考"},{"type":"element","tag":"a","props":{"href":"https://jin-yang.github.io/reference/linux/kernel/KBUILD_system.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"KBUILD系统原理分析"}]}]},{"type":"element","tag":"h2","props":{"id":"make-总结"},"children":[{"type":"text","value":"make 总结"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"依次读取变量\"MAKEFILES\"定义的makefile文件列表"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"读取工作目录下的Makefile文件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"依次读取工作目录makefile文件中使用指示符\"include\"包含的文件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"查找重建所有以读取的makefile文件的规则"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据“最终目标”以及其他目标的依赖关系建立依赖关系链表"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行除“最终目标”以外的所有的目标的规则"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"执行最终目标所在的规则"}]}]},{"type":"element","tag":"h2","props":{"id":"kbuild-make"},"children":[{"type":"text","value":"KBUILD MAKE"}]},{"type":"text","value":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"文件名"}]},{"type":"element","tag":"th","props":{},"children":[{"type":"text","value":"说明"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"Makefile"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"顶层 Makefile"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":".config"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"内核配置文件"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"arch/$(ARCH)/Makefile"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"具体架构的 Makefile"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"scripts/Makefile.*"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"通用的规则等，面向所有的 Kbuild Makefiles。"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"kbuild Makefiles"}]},{"type":"element","tag":"td","props":{},"children":[{"type":"text","value":"内核源代码中大约有 500 个这样的文件"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"目标定义"},"children":[{"type":"text","value":"目标定义"}]},{"type":"element","tag":"pre","props":{"code":"obj-$(CONFIG_FOO)+=foo.o\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"obj-$(CONFIG_FOO)+=foo.o\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"$(CONFIG_FOO) 可以为 y (编译进内核) 或 m (编译成模块)。否则的话  foo.o就不会被编译连接了"}]},{"type":"element","tag":"h4","props":{"id":"obj-y"},"children":[{"type":"text","value":"obj-y"}]},{"type":"element","tag":"pre","props":{"code":"KBuild Makefile规定编译进内核的文件都存在$(obj-y)的列表中。\n编译所有的$(obj-y)文件，然后调用$(LD) -r将它们合并到一个build-in.o文件中，然后该文件会被其父Makefile连接到vmlinux中\n$(obj-y)中的文件有顺序，可以重复项。连接过程有顺序，有些函数module_init()/__initcall将会在启动时按照他们出现的顺序进行调用。\n注意顺序会改变SCSI控制器的检测顺序，从而导致硬盘数据损害\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"KBuild Makefile规定编译进内核的文件都存在$(obj-y)的列表中。\n编译所有的$(obj-y)文件，然后调用$(LD) -r将它们合并到一个build-in.o文件中，然后该文件会被其父Makefile连接到vmlinux中\n$(obj-y)中的文件有顺序，可以重复项。连接过程有顺序，有些函数module_init()/__initcall将会在启动时按照他们出现的顺序进行调用。\n注意顺序会改变SCSI控制器的检测顺序，从而导致硬盘数据损害\n"}]}]},{"type":"element","tag":"h4","props":{"id":"obj-m"},"children":[{"type":"text","value":"obj-m"}]},{"type":"element","tag":"pre","props":{"code":"列举了哪些文件要编译成可装载模块\n一个模块可以由一个文件或多个文件编译而成。\n一个文件直接加$(obj-m)\n多个文件，需要声明编译的模块。通过变量$(<module_name>-objs)声明哪些文件在\n让 KbuildMakefile 可以通过使用 CONFIG_符号来判断该对象是否是用来组合对象的\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"列举了哪些文件要编译成可装载模块\n一个模块可以由一个文件或多个文件编译而成。\n一个文件直接加$(obj-m)\n多个文件，需要声明编译的模块。通过变量$(<module_name>-objs)声明哪些文件在\n让 KbuildMakefile 可以通过使用 CONFIG_符号来判断该对象是否是用来组合对象的\n"}]}]},{"type":"element","tag":"h4","props":{"id":"lib-y"},"children":[{"type":"text","value":"lib-y"}]},{"type":"element","tag":"pre","props":{"code":"其中所列的文件来组成目录下的一个库文件。\n在obj-y和lib-y中同时出现的文件，因为都是可以访问的，所以该文件不会被包含在库文件中。\n相同情况的lib-m中的文件就会包含在lib.a库文件中\nbuild-in.o和lib.a可以同时出现在一个目录里面\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"其中所列的文件来组成目录下的一个库文件。\n在obj-y和lib-y中同时出现的文件，因为都是可以访问的，所以该文件不会被包含在库文件中。\n相同情况的lib-m中的文件就会包含在lib.a库文件中\nbuild-in.o和lib.a可以同时出现在一个目录里面\n"}]}]},{"type":"element","tag":"h4","props":{"id":"访问子目录"},"children":[{"type":"text","value":"访问子目录"}]},{"type":"element","tag":"pre","props":{"code":"一个Makefile只对编译所在的目录对象负责。在子目录中的文件的编译要由其所在的子目录的MakeFile来管理。\n通过obj-$(CONFIG_MODULE_NAME) += module_dirctory/\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"一个Makefile只对编译所在的目录对象负责。在子目录中的文件的编译要由其所在的子目录的MakeFile来管理。\n通过obj-$(CONFIG_MODULE_NAME) += module_dirctory/\n"}]}]},{"type":"element","tag":"h4","props":{"id":"编辑标志"},"children":[{"type":"text","value":"编辑标志"}]},{"type":"element","tag":"pre","props":{"code":"EXTRA_变量只在所定义的Kbuild Makefile中起作用\n\n$(EXTRA_CFLAGS) 是用 $(CC) 编译 C 源文件时的选项。\n$(EXTRA_AFLAGS)也是一个针对每个目录的选项，只不过它是用来编译汇编源代码的。\n$(EXTRA_LDFLAGS) 和 $(EXTRA_ARFLAGS)分别与 $(LD)和 $(AR)类似，只不过，他们是针对每个目录的。\n\n$(CFLAGS_$@) 是 $(CC) 针对每个文件的选项。$@ 表明了具体操作的文件。\n$(AFLAGS_$@) 也类似，只不是是针对汇编语言的。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"EXTRA_变量只在所定义的Kbuild Makefile中起作用\n\n$(EXTRA_CFLAGS) 是用 $(CC) 编译 C 源文件时的选项。\n$(EXTRA_AFLAGS)也是一个针对每个目录的选项，只不过它是用来编译汇编源代码的。\n$(EXTRA_LDFLAGS) 和 $(EXTRA_ARFLAGS)分别与 $(LD)和 $(AR)类似，只不过，他们是针对每个目录的。\n\n$(CFLAGS_$@) 是 $(CC) 针对每个文件的选项。$@ 表明了具体操作的文件。\n$(AFLAGS_$@) 也类似，只不是是针对汇编语言的。\n"}]}]},{"type":"element","tag":"h4","props":{"id":"其他"},"children":[{"type":"text","value":"其他"}]},{"type":"element","tag":"pre","props":{"code":"跟踪依赖\n    \n    1、所有要参与编译的文件（.c和.h)文件\n    2、在参与编译文件中所要使用的CONFIG_选项\n    3、用于编译目标的命令行\n    \n    \n特殊依赖\n    \n    $(src)表明 Makefile所在目录的相对路径。经常在定位源代码树中的文件时，使用该变量。\n    $(obj) 表明目标文件所要存储目录的相对路径。经常在定位所生成的文件时，使用该变量。\n    \n支持的函数\nas-option，当编译汇编文件(*.S)时，用来检查 $(CC) 是否支持特定选项。如果第一个选项不支持的话，可选的第二个选项可以用来指定。\nld-option，当联接目标文件时，用来检查 $(CC) 是否支持特定选项。如果第一个选项不支持的话，可选的第二个选项可以用来指定。\ncc-option，用来检查 $(CC) 是否支持特定选项,并且不支持使用可选的第二项。\ncc-option-yn,用来检查 gcc 是否支持特定选项，返回'y'支持，否则为'n'。\n\ncc-option-align  : gcc 版本大于 3.0时，改变了函数，循环等用来声明内存对齐的选项。当用到对齐选项时，$(cc-option-align) 用来选择正确的前缀\ncc-version 以数学形式返回 $(CC)编译器的版本号。其格式是：<major><minor>，二者都是数学。\ncc-ifversion 测试 $(CC) 的版本号，如果版本表达式为真，就赋值为最后的参数。    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"跟踪依赖\n    \n    1、所有要参与编译的文件（.c和.h)文件\n    2、在参与编译文件中所要使用的CONFIG_选项\n    3、用于编译目标的命令行\n    \n    \n特殊依赖\n    \n    $(src)表明 Makefile所在目录的相对路径。经常在定位源代码树中的文件时，使用该变量。\n    $(obj) 表明目标文件所要存储目录的相对路径。经常在定位所生成的文件时，使用该变量。\n    \n支持的函数\nas-option，当编译汇编文件(*.S)时，用来检查 $(CC) 是否支持特定选项。如果第一个选项不支持的话，可选的第二个选项可以用来指定。\nld-option，当联接目标文件时，用来检查 $(CC) 是否支持特定选项。如果第一个选项不支持的话，可选的第二个选项可以用来指定。\ncc-option，用来检查 $(CC) 是否支持特定选项,并且不支持使用可选的第二项。\ncc-option-yn,用来检查 gcc 是否支持特定选项，返回'y'支持，否则为'n'。\n\ncc-option-align  : gcc 版本大于 3.0时，改变了函数，循环等用来声明内存对齐的选项。当用到对齐选项时，$(cc-option-align) 用来选择正确的前缀\ncc-version 以数学形式返回 $(CC)编译器的版本号。其格式是：<major><minor>，二者都是数学。\ncc-ifversion 测试 $(CC) 的版本号，如果版本表达式为真，就赋值为最后的参数。    \n"}]}]},{"type":"element","tag":"h3","props":{"id":"本地程序支持"},"children":[{"type":"text","value":"本地程序支持"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kbuild将编译分成了2个阶段"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"告诉Kbuild存在哪些可执行文件。通过变量hostprogs-y来完成的。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"添加一个对可执行文件的显性依赖。（通过增加依赖关系到一个规则中，或是利用$(always)）"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"$("},{"type":"element","tag":"executeable","props":{},"children":[{"type":"text","value":"-objs) 列出了联接成最后的可执行文件所需的所有目标文件。"}]}]},{"type":"element","tag":"h4","props":{"id":"定义共享库"},"children":[{"type":"text","value":"定义共享库"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"扩展名为 so 的文件称为共享库，被编译成位置无关对象。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"共享库文件经常要求一个相应的 -objs，"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程序经常是利用$(HOSTCC)编译,其选项在 $(HOSTCFLAGS)变量中。可通过使用变量 HOST＿EXTRACFLAGS，影响所有在 Makefile 文件中要创建的主机程序。"}]},{"type":"element","tag":"h3","props":{"id":"构建makefile"},"children":[{"type":"text","value":"构建Makefile"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Kbuild 执行的几个步骤"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"根据内核配置生产文件.config"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"将内核的版本号存储在include/linux/version.h"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"生产指向include/asm-$(ARCH)的符号链接"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"更新所有编译所需的文件：附加的文件由arch/$(ARCH)/Makefile指定"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"递归向下访问所有在下列变量中列出的目录 init-* core* drivers-* net-* libs-*,并编译生成目标文件。这些变量的值可以再arch/$(ARCH)/Makefile中扩充。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"链接所有的目标文件，在源代码树顶层目录中生成vmlinux。最先链接是在head-y中列出的文件，该变量由arch/$(ARCH)/Makefile赋值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"最后完成具体架构的特殊要求，并生成最终的启动镜像（ 包含生成启动指令， 准备 initrd 镜像或类似文件）"}]}]},{"type":"element","tag":"h4","props":{"id":"针对具体架构的调整"},"children":[{"type":"text","value":"针对具体架构的调整"}]},{"type":"element","tag":"pre","props":{"code":"LDFLAGS 一般是$(LD)选项\nLDFLAGS_Module 链接模块时的链接器选项，在链接模块.ko文件使用\nLDFLAGS_vmlinux 用来链接vmlinux时使用\n\nOBJCOMPYFLAGS objcopy选项\n$(call if_changed,objcopy) 经常被用来为 vmlinux 生成原始的二进制代码\n\nAFLAGS $(AS) 汇编编译器选项\n\nCFLAGS $(CC) 编译器选项\n\n$(CFLAGS_KERNEL) 包含了用于编译常驻内核代码的附加编译器选项。\n\n$(CFLAGS_MODULE) 包含了用于编译可装载模块的附加编译器选项。\n\narchprepare 规则在递归访问子目录之前，列出编译目标文件所需文件。\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"LDFLAGS 一般是$(LD)选项\nLDFLAGS_Module 链接模块时的链接器选项，在链接模块.ko文件使用\nLDFLAGS_vmlinux 用来链接vmlinux时使用\n\nOBJCOMPYFLAGS objcopy选项\n$(call if_changed,objcopy) 经常被用来为 vmlinux 生成原始的二进制代码\n\nAFLAGS $(AS) 汇编编译器选项\n\nCFLAGS $(CC) 编译器选项\n\n$(CFLAGS_KERNEL) 包含了用于编译常驻内核代码的附加编译器选项。\n\n$(CFLAGS_MODULE) 包含了用于编译可装载模块的附加编译器选项。\n\narchprepare 规则在递归访问子目录之前，列出编译目标文件所需文件。\n\n"}]}]},{"type":"element","tag":"h4","props":{"id":"自定义kbuild命令"},"children":[{"type":"text","value":"自定义kbuild命令"}]},{"type":"element","tag":"pre","props":{"code":"    当 Kbuild 的变量 KBUILD_VERBOSE 为 0 时，只会显示命令的简写。\n    如果要为自定义命令使用这一功能，需要设置 2 个变量：\n    quiet_cmd_<command> - 要显示的命令\n    cmd_<command> - 要执行的命令\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    当 Kbuild 的变量 KBUILD_VERBOSE 为 0 时，只会显示命令的简写。\n    如果要为自定义命令使用这一功能，需要设置 2 个变量：\n    quiet_cmd_<command> - 要显示的命令\n    cmd_<command> - 要执行的命令\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"make-总结","depth":2,"text":"make 总结"},{"id":"kbuild-make","depth":2,"text":"KBUILD MAKE","children":[{"id":"目标定义","depth":3,"text":"目标定义"},{"id":"本地程序支持","depth":3,"text":"本地程序支持"},{"id":"构建makefile","depth":3,"text":"构建Makefile"}]}]}},"_type":"markdown","_id":"content:blog:linux:kbuild.md","_source":"content","_file":"blog/linux/kbuild.md","_extension":"md"},{"_path":"/blog/linux/libseccomp","_dir":"linux","_draft":false,"_partial":false,"_locale":"","title":"libseccomp","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"libseccomp"},"children":[{"type":"text","value":"libseccomp"}]},{"type":"element","tag":"h2","props":{"id":"说明"},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"seccomp(全称securecomputing mode) 是linuxkernel从2.6.23版本开始所支持的一种安全机制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Linux系统里,大量的系统调用(systemcall)直接暴露给用户态程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是,并不是所有的系统调用都被需要,而且不安全的代码滥用系统调用会对系统造成安全威胁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过seccomp,我们限制程序使用某些系统调用,这样可以减少系统的暴露面,同时是程序进入一种“安全”的状态。"}]},{"type":"element","tag":"h2","props":{"id":"编译"},"children":[{"type":"text","value":"编译"}]},{"type":"element","tag":"pre","props":{"code":"git clone https://github.com/seccomp/libseccomp.git\n//自己选择 tag 或 branch 默认最新\n./autogen.sh            //需要autoconf automake\n./configure\nmake V=1\nmake install\nmake check\n\n在构建完成之后，doc/man目录下面有可以参考的手册，通过man xxxx 来查询详细的使用用法\n\n其他的一些参考资料\nDocumentation/prctl/seccomp_filter.txt\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\nhttp://man7.org/linux/man-pages/man2/seccomp.2.html\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git clone https://github.com/seccomp/libseccomp.git\n//自己选择 tag 或 branch 默认最新\n./autogen.sh            //需要autoconf automake\n./configure\nmake V=1\nmake install\nmake check\n\n在构建完成之后，doc/man目录下面有可以参考的手册，通过man xxxx 来查询详细的使用用法\n\n其他的一些参考资料\nDocumentation/prctl/seccomp_filter.txt\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\nhttp://man7.org/linux/man-pages/man2/seccomp.2.html\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"项目构建"},"children":[{"type":"text","value":"项目构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"libseccomp是由 automake 组织构建的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看 configure.ac文件"}]},{"type":"element","tag":"pre","props":{"code":"\nAC_INIT([libseccomp], [2.3.3])      //定义了包名和版本号\n\nAC_CONFIG_AUX_DIR([build-aux])      //辅助工具的存放路径\n\nAC_CONFIG_HEADERS([configure.h])    //宏定义变量的变量集合\n\nAC_CONFIG_MACRO_DIR([m4])           //指定本地autoconf宏的位置,m4文件夹下定义了check-code-coverage\n\n\n//m4 中  define (name, [expansion])\nm4_define([serial_tests], [\n    //m4 中  esyscmd(shell-command)\n    m4_esyscmd([automake --version |\n                head -1 |\n                awk '{split ($NF,a,\".\"); if (a[1] == 1 && a[2] >= 12) { print \"serial-tests\" }}'\n    ])\n])\n//根据automake的版本去\n\n\nAM_INIT_AUTOMAKE(-Wall foreign subdir-objects tar-pax serial_tests)     //增加make  的 options\n\n\nAC_PROG_CC              //检查要使用的c编译器\nAM_PROG_CC_C_O          //测试上面的次编译器的 -c 和 -o\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([shared pic-only])      //启用libtool\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])       //减少构建输出\n\n\nAM_CPPFLAGS=\"-I\\${top_srcdir}/include\"      //cpp flags\nAM_CFLAGS=\"-Wall\"                           //c   flags\nAM_LDFLAGS=\"-Wl,-z -Wl,relro\"               //ld  flags\nAC_SUBST([AM_CPPFLAGS])             //加入变量\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n\nAC_CHECK_HEADERS_ONCE([linux/seccomp.h])        //检查下这个文件是否存在\n\n\n//获取版本信息\nVERSION_MAJOR=$(echo ${VERSION} | cut -d'.' -f 1)\nVERSION_MINOR=$(echo ${VERSION} | cut -d'.' -f 2)\nVERSION_MICRO=$(echo ${VERSION} | cut -d'.' -f 3)\nAC_SUBST([VERSION_MAJOR])\nAC_SUBST([VERSION_MINOR])\nAC_SUBST([VERSION_MICRO])\n\n// cython checks   略\n// python binding checks   略\n// coverity checks 略\n// code coverage checks\n\n//指明需要版本信息来生成的文件\nAC_CONFIG_FILES([\n    libseccomp.pc\n    include/seccomp.h\n])\n\n//指明需要生成的各级Makefile\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    src/Makefile\n    src/python/Makefile\n    tools/Makefile\n    tests/Makefile\n    doc/Makefile\n])\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nAC_INIT([libseccomp], [2.3.3])      //定义了包名和版本号\n\nAC_CONFIG_AUX_DIR([build-aux])      //辅助工具的存放路径\n\nAC_CONFIG_HEADERS([configure.h])    //宏定义变量的变量集合\n\nAC_CONFIG_MACRO_DIR([m4])           //指定本地autoconf宏的位置,m4文件夹下定义了check-code-coverage\n\n\n//m4 中  define (name, [expansion])\nm4_define([serial_tests], [\n    //m4 中  esyscmd(shell-command)\n    m4_esyscmd([automake --version |\n                head -1 |\n                awk '{split ($NF,a,\".\"); if (a[1] == 1 && a[2] >= 12) { print \"serial-tests\" }}'\n    ])\n])\n//根据automake的版本去\n\n\nAM_INIT_AUTOMAKE(-Wall foreign subdir-objects tar-pax serial_tests)     //增加make  的 options\n\n\nAC_PROG_CC              //检查要使用的c编译器\nAM_PROG_CC_C_O          //测试上面的次编译器的 -c 和 -o\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([shared pic-only])      //启用libtool\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])       //减少构建输出\n\n\nAM_CPPFLAGS=\"-I\\${top_srcdir}/include\"      //cpp flags\nAM_CFLAGS=\"-Wall\"                           //c   flags\nAM_LDFLAGS=\"-Wl,-z -Wl,relro\"               //ld  flags\nAC_SUBST([AM_CPPFLAGS])             //加入变量\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n\nAC_CHECK_HEADERS_ONCE([linux/seccomp.h])        //检查下这个文件是否存在\n\n\n//获取版本信息\nVERSION_MAJOR=$(echo ${VERSION} | cut -d'.' -f 1)\nVERSION_MINOR=$(echo ${VERSION} | cut -d'.' -f 2)\nVERSION_MICRO=$(echo ${VERSION} | cut -d'.' -f 3)\nAC_SUBST([VERSION_MAJOR])\nAC_SUBST([VERSION_MINOR])\nAC_SUBST([VERSION_MICRO])\n\n// cython checks   略\n// python binding checks   略\n// coverity checks 略\n// code coverage checks\n\n//指明需要版本信息来生成的文件\nAC_CONFIG_FILES([\n    libseccomp.pc\n    include/seccomp.h\n])\n\n//指明需要生成的各级Makefile\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    src/Makefile\n    src/python/Makefile\n    tools/Makefile\n    tests/Makefile\n    doc/Makefile\n])\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再看 makefile.am文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顶层目录的makefile"}]},{"type":"element","tag":"pre","props":{"code":"    ACLOCAL_AMFLAGS =-I m4      //需要引用的宏的地址\n    SUBDIRS = include src tools tests doc   //下级 makefile.am地址\n    \n    pkgconfdir = ${libdir}/pkgconfig    \n    pkgconf_DATA = libseccomp.pc\n    \n    EXTRA_DIST = CHANGELOG CREDITS LICENSE README.md SUBMITTING_PATCHES     //规范中没有定义，但是选上的文件\n\n    \n    //配置静默安装\n    AM_MAKEFLAGS_0 = --quiet --no-print-directory\n    AM_MAKEFLAGS_1 =\n    AM_MAKEFLAGS_ = ${AM_MAKEFLAGS_0}\n    AM_MAKEFLAGS = ${AM_MAKEFLAGS_@AM_V@}\n    \n    \n    //切到src和tests中构建\n    check-build: all\n    ${MAKE} ${AM_MAKEFLAGS} -C src check-build      \n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-build\n    \n    check-syntax:\n    @./tools/check-syntax       //使用astyle来优化代码格式\n    \n    check-code-coverage: check-build\n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-code-coverage    \n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    ACLOCAL_AMFLAGS =-I m4      //需要引用的宏的地址\n    SUBDIRS = include src tools tests doc   //下级 makefile.am地址\n    \n    pkgconfdir = ${libdir}/pkgconfig    \n    pkgconf_DATA = libseccomp.pc\n    \n    EXTRA_DIST = CHANGELOG CREDITS LICENSE README.md SUBMITTING_PATCHES     //规范中没有定义，但是选上的文件\n\n    \n    //配置静默安装\n    AM_MAKEFLAGS_0 = --quiet --no-print-directory\n    AM_MAKEFLAGS_1 =\n    AM_MAKEFLAGS_ = ${AM_MAKEFLAGS_0}\n    AM_MAKEFLAGS = ${AM_MAKEFLAGS_@AM_V@}\n    \n    \n    //切到src和tests中构建\n    check-build: all\n    ${MAKE} ${AM_MAKEFLAGS} -C src check-build      \n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-build\n    \n    check-syntax:\n    @./tools/check-syntax       //使用astyle来优化代码格式\n    \n    check-code-coverage: check-build\n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-code-coverage    \n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照SUBDIRS的顺序依次进入子目录， 首先是include。"}]},{"type":"element","tag":"pre","props":{"code":"    include_HEADERS = seccomp.h\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    include_HEADERS = seccomp.h\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"src目录"}]},{"type":"element","tag":"pre","props":{"code":"    //看是否开启Python，开启的话则增加PYTHON到子目录中\n    SUBDIRS = .\n    if ENABLE_PYTHON\n    SUBDIRS += python\n    endif  \n    \n    SOURCE_ALL = ...    //所有的源文件\n    \n    EXTRA_DIST = arch-syscall-validate\n\n    TESTS = arch-syscall-check\n    \n    check_PROGRAMS = arch-syscall-check arch-syscall-dump   //指定系统的测试程序\n    \n    lib_LTLIBRARIES = libseccomp.la\n    \n    arch_syscall_dump_SOURCES = arch-syscall-dump.c ${SOURCES_ALL}\n\n    arch_syscall_check_SOURCES = arch-syscall-check.c ${SOURCES_ALL}\n\n    libseccomp_la_SOURCES = ${SOURCES_ALL}\n    libseccomp_la_CPPFLAGS = ${AM_CPPFLAGS} ${CODE_COVERAGE_CPPFLAGS} \\\n        -I${top_builddir}/include\n    libseccomp_la_CFLAGS = ${AM_CFLAGS} ${CODE_COVERAGE_CFLAGS} ${CFLAGS} \\\n        -fPIC -DPIC -fvisibility=hidden\n    libseccomp_la_LDFLAGS = ${AM_LDFLAGS} ${CODE_COVERAGE_LDFLAGS} ${LDFLAGS} \\\n        -version-number ${VERSION_MAJOR}:${VERSION_MINOR}:${VERSION_MICRO}\n    \n    check-build:\n        ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}       \n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    //看是否开启Python，开启的话则增加PYTHON到子目录中\n    SUBDIRS = .\n    if ENABLE_PYTHON\n    SUBDIRS += python\n    endif  \n    \n    SOURCE_ALL = ...    //所有的源文件\n    \n    EXTRA_DIST = arch-syscall-validate\n\n    TESTS = arch-syscall-check\n    \n    check_PROGRAMS = arch-syscall-check arch-syscall-dump   //指定系统的测试程序\n    \n    lib_LTLIBRARIES = libseccomp.la\n    \n    arch_syscall_dump_SOURCES = arch-syscall-dump.c ${SOURCES_ALL}\n\n    arch_syscall_check_SOURCES = arch-syscall-check.c ${SOURCES_ALL}\n\n    libseccomp_la_SOURCES = ${SOURCES_ALL}\n    libseccomp_la_CPPFLAGS = ${AM_CPPFLAGS} ${CODE_COVERAGE_CPPFLAGS} \\\n        -I${top_builddir}/include\n    libseccomp_la_CFLAGS = ${AM_CFLAGS} ${CODE_COVERAGE_CFLAGS} ${CFLAGS} \\\n        -fPIC -DPIC -fvisibility=hidden\n    libseccomp_la_LDFLAGS = ${AM_LDFLAGS} ${CODE_COVERAGE_LDFLAGS} ${LDFLAGS} \\\n        -version-number ${VERSION_MAJOR}:${VERSION_MINOR}:${VERSION_MICRO}\n    \n    check-build:\n        ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}       \n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"tools的makefile.am"}]},{"type":"element","tag":"pre","props":{"code":"AM_CPPFLAGS = -I${top_builddir}/include\n\nnoinst_LTLIBRARIES = util.la        //lib_LTLIBRARIES\nutil_la_SOURCES = util.c util.h bpf.h\nutil_la_LDFLAGS = -module\n\n    //安装的程序\nbin_PROGRAMS = \\\n    scmp_sys_resolver\n    \n    //没有安装的程序\nnoinst_PROGRAMS = \\\n    scmp_arch_detect \\\n    scmp_bpf_disasm \\\n    scmp_bpf_sim\n    \nEXTRA_DIST = check-syntax scmp_app_inspector\n\nscmp_bpf_disasm_SOURCES = scmp_bpf_disasm.c bpf.h util.h\nscmp_bpf_sim_SOURCES = scmp_bpf_sim.c bpf.h util.h\n\nscmp_sys_resolver_LDADD = ../src/libseccomp.la\nscmp_sys_resolver_LDFLAGS = -static\nscmp_arch_detect_LDADD = ../src/libseccomp.la\nscmp_arch_detect_LDFLAGS = -static\nscmp_bpf_disasm_LDADD = util.la\nscmp_bpf_sim_LDADD = util.la\n\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AM_CPPFLAGS = -I${top_builddir}/include\n\nnoinst_LTLIBRARIES = util.la        //lib_LTLIBRARIES\nutil_la_SOURCES = util.c util.h bpf.h\nutil_la_LDFLAGS = -module\n\n    //安装的程序\nbin_PROGRAMS = \\\n    scmp_sys_resolver\n    \n    //没有安装的程序\nnoinst_PROGRAMS = \\\n    scmp_arch_detect \\\n    scmp_bpf_disasm \\\n    scmp_bpf_sim\n    \nEXTRA_DIST = check-syntax scmp_app_inspector\n\nscmp_bpf_disasm_SOURCES = scmp_bpf_disasm.c bpf.h util.h\nscmp_bpf_sim_SOURCES = scmp_bpf_sim.c bpf.h util.h\n\nscmp_sys_resolver_LDADD = ../src/libseccomp.la\nscmp_sys_resolver_LDFLAGS = -static\nscmp_arch_detect_LDADD = ../src/libseccomp.la\nscmp_arch_detect_LDFLAGS = -static\nscmp_bpf_disasm_LDADD = util.la\nscmp_bpf_sim_LDADD = util.la\n\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"test中的makefile.am"}]},{"type":"element","tag":"pre","props":{"code":"\n//code_coverage_rules  略\n\nLDADD = util.la ../src/libseccomp.la \n\ncheck_LTLIBRARIES = util.la\nutil_la_SOURCES = util.c util.h\nutil_la_LDFLAGS = -module\n\nTESTS = regression    //主体的测试程序\n\ncheck_PROGRAMS = ...\n\nEXTRA_DIST_TESTPYTHON = ...\n\nEXTRA_DIST_TESTCFGS = ...\n\nEXTRA_DIST_TESTSCRIPTS = regression testdiff testgen    // 3个测试脚本\n\nEXTRA_DIST_TESTVALGRIND = valgrind_test.supp\n\nnodist_00_test_SOURCES = 00-test.c\nEXTRA_PROGRAMS = 00-test\n\ncheck-build:\n    ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}\n\nclean-local:\n    ${RM} -f 00-test *.pyc\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n//code_coverage_rules  略\n\nLDADD = util.la ../src/libseccomp.la \n\ncheck_LTLIBRARIES = util.la\nutil_la_SOURCES = util.c util.h\nutil_la_LDFLAGS = -module\n\nTESTS = regression    //主体的测试程序\n\ncheck_PROGRAMS = ...\n\nEXTRA_DIST_TESTPYTHON = ...\n\nEXTRA_DIST_TESTCFGS = ...\n\nEXTRA_DIST_TESTSCRIPTS = regression testdiff testgen    // 3个测试脚本\n\nEXTRA_DIST_TESTVALGRIND = valgrind_test.supp\n\nnodist_00_test_SOURCES = 00-test.c\nEXTRA_PROGRAMS = 00-test\n\ncheck-build:\n    ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}\n\nclean-local:\n    ${RM} -f 00-test *.pyc\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"doc的就略过了，  筛选出关键的外部程序或脚本"}]},{"type":"element","tag":"pre","props":{"code":"    regression \n    \n    testdiff \\ testgen   // compare test output from different test runs  \n\n    check-syntax   //  a basic C style/format checking tool\n    \n    scmp_app_inspector  //a simple syscall inspector based on strace\n\n    scmp_sys_resolver \\ scmp_arch_detect \\   scmp_bpf_disasm \\  scmp_bpf_sim\n    \n    arch-syscall-validate       //a simple syscall validation tool\n\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    regression \n    \n    testdiff \\ testgen   // compare test output from different test runs  \n\n    check-syntax   //  a basic C style/format checking tool\n    \n    scmp_app_inspector  //a simple syscall inspector based on strace\n\n    scmp_sys_resolver \\ scmp_arch_detect \\   scmp_bpf_disasm \\  scmp_bpf_sim\n    \n    arch-syscall-validate       //a simple syscall validation tool\n\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进入tests目录"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"发现   "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"数字"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"名称"}]},{"type":"text","value":"."},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"c\\py\\tests"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是   regression脚本对上面的文件进行libseccomp的测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中  .c和 .py是测试的主题逻辑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".test文件则是参与测试的样例数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中主体的测试控制程序是 regression ， 可以通过 -h 来查看使用方法，默认不增加参数即可开启测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"regression是一个shell程序，分析其代码："}]},{"type":"element","tag":"pre","props":{"code":"        run_tests\n        |-->    run_test $batch_name $testnum $line $test_type\n        |       //其中举例 01-sim-allow.tests\n        |       //         01-sim-allow  01 \"01-sim-allow   all  0-350  N   N   N   N   N   N   ALLOW\"  bpf-sim\n            |-->\n                    |       run_test_basic\n                    |       run_test_bpf_sim_fuzz\n                    |       run_test_bpf_valgrind\n                    |       run_test_live\n                    |-->    run_test_bpf_sim     01-sim-allow  01   \"01-sim-allow    all    0-350   N   N   N   N   N   N   ALLOW\" \n                            |--> run_test_command \"$testnumstr\" \"./$testname\" \"-b\" 4 \"\"\n                                    |-->  01-sim-allow\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        run_tests\n        |-->    run_test $batch_name $testnum $line $test_type\n        |       //其中举例 01-sim-allow.tests\n        |       //         01-sim-allow  01 \"01-sim-allow   all  0-350  N   N   N   N   N   N   ALLOW\"  bpf-sim\n            |-->\n                    |       run_test_basic\n                    |       run_test_bpf_sim_fuzz\n                    |       run_test_bpf_valgrind\n                    |       run_test_live\n                    |-->    run_test_bpf_sim     01-sim-allow  01   \"01-sim-allow    all    0-350   N   N   N   N   N   N   ALLOW\" \n                            |--> run_test_command \"$testnumstr\" \"./$testname\" \"-b\" 4 \"\"\n                                    |-->  01-sim-allow\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意:由于参数较多，组合起来的测试方案多种多样，所以"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"xxxx.tests"}]},{"type":"text","value":"文件中定义 range的模式，比0-300表示 0 到 300，regression会将这些表示拆开，然后分别执行，在对比日志的时候可以得到佐证。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"regression的最后通过调用 run_test_command 最后进入了 c的测试程序，在进入c的测试程序之前，我们需要熟悉下libseccomp 的一些api。"}]},{"type":"element","tag":"pre","props":{"code":"        //初始化seccomp filter state\n        scmp_filter_ctx seccomp_init(uint32_t def_action);\n        int seccomp_reset(scmp_filter_ctx ctx, unit32_t def_action);\n            def_action：\n                SCMP_ACT_KILL , SCMP_ACT_TRAP , ACMP_ACT_ERRNO , SCMP_ACT_TRACE , SCMP_ACT_ALLOW\n                \n        //释放seccomp filter state  ,已经loaded into kernel不受影响\n        void seccomp_release(scmp_filter_ctx ctx);\n        //合并两个seccomp filter,src会被释放，不需要在调用 seccomp_release\n        //filter值需要一致，架构需要重叠\n        int seccomp_merge(scmp_filter_ctx dst, scmp_filter_ctx src);\n        \n        \n        //架构管理\n       uint32_t seccomp_arch_resolve_name(const char *arch_name);\n       uint32_t seccomp_arch_native();\n       int seccomp_arch_exist(const scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_add(scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_remove(scmp_filter_ctx ctx, uint32_t arch_token);\n        \n            uint32_t arch_token 由 SCMP_ARCH_* 定义的常量\n            SCMP_ARCH_NATIVE 常量总是指向本地编译的架构\n            当一个新的架构加进来的时候，老 的filter和它没关系，但是后面新增的filter都跟他相关。\n            \n        //属性管理\n        int seccomp_attr_set(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t value)\n        int seccomp_attr_get(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t *value)\n        \n            可选的scmp_filter_attr为\n            \n                SCMP_FLTATR_ACT_DEFAULT\n                    只读属性\n                SCMP_FLTATR_ACT_BADARCH     //def_action\n                    如果架构不匹配，那么默认 SCMP_ACT_KILL\n                SCMP_FLTATR_CTL_NNP         //boolean\n                    定义NO_NEW_PRIVS在filter加载到内核之前就应该被启动。如果这个为0，那么会去检查 CAP_SYS_ADMIN，不然失败。默认1。\n                SCMP_FLTATR_CTL_TSYNC       //boolean\n                    设置表示seccomp_load调用的时候需要全部同步filter\n                SCMP_FLTATR_ATL_TSKIP       //boolean\n                    设置表示可以创建 -1的syscall \n        //导出seccomp filter\n        int seccomp_export_bpf(const scmp_filter_ctx, int fd);      //bpf   --> Berkley Packet Filter\n        int seccomp_export_pfc(const scmp_filter_ctx, int fd);      //pfc  --> Pseudo Filter Code\n            \n        //装载filter到kernel中\n        int seccomp_load(scmp_filter_ctx ctx);  //成功的加载\n        \n        //增加 seccomp filter rule\n        int SCMP_SYS(syscall_name);\n        struct scmp_arg_cmp SCMP_CMP(unsigned int arg, enum scmp_compare op, ...);\n        struct scmp_arg_cmp SCMP_A0(enum scmp_compare op, ...);\n        ...\n        struct scmp_arg_cmp SCMP_A5(enum scmp_compare op, ...);\n        int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action , int syscall, unsigned int arg_cnt, ...);\n        int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,    int syscall, unsigned int arg_cnt, ...);\n        \n        int seccomp_rule_add_array(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        int seccomp_rule_add_exact_array(scmp_filter_ctx ctx, uint32_t action, int syscal, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        \n            新加入的filter rule需要load进 kernel才会生效\n            SCMP_CMP（） 和 SCMP_A{0-5}()宏 生成一个 scmp_arg_cmp结构用到上面的函数中。\n    \n        \n            //区分 seccomp filter 中的 syscall\n            int seccomp_syscall_priority(scmp_filter_ctx ctx, int syscall, uint8_t priority);\n            //解析syscall名称\n            int seccomp_syscall_resolve_name(const char *name);\n            int seccomp_syscall_resolve_name_arch(uint32_t arch_token, const char *name);\n            int seccomp_syscall_resolve_name_rewrite(uint32_t arch_token, const char *name);\n            char *seccomp_syscall_resolve_num_arch(uint32_t arch_torken, int num);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        //初始化seccomp filter state\n        scmp_filter_ctx seccomp_init(uint32_t def_action);\n        int seccomp_reset(scmp_filter_ctx ctx, unit32_t def_action);\n            def_action：\n                SCMP_ACT_KILL , SCMP_ACT_TRAP , ACMP_ACT_ERRNO , SCMP_ACT_TRACE , SCMP_ACT_ALLOW\n                \n        //释放seccomp filter state  ,已经loaded into kernel不受影响\n        void seccomp_release(scmp_filter_ctx ctx);\n        //合并两个seccomp filter,src会被释放，不需要在调用 seccomp_release\n        //filter值需要一致，架构需要重叠\n        int seccomp_merge(scmp_filter_ctx dst, scmp_filter_ctx src);\n        \n        \n        //架构管理\n       uint32_t seccomp_arch_resolve_name(const char *arch_name);\n       uint32_t seccomp_arch_native();\n       int seccomp_arch_exist(const scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_add(scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_remove(scmp_filter_ctx ctx, uint32_t arch_token);\n        \n            uint32_t arch_token 由 SCMP_ARCH_* 定义的常量\n            SCMP_ARCH_NATIVE 常量总是指向本地编译的架构\n            当一个新的架构加进来的时候，老 的filter和它没关系，但是后面新增的filter都跟他相关。\n            \n        //属性管理\n        int seccomp_attr_set(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t value)\n        int seccomp_attr_get(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t *value)\n        \n            可选的scmp_filter_attr为\n            \n                SCMP_FLTATR_ACT_DEFAULT\n                    只读属性\n                SCMP_FLTATR_ACT_BADARCH     //def_action\n                    如果架构不匹配，那么默认 SCMP_ACT_KILL\n                SCMP_FLTATR_CTL_NNP         //boolean\n                    定义NO_NEW_PRIVS在filter加载到内核之前就应该被启动。如果这个为0，那么会去检查 CAP_SYS_ADMIN，不然失败。默认1。\n                SCMP_FLTATR_CTL_TSYNC       //boolean\n                    设置表示seccomp_load调用的时候需要全部同步filter\n                SCMP_FLTATR_ATL_TSKIP       //boolean\n                    设置表示可以创建 -1的syscall \n        //导出seccomp filter\n        int seccomp_export_bpf(const scmp_filter_ctx, int fd);      //bpf   --> Berkley Packet Filter\n        int seccomp_export_pfc(const scmp_filter_ctx, int fd);      //pfc  --> Pseudo Filter Code\n            \n        //装载filter到kernel中\n        int seccomp_load(scmp_filter_ctx ctx);  //成功的加载\n        \n        //增加 seccomp filter rule\n        int SCMP_SYS(syscall_name);\n        struct scmp_arg_cmp SCMP_CMP(unsigned int arg, enum scmp_compare op, ...);\n        struct scmp_arg_cmp SCMP_A0(enum scmp_compare op, ...);\n        ...\n        struct scmp_arg_cmp SCMP_A5(enum scmp_compare op, ...);\n        int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action , int syscall, unsigned int arg_cnt, ...);\n        int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,    int syscall, unsigned int arg_cnt, ...);\n        \n        int seccomp_rule_add_array(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        int seccomp_rule_add_exact_array(scmp_filter_ctx ctx, uint32_t action, int syscal, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        \n            新加入的filter rule需要load进 kernel才会生效\n            SCMP_CMP（） 和 SCMP_A{0-5}()宏 生成一个 scmp_arg_cmp结构用到上面的函数中。\n    \n        \n            //区分 seccomp filter 中的 syscall\n            int seccomp_syscall_priority(scmp_filter_ctx ctx, int syscall, uint8_t priority);\n            //解析syscall名称\n            int seccomp_syscall_resolve_name(const char *name);\n            int seccomp_syscall_resolve_name_arch(uint32_t arch_token, const char *name);\n            int seccomp_syscall_resolve_name_rewrite(uint32_t arch_token, const char *name);\n            char *seccomp_syscall_resolve_num_arch(uint32_t arch_torken, int num);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进入 01-sim-alloc.c 代码"}]},{"type":"element","tag":"pre","props":{"code":"    ...\n    ctx = seccomp_init(SCMP_ACT_ALLOW);\n    ...\n    rc = util_filter_output(&opts,ctx);\n         |--> _ctx_valid(ctx)\n         |--> program = gen_bpf_generate((struct db_filter_col *) ctx);\n                |--> _gen_bpf_build_bpf(stcut bpf_state *state,const struct db_filter_col *col)\n                            |--> ???\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    ...\n    ctx = seccomp_init(SCMP_ACT_ALLOW);\n    ...\n    rc = util_filter_output(&opts,ctx);\n         |--> _ctx_valid(ctx)\n         |--> program = gen_bpf_generate((struct db_filter_col *) ctx);\n                |--> _gen_bpf_build_bpf(stcut bpf_state *state,const struct db_filter_col *col)\n                            |--> ???\n    \n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"说明","depth":2,"text":"说明"},{"id":"编译","depth":2,"text":"编译"},{"id":"项目构建","depth":2,"text":"项目构建"}]}},"_type":"markdown","_id":"content:blog:linux:libseccomp.md","_source":"content","_file":"blog/linux/libseccomp.md","_extension":"md"},{"_path":"/blog/linux/shell","_dir":"linux","_draft":false,"_partial":false,"_locale":"","title":"shell","description":"参考：http://blog.csdn.net/u010861514/article/details/51028220","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"shell"},"children":[{"type":"text","value":"shell"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考："},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/u010861514/article/details/51028220","rel":["nofollow"]},"children":[{"type":"text","value":"http://blog.csdn.net/u010861514/article/details/51028220"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"留作记录，方便以后查询"}]},{"type":"element","tag":"pre","props":{"code":"shell 基础语法\n===============================================\n推荐：http://c.biancheng.net/cpp/shell/\n===============================================\n第一个Shell脚本\n===============================================\n格式：\n    （1）扩展名为sh（sh代表shell）\n                例如：bash.sh\n    （2）文件头（文件头固定格式）\n                如：#!/bin/bash\n\n作为可执行程序：\n    （1）使脚本具有执行权限\n        ~]# chmod +x ./test.sh\n    （2）执行脚本\n            1：可以不加执行权限\n                ~]$ bash abc.sh     （直接指明文件）\n                ~]$ bash ./abc.sh    （相对路径）\n                ~]$ bash /home/mdx/abc.sh （绝对路径）\n            2：必须加执行权限 （必须是绝对路径或者相对路径）\n                ~]# ./test.sh   （相对路径）\n                ~]$ /home/mdx/test.sh  （绝对路径）\n\n解释器参数（read）：\n        使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：\n        read   [option]  ...  A B\n           -p 'PROMPT'  提示符\n                ~] read -p \"提示符：\"     （接受其传入的参数）\n           -t    TIMEOUT\n\n===============================================\nShell变量\n===============================================\n定义：\n    （1）只能使用字母、数字和下划线；而且不能以数字开头。\n    （2）不能使用标点符号。\n    （3）不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n变量赋值：\n    （1）NAME=VALUE\n            =：赋值符号，两边不能有空格。把VALUE存储到NAME指向的内存空间中\n    （2）declare  命令\n                declare [-aAfFgilrtux] [-p] [name[=value] ...]\n                +:  指定变量的属性\n                -:  取消变量所设的属性\n                -a:  一个使名称索引的数组（如果支持的话）\n                -A:  一个使名称关联数组（如果支持）\n                -i:  “整数”属性\n                -l:  to convert NAMEs to lower case on assignment\n                -r:  名字只读\n                -t:   to make NAMEs have the 'trace' attribute\n                -u:  to convert NAMEs to upper case on assignment\n                -x:   to make NAMEs export\n\n重新赋值变量：\n    （1）NAME=VALUE（再次重新赋值）\n\n变量引用：\n    （1）${NAME}\n    （2）$NAME\n\n只读变量：\n    （1）readonly NAME（变量赋值后定义）\n\n删除变量：\n    （1）unset NAME\n\n变量类型：\n（1) 局部变量\n    局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n（2) 环境变量\n    所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n（3) shell变量\n    shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n===============================================\nShell特殊变量\n===============================================\n（1）$0：当前脚本的文件名\n                ~]# vi test.sh\n                        echo $0\n                ~]# ./test.sh\n                        ./test.sh\n（2）$n：传递给脚本或函数的参数。n 是一个数字，表示第几个参数。\n                ~]# ./test.sh param1 param2 param3 ......\n                ~]# vi test.sh\n                        echo $1 （param1：第1个参数）\n                        echo $2 （param2：第2个参数）\n                        echo $3 （param3：第3个参数）\n                        ......\n（3）$#：传递给脚本或函数的参数个数。\n                ~]# vi test.sh\n                        echo $#\n                ~]# ./test.sh param1 param2 param3 ......\n                        3\n（4）$*：传递给脚本或函数的所有参数。横向显示。\n                ~]# vi test.sh\n                       for var in \"$*\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1 param2 param3 ....\n（5）$@：传递给脚本或函数的所有参数。竖向显示。\n                ~]# vi test.sh\n                       for var in \"$@\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1\n                        param2\n                        param3\n                        ...\n（6）$?：上个命令的执行状态，或函数的返回值。\n                成功：0\n                失败：1-255\n（7）$$：当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。\n                ~]# vi test.sh\n                       echo $$\n                ~]# ./test.sh \n                        14781\n\n===============================================\nShell替换\n===============================================\n转义字符：\n    （1）\\\\  反斜杠\n    （2） \\a  警报，响铃\n    （3） \\b  退格（删除键）\n    （4） \\f  换页(FF)，将当前位置移到下页开头\n    （5） \\n  换行\n    （6） \\r  回车\n    （7） \\t  水平制表符（tab键）\n    （8） \\v  垂直制表符\n\n命令替换：\n    （1）：`command` 反引号\n    （2）：$(command)\n\n变量替换：\n    （1）${var}  变量本来的值\n    （2）${var:-word}    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n    （3）${var:=word}    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n    （4）${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n    （5）${var:+word}    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\n===============================================\nShell运算符\n===============================================\n 条件测试：\n    （1） test  EXPRESSION \n    （2）[ EXPRESSION ]\n    （3）[[ EXPRESSION ]]                       \n\n算术运算符\n    （1）+：加法\n    （2）-：减法\n    （3）*：乘法\n    （4）/：除法\n    （5）%：取余\n    （6）=：赋值\n    （7）==：相等\n    （8）!=：不相等\n\n    计算方式：\n        （1）expr\n                expr $a + $b\n                $(expr $a + $b)\n                `expr $a + $b`   （注意：这是反引号）\n                注意：符号号两边有空格\n        （2）$[$a+$b]\n        （3）let\n                let \"c = $a + $b\"  或者  let \"c=$a+$b\"  （注意：这是双引号）\n                let c=$a+$b （ 注意：符号号两边没有空格）\n        （4）$((expression))\n                c=$(( $a + $b ))\n                备注：空格可有可无\n\n数字运算符：\n    （1）-eq   是否等于  \n    （2）-ne   是否不等于\n    （3）-gt   是否大于\n    （4）-lt   小于    \n    （5）-ge  大于等于\n    （6）-le   是否小于等于 \n\n布尔运算符：\n        （1）-not  非运算。\n        （2）-o  或运算。\n        （3）-a  与运算。\n        （4）! 非运算。\n        （5）&& 与运算。\n        （6）||  或运算。\n\n字符串运算符：\n    （1）=  相等。\n    （2）!= 不相等。\n    （3）-z   判断字符串是否为空\n    （4）-n   判断字符串是否不为空\n    （5）str： 检测字符串是否为空。\n\n文件测试运算符：\n        -b file： 检测文件是否是块设备文件，\n        -c file： 检测文件是否是字符设备文件，\n        -d file： 检测文件是否是目录，\n        -f file： 检测文件是否是普通文件（既不是目录，也不是设备文件），\n        -g file： 检测文件是否设置了 SGID 位，\n        -k file： 检测文件是否设置了粘着位(Sticky Bit)，\n        -p file： 检测文件是否是具名管道，\n        -u file： 检测文件是否设置了 SUID 位，\n        -r file： 检测文件是否可读，\n        -w file： 检测文件是否可写，\n        -x file： 检测文件是否可执行，\n        -s file： 检测文件是否为空（文件大小是否大于0），不为空返回 true。\n        -a file： 检测文件（包括目录）是否存在，（-a 等同于 -e）\n        -e file： 检测文件（包括目录）是否存在，\n        -N  file   文件自从上一次读操作之后，是否被改过 \n        -O  file 当前用户是否为文件的属主\n        -G  file  当前用户是否为文件的属组\n\n      双目测试\n        FILE1 -ef FILE2  是否指向同一个文件系统的相同inode的硬链接\n        FILE1  -nt FILE2  FILE1文件，是否新于FILE2\n        FILE1 -ot  FILE2  FILE1文件，是否旧于FILE2\n\n其他运算符：\n    ?: 三元运算符\n    =~  左侧字符串是否能够被右侧的PATTERN所匹配 （说人话  包含）\n\n---------------------------------------------------------------------------------------\nlet 与 expr 语法详解\n---------------------------------------------------------------------------------------\nlet：评估算术表达式\n        id++, id--  variable post-increment, post-decrement\n        ++id, --id  variable pre-increment, pre-decrement\n        -, +        unary minus, plus\n        !, ~        logical and bitwise negation\n        **      exponentiation\n        *, /, %     multiplication, division, remainder\n        +, -        addition, subtraction\n        <<, >>      left and right bitwise shifts\n        <=, >=, <, >    comparison\n        ==, !=      equality, inequality\n        &       bitwise AND\n        ^       bitwise XOR\n        |       bitwise OR\n        &&      logical AND\n        ||      logical OR\n        expr ? expr : expr\n                conditional operator\n        =, *=, /=, %=,\n        +=, -=, <<=, >>=,\n        &=, ^=, |=  assignment\n---------------------------------------------------------------------------------------\nexpr：评价表达式 \n       ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n       ARG1 & ARG2  ARG1 if neither argument is null or 0, otherwise 0\n       ARG1 < ARG2    ARG1 is less than ARG2\n       ARG1 <= ARG2  ARG1 is less than or equal to ARG2\n       ARG1 = ARG2   ARG1 is equal to ARG2\n       ARG1 != ARG2   ARG1 is unequal to ARG2\n       ARG1 >= ARG2  ARG1 is greater than or equal to ARG2\n       ARG1 > ARG2  ARG1 is greater than ARG2\n       ARG1 + ARG2  arithmetic sum of ARG1 and ARG2\n       ARG1 - ARG2  arithmetic difference of ARG1 and ARG2\n       ARG1 * ARG2  arithmetic product of ARG1 and ARG2\n       ARG1 / ARG2  arithmetic quotient of ARG1 divided by ARG2\n       ARG1 % ARG2  arithmetic remainder of ARG1 divided by ARG2\n       STRING : REGEXP  anchored pattern match of REGEXP in STRING\n       match STRING REGEXP     same as STRING : REGEXP\n       substr STRING POS LENGTH  substring of STRING, POS counted from 1\n       index STRING CHARS   index in STRING where any CHARS is found, or 0\n       length STRING   length of STRING\n       + TOKEN\n              interpret TOKEN as a string, even if it is a\n              keyword like 'match' or an operator like '/'\n       ( EXPRESSION )\n              value of EXPRESSION\n---------------------------------------------------------------------------------------\n\n\n\n===============================================\nShell注释\n===============================================\n以“#”开头的行就是注释，会被解释器忽略。\n\n===============================================\nShell字符串\n===============================================\n单引号：str='this is a string'\n    注意：\n    单引号里的任何字符都会原样输出。\n双引号：your_name=\"qinj\"\n    注意：\n        双引号里变量正常输出\n---------------------------------------------------------------------------------------\n字符串切片：${var:offset:number}\n    示例：\n        1：取字符串的子串\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:3}\n            ~]# ./bash.sh\n            ~]# defg\n        2：${var:  -length}：取字符的最右侧的几个字符。\n            ~]# vi bash.sh \n                var='abcdefg'\n                echo ${var: -3}   #注意：冒号后必须有一个空白字符\n            ~]# ./bash.sh\n            ~]# efg\n        3：从左向右截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:2:2}\n            ~]# ./bash.sh\n            ~]# cd\n        4：从右向左截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var: -4:2}\n            ~]# ./bash.sh\n            ~]# de\n---------------------------------------------------------------------------------------\n基于模式取子串：\n    1：${var#*word}：删除字符串开头至此分隔符之间的所有字符。\n            示例：\n                ~]# vi bash.sh\n                    var='abc/de/fg'\n                    echo ${var#*/}\n                ~]# ./bash.sh \n                    de/fg\n\n    2：${var##*word}：删除字符串开头至此分隔符之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var##*/}\n            ~]# ./bash.sh \n                fg\n\n    3：${var%word*}：删除此分隔符至字符串尾部之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var%/*}\n            ~]# ./bash.sh \n                abc/de\n\n    4：${var%%word*}：删除此分隔符至字符串尾部之间的所有字符；\n            示例：\n                ~]# cat bash.sh \n                        var='abc/de/fg'\n                        echo ${var%%/*}\n                ~]# ./bash.sh \n                        abc\n---------------------------------------------------------------------------------------\n查找替换：（PATTERN中使用glob风格和通配符）\n    1：${var/PATTERN/SUBSTI}：查找var所表示的字符串中，第一次被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n            示例：\n                ~]# vi ./bash.sh \n                    var='aaabbbcccaaabbbccc'\n                    echo ${var/bbb/字符串}\n                ~]# ./bash.sh \n                    aaa字符串cccaaabbbccc\n\n    :2：${var//PATTERN/SUBSTI}：查找var所表示的字符串中，所有被PATTERN所匹配到的字符串，并将其全部替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var//bbb/字符串}\n            ~]# ./bash.sh \n                aaa字符串cccaaa字符串ccc\n\n    3：${var/#PATTERN/SUBSTI}：查找var所表示的字符串中，行首被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN/SUBSTI}：查找var所表示的字符串中，行尾被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n查找删除：\n    1：${var/PATTERN}：删除第一次的匹配；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/cc/字符串}\n            ~]# ./bash.sh \n                aaabbb字符串caaabbbccc\n\n    2：${var//PATERN}：删除最后一次匹配\n        示例：\n        ~]# vi bash.sh \n            var='aaabbbcccaaabbbccc'\n            echo ${var//cc/字符串}\n        ~]# ./bash.sh \n            aaabbb字符串caaabbb字符串c\n\n    3：${var/#PATTERN}：删除行首匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN}：删除行尾匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n字符大小写转换：\n    1：${var^^}：所有字符转换为大写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var^^}\n            ~]# ./bash.sh \n                AAABBBCCCAAABBBCCC\n\n    :2：${var,,}：所有字符转换为小写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var,,}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbccc\n---------------------------------------------------------------------------------------\n变量赋值：\n    1：${var:-VALUE}：如果var变量为空，或未设置，那么返回VALUE；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:-string}\n                echo ${ar:-string}\n            ~]# ./bash.sh \n                字符串\n                string\n\n    2：${var:=VALUE}：如果var变量为空，或未设置，那么返回VALUE，并将VALUE赋值给var变量；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:=string}\n                echo ${ar:=string}\n                echo $ar\n            ~]# ./bash.sh \n                字符串\n                string\n                string\n\n    3：${var:+VALUE}：如果var变量不为空，则返回VALUE；\n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:+string}\n            ~]# ./bash.sh \n                string\n\n    4：${var:?ERROR_INFO}：如果var为空，或未设置，那么返回ERROR_INFO为错误提示；否则，返回var值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:?string}\n                echo ${ar:?错误信息}\n            ~]# ./bash.sh \n                字符串\n                ./bash.sh: line 4: ar: 错误信息\n---------------------------------------------------------------------------------------\n拼接字符串\n    示例：\n        ~]# vi bash.sh\n            your_name=\"qinjx\"\n            greeting=\"hello, \"$your_name\" !\"\n            greeting_1=\"hello, ${your_name} !\"\n            echo $greeting $greeting_1\n        ~]# ./bash.sh\n            hello, qinjx ! hello, qinjx !\n---------------------------------------------------------------------------------------\n获取字符串长度：${#string}\n    示例：\n        ~]# vi bash.sh \n            string='abcd'\n            echo ${#string}\n            echo $(expr length $string)\n        ~]# ./bash.sh \n            4\n            4\n===============================================\nShell if else语句\n===============================================\n（1）单分支1\n        if CONDITION ; then\n            分支\n        fi\n（2）单分支2\n        if CONDITION ; then\n            分支1\n        else\n            分支2\n        fi\n（3）多分支1\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        elif CONDITION; then\n                分支n\n        fi\n（4）多分支2\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        else CONDITION; then\n                    分支n\n        fi\n\n语法：then可换行写，condition后面就不用加分号。\n        if CONDITION\n        then\n            分支\n        fi\n===============================================\nShell case esac语句\n===============================================\n（1）语法结构\n        case  $VARAIBLE  in  \n        PAT1)\n            分支1\n            ;;\n        PAT2)\n            分支2\n            ;;\n        ...\n        *)\n            分支n\n            ;;\n        esac\n\n示例：\n    value='c'\n    case $value in\n    a)\n        echo '这是a' # 可以是单引号或者双引号\n        ;;\n    b)\n        if [0 -le 18];then  # 可以是一段代码\n            echo '一个判断'\n        fi\n        ;;\n    c)\n        echo 这是c\n        ;; # 必须以;;为结束\n    *)\n        echo \"未匹配到上面的结果,在此可以执行一段代码或者不写 *) 这一部分\"\n        ;;\n    esac\n    \n    结果：\n        这是c\n===============================================\nShell for循环\n===============================================\n（1）语法结构\n    for 变量 in 列表; do\n        command\n    done\n\n示例：\n    1：详细输出，依次输出1,2,3,4,5 \n        for File in 1 2 3 4 5 \n        do \n            echo $File \n        done\n    2：输出某个目录下所有的文件或者匹配到的文件\n        for file in $HOME/.bash*; do        # 也可以写 $HOME/*\n            echo $file\n        done\n    3：{开始正整数..结束正整数}：注意：中间是两个点\n        for num in {1..5}; do\n            echo $num           # 输出数字 1-5 的正整数\n        done\n    4：((i=1; i<=5; i++ ))：每次循环加1\n        for((i=1; i<=5; i++ )); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    5：执行命令 seq：起始从1开始\n        for i in $(seq 5); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    6：执行命令\n        for i in $(ls /); do\n            echo $i\n        done\n\n语法：do可以换行写，那里就不需要分号了。\n===============================================\nShell while循环\n===============================================\n（1）语法结构\n        while  CONDITION; do\n            代码....\n        done\n\n        注意：\n        进入条件： CONDITION 测试为”真“\n        退出条件： CONDITION 测试为”假“\n\n示例：\n（1）\n    declare -i i=1\n    while [ $i -le 5 ]; do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    while (( $i <= 5 )); do\n        echo $i\n        let i++\n    done\n\n===============================================\nShell until循环\n===============================================\n（1）语法结构\n        until  CONDITION; do\n            循环体\n            循环控制变量修正表达式\n        done\n\n        注意：\n        进入条件：CONDITION测试为”假“\n        退出条件：CONDITION测试为”真“    \n\n示例：\n    declare -i i=1\n    until (( $i > 5 )); do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    until [ $i -gt 5 ]; do\n        echo $i\n        let i++\n    done\n===============================================\nShell跳出循环\n===============================================\n（1）continue：跳过本次循环，执行下一次循环\n（2）break：退出循环\n\n===============================================\nShell函数\n===============================================\n（1）语法一：\n        function  f_name  {\n            ...函数体...\n        }\n            \n（2）语法二：\n        f_name()  {\n            ...函数体...\n        }\n\n执行函数：\n    f_name\n\n    示例：\n        1：    #函数的声明\n                function fname {\n                    echo '我是语法一函数'\n                }\n                # 执行函数\n                fname\n\n        2：   # 函数的声明\n            fname(){\n                echo '我是语法二函数'\n            }\n            # 执行函数\n            fname\n\n参数：\n    （1）$1，$2, ...\n    （2）$#   $@ $*\n        \n        示例：\n                function fname {\n                    echo \"第一个参数：$1\"\n                    echo \"第二个参数：$2\"\n                    # echo \"第N个参数：$n\"\n                    echo \"参数总数：$#\"\n                    echo \"参数字符串: $@\"\n                    echo \"参数字符串: $*\"\n                }\n                #执行函数，并传入参数\n                fname 1 2\n            结果：\n                第一个参数：1\n                第二个参数：2\n                参数总数：2\n                参数字符串: 1 2\n                参数字符串: 1 2\n\nreturn：返回退出状态码，shell不退出\n    示例：\n        function fname {\n            return 1\n        }\n        fname\n        echo $?\n    结果：\n        1\n\nexit：返回状态码并推出\n\n作用域：\n    （1）全局作用域：没有使用 local 关键字；语法：VARIABLE=VALUE\n    （2）局部作用域：函数内部声明并且使用 local 关键字，仅在函数内部有效：语法：local VARIABLE=VALUE\n\n        示例：\n            name=tom    # 全局作用域\n            setname() {\n                local name=jerry        # 局部作用域,仅在函数内部有效。\n                    echo \"局部: $name\"\n            }\n            setname         #执行函数\n            echo \"全局: $name\"\n===============================================\nShell数组\n===============================================\n声明数组：\n        declare  -a  NAME：声明索引数组；\n        declare  -A  NAME：声明关联数组；\n\n数组中元素的赋值方式：\n            (1) 一次只赋值一个元素；\n                ARRAY_NAME[INDEX]=value\n                示例：索引数组\n                    declare -a index_array;\n                    index_array[0]=0\n                    index_array[1]=1\n                    echo ${index_array[0]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name[aa]=aaaa\n                    array_name[bb]=bbbb\n                    echo ${array_name[aa]}\n            (2) 一次赋值全部元素；\n                ARRAY_NAME=(\"VAL1\"  \"VAL2\"  \"VAL3\"  ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=('val0' 'val1' 'val2')\n                    echo ${index_array[0]}\n\n            (3) 只赋值特定元素；\n                ARRAY_NAME=([0]=\"VAL1\"  [3]=\"VAL4\" ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=([0]='val0' [3]='val1' [6]='val2')\n                    echo ${index_array[6]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name=([aa]='aaaa' [bb]='bbbb')\n                    echo ${array_name[aa]}\n\n\n                注意：bash支持稀疏格式的数组；\n\n            (4) read  -a  ARRAY_NAME\n                示例：\n                    read -p \"输入参数: \" -a array_name\n                    echo ${array_name[0]}\n\n\n       （5） 引用数组中的元素：${ARRAY_NAME[INDEX]}\n        注意：引用时，只给数组名，表示引用下标为0的元素；\n\n        （6）数组的长度（数组中元素的个数）:\n            ${#ARRAY_NAME[*]}\n            ${#ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${#array_name[@]}\n                echo ${#array_name[*]}\n                结果：\n                    3\n                    3\n\n        （7）数组的参数（数组中所有的参数）：\n            ${ARRAY_NAME[*]}\n            ${ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${array_name[@]}\n                echo ${array_name[*]}\n            结果：\n                00000 1111 2222\n                00000 1111 2222\n===============================================\nShell输入输出重定向\n===============================================\n推荐：http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html\n\nlinux shell下常用输入输出操作符是：\n1.  标准输入   (stdin) ：代码为 0 ，使用 < 或 << ； /dev/stdin -> /proc/self/fd/0   0代表：/dev/stdin \n2.  标准输出   (stdout)：代码为 1 ，使用 > 或 >> ； /dev/stdout -> /proc/self/fd/1  1代表：/dev/stdout\n3.  标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ； /dev/stderr -> /proc/self/fd/2 2代表：/dev/stderr\n\n输出重定向：\n    1：重定向程序正常执行的结果\n    覆盖重定向：覆盖目标文件中的原有内容；\n        COMMAND >  /PATH/TO/SOMEFILE\n    追加重定向：追加新产生的内容至目标文件尾部；\n        COMMAND >> /PATH/TO/SOMEFILE\n\n    shell的一个功能开关：\n        # set -C\n            禁止覆盖输出重定向至已存在的文件；\n            注意：此时仍然可以使用“>|”至目标文件； \n        # set +C\n            关闭上述特性；\n                        \n错误重定向：\n                重定向错误的执行结果；\n                \n                    COMMAND 2>  /PATH/TO/SOMEFILE\n                        错误输出覆盖重定向；\n                    COMMAND 2>> /PATH/TO/SOMEFILE\n                        错误输出追加重定向；\n                        \n合并标准输出与错误输出流：\n                (1) &>, &>>\n                (2) COMMAND > /PATH/TO/SOMEFILE 2>&1\n                      COMMAND >> /PATH/TO/SOMEFILE 2>&1\n                      \n            特殊输出目标：/dev/null\n                位桶：bit bucket\n            特殊的输入文件：/dev/zero\n\n输入重定向：\n            COMMAND < /PATH/FROM/SOMEFILE\n            COMMAND << ：\n            Here Document\n\n            用法：\n                COMMAND << EOF\n                COMMAND > /PATH/TO/SOMEFILE << EOF\n===============================================\nShell文件包含  . 与 source\n===============================================\n文件包含：. （点） 与 source 都可以引入文件\n注意：\n    1：被引入的文件不需要执行权限\n    2：可以没有 #!/bin/bash\n    3：被引入程序当做一个可执行的脚本运行。\n\n示例：\n~]# vi bash.sh \n    #!/bin/bash\n    # 引入 config.sh 文件\n    . ./config.sh\n    # 引入 cfg 文件\n    source ./cfg\n    echo $string\n    echo $cfg\n~]# vi cfg\n    cfg='cfg文件'\n~]# vi config.sh \n    #!/bin/bash\n    string='config文件'\n~]# ./bash.sh\n    config文件\n    cfg文件\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"shell 基础语法\n===============================================\n推荐：http://c.biancheng.net/cpp/shell/\n===============================================\n第一个Shell脚本\n===============================================\n格式：\n    （1）扩展名为sh（sh代表shell）\n                例如：bash.sh\n    （2）文件头（文件头固定格式）\n                如：#!/bin/bash\n\n作为可执行程序：\n    （1）使脚本具有执行权限\n        ~]# chmod +x ./test.sh\n    （2）执行脚本\n            1：可以不加执行权限\n                ~]$ bash abc.sh     （直接指明文件）\n                ~]$ bash ./abc.sh    （相对路径）\n                ~]$ bash /home/mdx/abc.sh （绝对路径）\n            2：必须加执行权限 （必须是绝对路径或者相对路径）\n                ~]# ./test.sh   （相对路径）\n                ~]$ /home/mdx/test.sh  （绝对路径）\n\n解释器参数（read）：\n        使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：\n        read   [option]  ...  A B\n           -p 'PROMPT'  提示符\n                ~] read -p \"提示符：\"     （接受其传入的参数）\n           -t    TIMEOUT\n\n===============================================\nShell变量\n===============================================\n定义：\n    （1）只能使用字母、数字和下划线；而且不能以数字开头。\n    （2）不能使用标点符号。\n    （3）不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n变量赋值：\n    （1）NAME=VALUE\n            =：赋值符号，两边不能有空格。把VALUE存储到NAME指向的内存空间中\n    （2）declare  命令\n                declare [-aAfFgilrtux] [-p] [name[=value] ...]\n                +:  指定变量的属性\n                -:  取消变量所设的属性\n                -a:  一个使名称索引的数组（如果支持的话）\n                -A:  一个使名称关联数组（如果支持）\n                -i:  “整数”属性\n                -l:  to convert NAMEs to lower case on assignment\n                -r:  名字只读\n                -t:   to make NAMEs have the 'trace' attribute\n                -u:  to convert NAMEs to upper case on assignment\n                -x:   to make NAMEs export\n\n重新赋值变量：\n    （1）NAME=VALUE（再次重新赋值）\n\n变量引用：\n    （1）${NAME}\n    （2）$NAME\n\n只读变量：\n    （1）readonly NAME（变量赋值后定义）\n\n删除变量：\n    （1）unset NAME\n\n变量类型：\n（1) 局部变量\n    局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n（2) 环境变量\n    所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n（3) shell变量\n    shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n===============================================\nShell特殊变量\n===============================================\n（1）$0：当前脚本的文件名\n                ~]# vi test.sh\n                        echo $0\n                ~]# ./test.sh\n                        ./test.sh\n（2）$n：传递给脚本或函数的参数。n 是一个数字，表示第几个参数。\n                ~]# ./test.sh param1 param2 param3 ......\n                ~]# vi test.sh\n                        echo $1 （param1：第1个参数）\n                        echo $2 （param2：第2个参数）\n                        echo $3 （param3：第3个参数）\n                        ......\n（3）$#：传递给脚本或函数的参数个数。\n                ~]# vi test.sh\n                        echo $#\n                ~]# ./test.sh param1 param2 param3 ......\n                        3\n（4）$*：传递给脚本或函数的所有参数。横向显示。\n                ~]# vi test.sh\n                       for var in \"$*\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1 param2 param3 ....\n（5）$@：传递给脚本或函数的所有参数。竖向显示。\n                ~]# vi test.sh\n                       for var in \"$@\"\n                       do\n                           echo \"$var\"\n                       done\n                ~]# ./test.sh param1 param2 param3 ......\n                        param1\n                        param2\n                        param3\n                        ...\n（6）$?：上个命令的执行状态，或函数的返回值。\n                成功：0\n                失败：1-255\n（7）$$：当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。\n                ~]# vi test.sh\n                       echo $$\n                ~]# ./test.sh \n                        14781\n\n===============================================\nShell替换\n===============================================\n转义字符：\n    （1）\\\\  反斜杠\n    （2） \\a  警报，响铃\n    （3） \\b  退格（删除键）\n    （4） \\f  换页(FF)，将当前位置移到下页开头\n    （5） \\n  换行\n    （6） \\r  回车\n    （7） \\t  水平制表符（tab键）\n    （8） \\v  垂直制表符\n\n命令替换：\n    （1）：`command` 反引号\n    （2）：$(command)\n\n变量替换：\n    （1）${var}  变量本来的值\n    （2）${var:-word}    如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。\n    （3）${var:=word}    如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。\n    （4）${var:?message} 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。\n    （5）${var:+word}    如果变量 var 被定义，那么返回 word，但不改变 var 的值。\n\n===============================================\nShell运算符\n===============================================\n 条件测试：\n    （1） test  EXPRESSION \n    （2）[ EXPRESSION ]\n    （3）[[ EXPRESSION ]]                       \n\n算术运算符\n    （1）+：加法\n    （2）-：减法\n    （3）*：乘法\n    （4）/：除法\n    （5）%：取余\n    （6）=：赋值\n    （7）==：相等\n    （8）!=：不相等\n\n    计算方式：\n        （1）expr\n                expr $a + $b\n                $(expr $a + $b)\n                `expr $a + $b`   （注意：这是反引号）\n                注意：符号号两边有空格\n        （2）$[$a+$b]\n        （3）let\n                let \"c = $a + $b\"  或者  let \"c=$a+$b\"  （注意：这是双引号）\n                let c=$a+$b （ 注意：符号号两边没有空格）\n        （4）$((expression))\n                c=$(( $a + $b ))\n                备注：空格可有可无\n\n数字运算符：\n    （1）-eq   是否等于  \n    （2）-ne   是否不等于\n    （3）-gt   是否大于\n    （4）-lt   小于    \n    （5）-ge  大于等于\n    （6）-le   是否小于等于 \n\n布尔运算符：\n        （1）-not  非运算。\n        （2）-o  或运算。\n        （3）-a  与运算。\n        （4）! 非运算。\n        （5）&& 与运算。\n        （6）||  或运算。\n\n字符串运算符：\n    （1）=  相等。\n    （2）!= 不相等。\n    （3）-z   判断字符串是否为空\n    （4）-n   判断字符串是否不为空\n    （5）str： 检测字符串是否为空。\n\n文件测试运算符：\n        -b file： 检测文件是否是块设备文件，\n        -c file： 检测文件是否是字符设备文件，\n        -d file： 检测文件是否是目录，\n        -f file： 检测文件是否是普通文件（既不是目录，也不是设备文件），\n        -g file： 检测文件是否设置了 SGID 位，\n        -k file： 检测文件是否设置了粘着位(Sticky Bit)，\n        -p file： 检测文件是否是具名管道，\n        -u file： 检测文件是否设置了 SUID 位，\n        -r file： 检测文件是否可读，\n        -w file： 检测文件是否可写，\n        -x file： 检测文件是否可执行，\n        -s file： 检测文件是否为空（文件大小是否大于0），不为空返回 true。\n        -a file： 检测文件（包括目录）是否存在，（-a 等同于 -e）\n        -e file： 检测文件（包括目录）是否存在，\n        -N  file   文件自从上一次读操作之后，是否被改过 \n        -O  file 当前用户是否为文件的属主\n        -G  file  当前用户是否为文件的属组\n\n      双目测试\n        FILE1 -ef FILE2  是否指向同一个文件系统的相同inode的硬链接\n        FILE1  -nt FILE2  FILE1文件，是否新于FILE2\n        FILE1 -ot  FILE2  FILE1文件，是否旧于FILE2\n\n其他运算符：\n    ?: 三元运算符\n    =~  左侧字符串是否能够被右侧的PATTERN所匹配 （说人话  包含）\n\n---------------------------------------------------------------------------------------\nlet 与 expr 语法详解\n---------------------------------------------------------------------------------------\nlet：评估算术表达式\n        id++, id--  variable post-increment, post-decrement\n        ++id, --id  variable pre-increment, pre-decrement\n        -, +        unary minus, plus\n        !, ~        logical and bitwise negation\n        **      exponentiation\n        *, /, %     multiplication, division, remainder\n        +, -        addition, subtraction\n        <<, >>      left and right bitwise shifts\n        <=, >=, <, >    comparison\n        ==, !=      equality, inequality\n        &       bitwise AND\n        ^       bitwise XOR\n        |       bitwise OR\n        &&      logical AND\n        ||      logical OR\n        expr ? expr : expr\n                conditional operator\n        =, *=, /=, %=,\n        +=, -=, <<=, >>=,\n        &=, ^=, |=  assignment\n---------------------------------------------------------------------------------------\nexpr：评价表达式 \n       ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n       ARG1 & ARG2  ARG1 if neither argument is null or 0, otherwise 0\n       ARG1 < ARG2    ARG1 is less than ARG2\n       ARG1 <= ARG2  ARG1 is less than or equal to ARG2\n       ARG1 = ARG2   ARG1 is equal to ARG2\n       ARG1 != ARG2   ARG1 is unequal to ARG2\n       ARG1 >= ARG2  ARG1 is greater than or equal to ARG2\n       ARG1 > ARG2  ARG1 is greater than ARG2\n       ARG1 + ARG2  arithmetic sum of ARG1 and ARG2\n       ARG1 - ARG2  arithmetic difference of ARG1 and ARG2\n       ARG1 * ARG2  arithmetic product of ARG1 and ARG2\n       ARG1 / ARG2  arithmetic quotient of ARG1 divided by ARG2\n       ARG1 % ARG2  arithmetic remainder of ARG1 divided by ARG2\n       STRING : REGEXP  anchored pattern match of REGEXP in STRING\n       match STRING REGEXP     same as STRING : REGEXP\n       substr STRING POS LENGTH  substring of STRING, POS counted from 1\n       index STRING CHARS   index in STRING where any CHARS is found, or 0\n       length STRING   length of STRING\n       + TOKEN\n              interpret TOKEN as a string, even if it is a\n              keyword like 'match' or an operator like '/'\n       ( EXPRESSION )\n              value of EXPRESSION\n---------------------------------------------------------------------------------------\n\n\n\n===============================================\nShell注释\n===============================================\n以“#”开头的行就是注释，会被解释器忽略。\n\n===============================================\nShell字符串\n===============================================\n单引号：str='this is a string'\n    注意：\n    单引号里的任何字符都会原样输出。\n双引号：your_name=\"qinj\"\n    注意：\n        双引号里变量正常输出\n---------------------------------------------------------------------------------------\n字符串切片：${var:offset:number}\n    示例：\n        1：取字符串的子串\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:3}\n            ~]# ./bash.sh\n            ~]# defg\n        2：${var:  -length}：取字符的最右侧的几个字符。\n            ~]# vi bash.sh \n                var='abcdefg'\n                echo ${var: -3}   #注意：冒号后必须有一个空白字符\n            ~]# ./bash.sh\n            ~]# efg\n        3：从左向右截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var:2:2}\n            ~]# ./bash.sh\n            ~]# cd\n        4：从右向左截取某字符后几位\n            ~]# vi bash.sh\n                var='abcdefg'\n                echo ${var: -4:2}\n            ~]# ./bash.sh\n            ~]# de\n---------------------------------------------------------------------------------------\n基于模式取子串：\n    1：${var#*word}：删除字符串开头至此分隔符之间的所有字符。\n            示例：\n                ~]# vi bash.sh\n                    var='abc/de/fg'\n                    echo ${var#*/}\n                ~]# ./bash.sh \n                    de/fg\n\n    2：${var##*word}：删除字符串开头至此分隔符之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var##*/}\n            ~]# ./bash.sh \n                fg\n\n    3：${var%word*}：删除此分隔符至字符串尾部之间的所有字符；\n        示例：\n            ~]# vi bash.sh \n                var='abc/de/fg'\n                echo ${var%/*}\n            ~]# ./bash.sh \n                abc/de\n\n    4：${var%%word*}：删除此分隔符至字符串尾部之间的所有字符；\n            示例：\n                ~]# cat bash.sh \n                        var='abc/de/fg'\n                        echo ${var%%/*}\n                ~]# ./bash.sh \n                        abc\n---------------------------------------------------------------------------------------\n查找替换：（PATTERN中使用glob风格和通配符）\n    1：${var/PATTERN/SUBSTI}：查找var所表示的字符串中，第一次被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n            示例：\n                ~]# vi ./bash.sh \n                    var='aaabbbcccaaabbbccc'\n                    echo ${var/bbb/字符串}\n                ~]# ./bash.sh \n                    aaa字符串cccaaabbbccc\n\n    :2：${var//PATTERN/SUBSTI}：查找var所表示的字符串中，所有被PATTERN所匹配到的字符串，并将其全部替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var//bbb/字符串}\n            ~]# ./bash.sh \n                aaa字符串cccaaa字符串ccc\n\n    3：${var/#PATTERN/SUBSTI}：查找var所表示的字符串中，行首被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN/SUBSTI}：查找var所表示的字符串中，行尾被PATTERN所匹配到的字符串，将其替换为SUBSTI所表示的字符串；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n查找删除：\n    1：${var/PATTERN}：删除第一次的匹配；\n        示例：\n            ~]# vi bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/cc/字符串}\n            ~]# ./bash.sh \n                aaabbb字符串caaabbbccc\n\n    2：${var//PATERN}：删除最后一次匹配\n        示例：\n        ~]# vi bash.sh \n            var='aaabbbcccaaabbbccc'\n            echo ${var//cc/字符串}\n        ~]# ./bash.sh \n            aaabbb字符串caaabbb字符串c\n\n    3：${var/#PATTERN}：删除行首匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/#aa/字符串}\n            ~]# ./bash.sh \n                字符串abbbcccaaabbbccc\n\n    4：${var/%PATTERN}：删除行尾匹配\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccaaabbbccc'\n                echo ${var/%cc/字符串}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbc字符串\n---------------------------------------------------------------------------------------\n字符大小写转换：\n    1：${var^^}：所有字符转换为大写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var^^}\n            ~]# ./bash.sh \n                AAABBBCCCAAABBBCCC\n\n    :2：${var,,}：所有字符转换为小写；\n        示例：\n            ~]# cat bash.sh \n                var='aaabbbcccAAABBBCCC'\n                echo ${var,,}\n            ~]# ./bash.sh \n                aaabbbcccaaabbbccc\n---------------------------------------------------------------------------------------\n变量赋值：\n    1：${var:-VALUE}：如果var变量为空，或未设置，那么返回VALUE；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:-string}\n                echo ${ar:-string}\n            ~]# ./bash.sh \n                字符串\n                string\n\n    2：${var:=VALUE}：如果var变量为空，或未设置，那么返回VALUE，并将VALUE赋值给var变量；否则，则返回var变量的值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:=string}\n                echo ${ar:=string}\n                echo $ar\n            ~]# ./bash.sh \n                字符串\n                string\n                string\n\n    3：${var:+VALUE}：如果var变量不为空，则返回VALUE；\n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:+string}\n            ~]# ./bash.sh \n                string\n\n    4：${var:?ERROR_INFO}：如果var为空，或未设置，那么返回ERROR_INFO为错误提示；否则，返回var值； \n        示例：\n            ~]# cat bash.sh \n                var='字符串'\n                echo ${var:?string}\n                echo ${ar:?错误信息}\n            ~]# ./bash.sh \n                字符串\n                ./bash.sh: line 4: ar: 错误信息\n---------------------------------------------------------------------------------------\n拼接字符串\n    示例：\n        ~]# vi bash.sh\n            your_name=\"qinjx\"\n            greeting=\"hello, \"$your_name\" !\"\n            greeting_1=\"hello, ${your_name} !\"\n            echo $greeting $greeting_1\n        ~]# ./bash.sh\n            hello, qinjx ! hello, qinjx !\n---------------------------------------------------------------------------------------\n获取字符串长度：${#string}\n    示例：\n        ~]# vi bash.sh \n            string='abcd'\n            echo ${#string}\n            echo $(expr length $string)\n        ~]# ./bash.sh \n            4\n            4\n===============================================\nShell if else语句\n===============================================\n（1）单分支1\n        if CONDITION ; then\n            分支\n        fi\n（2）单分支2\n        if CONDITION ; then\n            分支1\n        else\n            分支2\n        fi\n（3）多分支1\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        elif CONDITION; then\n                分支n\n        fi\n（4）多分支2\n        if CONDITION1; then\n                分支1\n        elif  CONDITION2; then\n                分支2\n                ...\n        else CONDITION; then\n                    分支n\n        fi\n\n语法：then可换行写，condition后面就不用加分号。\n        if CONDITION\n        then\n            分支\n        fi\n===============================================\nShell case esac语句\n===============================================\n（1）语法结构\n        case  $VARAIBLE  in  \n        PAT1)\n            分支1\n            ;;\n        PAT2)\n            分支2\n            ;;\n        ...\n        *)\n            分支n\n            ;;\n        esac\n\n示例：\n    value='c'\n    case $value in\n    a)\n        echo '这是a' # 可以是单引号或者双引号\n        ;;\n    b)\n        if [0 -le 18];then  # 可以是一段代码\n            echo '一个判断'\n        fi\n        ;;\n    c)\n        echo 这是c\n        ;; # 必须以;;为结束\n    *)\n        echo \"未匹配到上面的结果,在此可以执行一段代码或者不写 *) 这一部分\"\n        ;;\n    esac\n    \n    结果：\n        这是c\n===============================================\nShell for循环\n===============================================\n（1）语法结构\n    for 变量 in 列表; do\n        command\n    done\n\n示例：\n    1：详细输出，依次输出1,2,3,4,5 \n        for File in 1 2 3 4 5 \n        do \n            echo $File \n        done\n    2：输出某个目录下所有的文件或者匹配到的文件\n        for file in $HOME/.bash*; do        # 也可以写 $HOME/*\n            echo $file\n        done\n    3：{开始正整数..结束正整数}：注意：中间是两个点\n        for num in {1..5}; do\n            echo $num           # 输出数字 1-5 的正整数\n        done\n    4：((i=1; i<=5; i++ ))：每次循环加1\n        for((i=1; i<=5; i++ )); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    5：执行命令 seq：起始从1开始\n        for i in $(seq 5); do\n            echo $i          # 输出数字 1-5 的正整数\n        done\n    6：执行命令\n        for i in $(ls /); do\n            echo $i\n        done\n\n语法：do可以换行写，那里就不需要分号了。\n===============================================\nShell while循环\n===============================================\n（1）语法结构\n        while  CONDITION; do\n            代码....\n        done\n\n        注意：\n        进入条件： CONDITION 测试为”真“\n        退出条件： CONDITION 测试为”假“\n\n示例：\n（1）\n    declare -i i=1\n    while [ $i -le 5 ]; do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    while (( $i <= 5 )); do\n        echo $i\n        let i++\n    done\n\n===============================================\nShell until循环\n===============================================\n（1）语法结构\n        until  CONDITION; do\n            循环体\n            循环控制变量修正表达式\n        done\n\n        注意：\n        进入条件：CONDITION测试为”假“\n        退出条件：CONDITION测试为”真“    \n\n示例：\n    declare -i i=1\n    until (( $i > 5 )); do\n        echo $i\n        let i++\n    done\n    或者\n    declare -i i=1\n    until [ $i -gt 5 ]; do\n        echo $i\n        let i++\n    done\n===============================================\nShell跳出循环\n===============================================\n（1）continue：跳过本次循环，执行下一次循环\n（2）break：退出循环\n\n===============================================\nShell函数\n===============================================\n（1）语法一：\n        function  f_name  {\n            ...函数体...\n        }\n            \n（2）语法二：\n        f_name()  {\n            ...函数体...\n        }\n\n执行函数：\n    f_name\n\n    示例：\n        1：    #函数的声明\n                function fname {\n                    echo '我是语法一函数'\n                }\n                # 执行函数\n                fname\n\n        2：   # 函数的声明\n            fname(){\n                echo '我是语法二函数'\n            }\n            # 执行函数\n            fname\n\n参数：\n    （1）$1，$2, ...\n    （2）$#   $@ $*\n        \n        示例：\n                function fname {\n                    echo \"第一个参数：$1\"\n                    echo \"第二个参数：$2\"\n                    # echo \"第N个参数：$n\"\n                    echo \"参数总数：$#\"\n                    echo \"参数字符串: $@\"\n                    echo \"参数字符串: $*\"\n                }\n                #执行函数，并传入参数\n                fname 1 2\n            结果：\n                第一个参数：1\n                第二个参数：2\n                参数总数：2\n                参数字符串: 1 2\n                参数字符串: 1 2\n\nreturn：返回退出状态码，shell不退出\n    示例：\n        function fname {\n            return 1\n        }\n        fname\n        echo $?\n    结果：\n        1\n\nexit：返回状态码并推出\n\n作用域：\n    （1）全局作用域：没有使用 local 关键字；语法：VARIABLE=VALUE\n    （2）局部作用域：函数内部声明并且使用 local 关键字，仅在函数内部有效：语法：local VARIABLE=VALUE\n\n        示例：\n            name=tom    # 全局作用域\n            setname() {\n                local name=jerry        # 局部作用域,仅在函数内部有效。\n                    echo \"局部: $name\"\n            }\n            setname         #执行函数\n            echo \"全局: $name\"\n===============================================\nShell数组\n===============================================\n声明数组：\n        declare  -a  NAME：声明索引数组；\n        declare  -A  NAME：声明关联数组；\n\n数组中元素的赋值方式：\n            (1) 一次只赋值一个元素；\n                ARRAY_NAME[INDEX]=value\n                示例：索引数组\n                    declare -a index_array;\n                    index_array[0]=0\n                    index_array[1]=1\n                    echo ${index_array[0]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name[aa]=aaaa\n                    array_name[bb]=bbbb\n                    echo ${array_name[aa]}\n            (2) 一次赋值全部元素；\n                ARRAY_NAME=(\"VAL1\"  \"VAL2\"  \"VAL3\"  ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=('val0' 'val1' 'val2')\n                    echo ${index_array[0]}\n\n            (3) 只赋值特定元素；\n                ARRAY_NAME=([0]=\"VAL1\"  [3]=\"VAL4\" ...)\n                示例：索引数组\n                    declare -a index_array;\n                    index_array=([0]='val0' [3]='val1' [6]='val2')\n                    echo ${index_array[6]}\n                示例：关联数组\n                    declare -A array_name\n                    array_name=([aa]='aaaa' [bb]='bbbb')\n                    echo ${array_name[aa]}\n\n\n                注意：bash支持稀疏格式的数组；\n\n            (4) read  -a  ARRAY_NAME\n                示例：\n                    read -p \"输入参数: \" -a array_name\n                    echo ${array_name[0]}\n\n\n       （5） 引用数组中的元素：${ARRAY_NAME[INDEX]}\n        注意：引用时，只给数组名，表示引用下标为0的元素；\n\n        （6）数组的长度（数组中元素的个数）:\n            ${#ARRAY_NAME[*]}\n            ${#ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${#array_name[@]}\n                echo ${#array_name[*]}\n                结果：\n                    3\n                    3\n\n        （7）数组的参数（数组中所有的参数）：\n            ${ARRAY_NAME[*]}\n            ${ARRAY_NAME[@]}\n            示例：\n                declare -a array_name\n                array_name[0]=00000\n                array_name[1]=1111\n                array_name[2]=2222\n                echo ${array_name[@]}\n                echo ${array_name[*]}\n            结果：\n                00000 1111 2222\n                00000 1111 2222\n===============================================\nShell输入输出重定向\n===============================================\n推荐：http://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html\n\nlinux shell下常用输入输出操作符是：\n1.  标准输入   (stdin) ：代码为 0 ，使用 < 或 << ； /dev/stdin -> /proc/self/fd/0   0代表：/dev/stdin \n2.  标准输出   (stdout)：代码为 1 ，使用 > 或 >> ； /dev/stdout -> /proc/self/fd/1  1代表：/dev/stdout\n3.  标准错误输出(stderr)：代码为 2 ，使用 2> 或 2>> ； /dev/stderr -> /proc/self/fd/2 2代表：/dev/stderr\n\n输出重定向：\n    1：重定向程序正常执行的结果\n    覆盖重定向：覆盖目标文件中的原有内容；\n        COMMAND >  /PATH/TO/SOMEFILE\n    追加重定向：追加新产生的内容至目标文件尾部；\n        COMMAND >> /PATH/TO/SOMEFILE\n\n    shell的一个功能开关：\n        # set -C\n            禁止覆盖输出重定向至已存在的文件；\n            注意：此时仍然可以使用“>|”至目标文件； \n        # set +C\n            关闭上述特性；\n                        \n错误重定向：\n                重定向错误的执行结果；\n                \n                    COMMAND 2>  /PATH/TO/SOMEFILE\n                        错误输出覆盖重定向；\n                    COMMAND 2>> /PATH/TO/SOMEFILE\n                        错误输出追加重定向；\n                        \n合并标准输出与错误输出流：\n                (1) &>, &>>\n                (2) COMMAND > /PATH/TO/SOMEFILE 2>&1\n                      COMMAND >> /PATH/TO/SOMEFILE 2>&1\n                      \n            特殊输出目标：/dev/null\n                位桶：bit bucket\n            特殊的输入文件：/dev/zero\n\n输入重定向：\n            COMMAND < /PATH/FROM/SOMEFILE\n            COMMAND << ：\n            Here Document\n\n            用法：\n                COMMAND << EOF\n                COMMAND > /PATH/TO/SOMEFILE << EOF\n===============================================\nShell文件包含  . 与 source\n===============================================\n文件包含：. （点） 与 source 都可以引入文件\n注意：\n    1：被引入的文件不需要执行权限\n    2：可以没有 #!/bin/bash\n    3：被引入程序当做一个可执行的脚本运行。\n\n示例：\n~]# vi bash.sh \n    #!/bin/bash\n    # 引入 config.sh 文件\n    . ./config.sh\n    # 引入 cfg 文件\n    source ./cfg\n    echo $string\n    echo $cfg\n~]# vi cfg\n    cfg='cfg文件'\n~]# vi config.sh \n    #!/bin/bash\n    string='config文件'\n~]# ./bash.sh\n    config文件\n    cfg文件\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:blog:linux:shell.md","_source":"content","_file":"blog/linux/shell.md","_extension":"md"},{"_path":"/blog/otopi/analyze","_dir":"otopi","_draft":false,"_partial":false,"_locale":"","title":"otopi源码分析","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"otopi源码分析"},"children":[{"type":"text","value":"otopi源码分析"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文以otopi源码的文档和参考资料"},{"type":"element","tag":"a","props":{"href":"https://resources.ovirt.org/old-site-files/wiki/Ovirt-host-deploy_3.2.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"Ovirt-host-deloy_3.2.pdf"}]},{"type":"text","value":"为输入，用自己的语言来组织下对otopi的理解和使用。"}]},{"type":"element","tag":"h2","props":{"id":"otopi"},"children":[{"type":"text","value":"otopi"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"全名 oVirt Task Oriented Pluggable Installer/Implementation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于独立插件的安装框架，可以用来设置系统环境。使用插件的性质尽可能的简化安装新功能的难度，摆脱状态和事务管理的复杂性。"}]},{"type":"element","tag":"pre","props":{"code":"// fixme  状态和事务管理的复杂性在哪里？为什么插件管理简单？\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// fixme  状态和事务管理的复杂性在哪里？为什么插件管理简单？\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具有如下特点"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"模块化、面向任务的库实现"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支持可插拔管理器的对话框协议，用于人机对话"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"本地化支持"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"支持本地和远程模式执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"分布式独立实现"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"兼容python 2.6 2.7 3.2"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"// fixme 这6点分别对应的是哪些代码?"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"留些问题，回头来看。"}]},{"type":"element","tag":"h3","props":{"id":"安装顺序"},"children":[{"type":"text","value":"安装顺序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"开放把提供的插件放到插件组中，每个插件需要使用@plugin.event来注册，需要提供阶段和优先级信息，每个插件可以提供用于检查条件的回调。状态管理是通过k/v的Environment来实现。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"install_sequence","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_installation_sequence.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Environment中的k/v值有三个来源，默认值、初始化之、通过Config文件覆盖的值。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在plugin.py文件中定义了18个阶段，他们的进入顺序如图中箭头所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个阶段定义了7个默认的优先级，数字越小优先级越高，最后执行插件方法排序的依据是优先级数字的大小，所以每个插件在传入PRIORITY_X的时候可以做+/-运算来调整执行顺序。"}]},{"type":"element","tag":"h3","props":{"id":"插件组"},"children":[{"type":"text","value":"插件组"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有插件都由插件组来划分，可以通过ENVIRONMENT来传递给otopi，接下来Otopi会去加载${group_name}下的插件。"}]},{"type":"element","tag":"pre","props":{"code":"APPEND:BASE/pluginGroups=str:${group_name}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"APPEND:BASE/pluginGroups=str:${group_name}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文件结构如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/ovirt_engine_packages_setup_plugins_list.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如其中ovirt-engine-common就是plugin groups，core文件夹下面的_ _ init__.py文件里面定义了core目录中包含了多少plugin. 如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/ovirt_engine_packages_setup_plugins_plugin_createPlugins.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义了5个plugin"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"firewall_manager"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"firewall_ mamager_firewalld"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"firewall_ manager_human"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"firewall_ manager_iptables"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"hostname"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有Plugin都继承自PluginBase并使用@Plugin.event注解来声明该插件所在的流程位置，python模块可以使用createPlugins方法来加载插件。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是一个示例，假设写了plugin example1 在group1里面"}]},{"type":"element","tag":"pre","props":{"code":"//__init__.py\nfrom otopi import util\n\nfrom . import example1\n\n@util.export\ndef createPlugins(context):\n    example1.Plugin(context=context)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//__init__.py\nfrom otopi import util\n\nfrom . import example1\n\n@util.export\ndef createPlugins(context):\n    example1.Plugin(context=context)\n"}]}]},{"type":"element","tag":"pre","props":{"code":"//example1.py\nimport platform\nimport gettext\n_ = lambda m: gettext.dgettext(message=m, domain='otopi')\n\n\nfrom otopi import constants\nfrom otopi import util\nfrom otopi import plugin\nfrom otopi import filetransaction\n\n\n@util.export\nclass Plugin(plugin.PluginBase):\n\n    def __init__(self, context):\n        super(Plugin, self).__init__(context=context)\n\n    #\n    # 使用默认的优先级注册到STAGE_INIT阶段\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_INIT,\n    )\n    def _init(self):\n\n        #\n        # 使用默认值来保持现存的ENVIRONMENT\n        #\n        self.environment.setdefault('var1', False)\n\n    #\n    # 执行验证，修改的最后机会\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_VALIDATION,\n        priority=plugin.Stages.PRIORITY_LOW,\n    )\n    def _validate(self):\n        if not self._distribution in ('redhat', 'fedora'):\n            raise RuntimeError(\n                _('Unsupported distribution for iptables plugin')\n            )\n\n    #\n    # 执行插件的对应工作.\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_MISC,\n        condition=lambda self: self.environment['var1'],\n    )\n    def _store_iptables(self):\n            self.environment[constants.CoreEnv.TRANSACTION].append(\n                filetransaction.FileTransaction(\n                    name='/etc/example1.conf',\n                    content=(\n                        'hello',\n                        'world',\n                    )\n                )\n            )\n\n@util.export\ndef createPlugins(context):\n    Plugin(context=context)\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//example1.py\nimport platform\nimport gettext\n_ = lambda m: gettext.dgettext(message=m, domain='otopi')\n\n\nfrom otopi import constants\nfrom otopi import util\nfrom otopi import plugin\nfrom otopi import filetransaction\n\n\n@util.export\nclass Plugin(plugin.PluginBase):\n\n    def __init__(self, context):\n        super(Plugin, self).__init__(context=context)\n\n    #\n    # 使用默认的优先级注册到STAGE_INIT阶段\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_INIT,\n    )\n    def _init(self):\n\n        #\n        # 使用默认值来保持现存的ENVIRONMENT\n        #\n        self.environment.setdefault('var1', False)\n\n    #\n    # 执行验证，修改的最后机会\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_VALIDATION,\n        priority=plugin.Stages.PRIORITY_LOW,\n    )\n    def _validate(self):\n        if not self._distribution in ('redhat', 'fedora'):\n            raise RuntimeError(\n                _('Unsupported distribution for iptables plugin')\n            )\n\n    #\n    # 执行插件的对应工作.\n    #\n    @plugin.event(\n        stage=plugin.Stages.STAGE_MISC,\n        condition=lambda self: self.environment['var1'],\n    )\n    def _store_iptables(self):\n            self.environment[constants.CoreEnv.TRANSACTION].append(\n                filetransaction.FileTransaction(\n                    name='/etc/example1.conf',\n                    content=(\n                        'hello',\n                        'world',\n                    )\n                )\n            )\n\n@util.export\ndef createPlugins(context):\n    Plugin(context=context)\n\n"}]}]},{"type":"element","tag":"h3","props":{"id":"环境"},"children":[{"type":"text","value":"环境"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"环境包含两个部分 系统变量和安装环境变量"}]},{"type":"element","tag":"h4","props":{"id":"系统变量"},"children":[{"type":"text","value":"系统变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以用来覆盖安装环境变量，一般用来调试。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选取几个变量"}]},{"type":"element","tag":"pre","props":{"code":"    OTOPI_CONFIG\n        配置文件\n        覆盖了 安装环境的CORE/configFileName.\n\n    OTOPI_DEBUG\n        是否开启调试特性，0表示关闭\n        覆盖了 安装环境的BASE/debug.\n    \n    OTOPI_LOGDIR\n        日志目录\n        覆盖了安装环境的CORE/logDir.\n    \n    OTOPI_LOGFILE\n        指定了日志文件\n        覆盖了安装环境的CORE/logFileName.\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    OTOPI_CONFIG\n        配置文件\n        覆盖了 安装环境的CORE/configFileName.\n\n    OTOPI_DEBUG\n        是否开启调试特性，0表示关闭\n        覆盖了 安装环境的BASE/debug.\n    \n    OTOPI_LOGDIR\n        日志目录\n        覆盖了安装环境的CORE/logDir.\n    \n    OTOPI_LOGFILE\n        指定了日志文件\n        覆盖了安装环境的CORE/logFileName.\n"}]}]},{"type":"element","tag":"h4","props":{"id":"安装环境变量"},"children":[{"type":"text","value":"安装环境变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在constants.py中定义了所有的插件变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"otopi_installer_environment_constants_py_variables","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_installer_environment_constants_py_variables.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中两个注解的意思是"}]},{"type":"element","tag":"pre","props":{"code":"@util.export    //导出该类\n@util.codegen   //将下面变量定义成class的可访问属性\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@util.export    //导出该类\n@util.codegen   //将下面变量定义成class的可访问属性\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上图中定义的变量都可以通过import的方式被plugin访问引用，从而影响plugin的行为，而且更进一步让ovirt-engine通过otopi提供的MachineDialogParser类来与变量交互。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"netenv_ssh","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_ovirt_engine_set_NetEnv_SSH_USER.png?raw=ture"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考几个关键的Environment"}]},{"type":"element","tag":"pre","props":{"code":"\n    BASE/pluginGroups(str)\n        通过 \":\"来切分的插件组\n    CORE/configFileName(str) [/etc/otopi.conf]\n        默认路径是/etc/otopi.conf的配置文件\n    NETWORK/sshEnable(bool) [False]\n        是否存储ssh的密钥，默认不存。\n    NETWORK/iptablesRules(multi-str)\n        iptables的过滤规则，多条str\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n    BASE/pluginGroups(str)\n        通过 \":\"来切分的插件组\n    CORE/configFileName(str) [/etc/otopi.conf]\n        默认路径是/etc/otopi.conf的配置文件\n    NETWORK/sshEnable(bool) [False]\n        是否存储ssh的密钥，默认不存。\n    NETWORK/iptablesRules(multi-str)\n        iptables的过滤规则，多条str\n"}]}]},{"type":"element","tag":"h3","props":{"id":"对话框"},"children":[{"type":"text","value":"对话框"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"dialog是plugins用来和外部交互的接口。交互的对象包括Human和Machine类。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我的理解是："}]},{"type":"element","tag":"pre","props":{"code":"human的交互模式就是 command line interactive mode\n\nmachine的交互模式就是answer file mode\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"human的交互模式就是 command line interactive mode\n\nmachine的交互模式就是answer file mode\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"支持的交互包括"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"terminate"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"note"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"queries\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"string"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"multi-string"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"value"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"display\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"multi-string"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"value"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"confirm"}]}]},{"type":"element","tag":"h4","props":{"id":"定制和结束对话框"},"children":[{"type":"text","value":"定制和结束对话框"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在启动otopi之前传入DIALOG/customization=bool:Ture，可以开启comman 交互模式，这个模式下会有一些简单的命令可以使用，如下"}]},{"type":"element","tag":"pre","props":{"code":"abort - Abort process\nenv-get - Get environment variable\nenv-query - Query environment variable\nenv-query-multi - Get multi string environment variable\nenv-set - Set environment variable\nenv-show - Display environment\nexception-show - show exception information\nhelp - Display available commands\ninstall - Install software\nlog - Retrieve log file\nnoop - No operation\nquit - Quit\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"abort - Abort process\nenv-get - Get environment variable\nenv-query - Query environment variable\nenv-query-multi - Get multi string environment variable\nenv-set - Set environment variable\nenv-show - Display environment\nexception-show - show exception information\nhelp - Display available commands\ninstall - Install software\nlog - Retrieve log file\nnoop - No operation\nquit - Quit\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过这些命令来操作environment，一般在每个stages的定制和结束前可以执行。效果如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"otopi_dialog_customization","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_dialog_customization_true.png?raw=true"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"bundle"},"children":[{"type":"text","value":"bundle"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"略"}]},{"type":"element","tag":"h2","props":{"id":"源码分析"},"children":[{"type":"text","value":"源码分析"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"otopi属于Ovirt下的一个子项目，开发仓库"},{"type":"element","tag":"a","props":{"href":"https://gerrit.ovirt.org/","rel":["nofollow"]},"children":[{"type":"text","value":"gerrit"}]}]},{"type":"element","tag":"pre","props":{"code":"    git clone https://gerrit.ovirt.org/otopi\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    git clone https://gerrit.ovirt.org/otopi\n"}]}]},{"type":"element","tag":"h3","props":{"id":"安装"},"children":[{"type":"text","value":"安装"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"项目文档中提供了INSTALL"}]},{"type":"element","tag":"pre","props":{"code":"    autoreconf -ivf\n    ./configure\n    make\n    make install\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    autoreconf -ivf\n    ./configure\n    make\n    make install\n"}]}]},{"type":"element","tag":"h3","props":{"id":"目录"},"children":[{"type":"text","value":"目录"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"核心的内容在一下四个目录"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"src/bin   otopi命令入口脚本"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"src/java  otopi提供给外部Java程序和Environment交互的工具jar包的源码"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"src/otopi otopi架构的核心代码"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"src/plugins/otopi otopi内置的插件，外部在使用otopi来实现安装过程中会默认加载这些插件"}]}]},{"type":"element","tag":"h4","props":{"id":"binotopi"},"children":[{"type":"text","value":"bin/otopi"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这个脚本在完成必要的 环境检查（bundle\\root\\ptyon-version)之后进入otopi._ _ main__中"}]},{"type":"element","tag":"h4","props":{"id":"srcotopi"},"children":[{"type":"text","value":"src/otopi"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"梳理下otopi运行的核心代码的流程如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"otopi_code_process_flow","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_core_code_process_flow.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以简单分成两部分："}]},{"type":"element","tag":"pre","props":{"code":"\n    installer =main.Otopi() //开始进行初始化工作。\n    \n    installer.execute() //根据传入的参数开始执行对应的业务。\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n    installer =main.Otopi() //开始进行初始化工作。\n    \n    installer.execute() //根据传入的参数开始执行对应的业务。\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"初始化部"}]},{"type":"text","value":"分可以看到，otopi主要包含了4个对象:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dialog\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"humam"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"machineDialog"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Services\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"rhel"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"openrc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"systemd"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Packager\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"dnfpackager"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"yumpackager"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Command"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了command外其他都属于虚类，具体实现由子项中的子类来实现。在otopi的初始化阶段，context只保存虚类，所有子类全部由插件的方式提供，该子类插件的对应阶段执行时，执行响应的context.registerXXXXX()方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"otopi_human_dialog_registerdialog","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_human_dialog_registerdialog.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在context中，registerXXXX()都属于覆盖（registerPlugin、registerNotification除外），在完成覆盖后，由对应插件的子类来实现具体功能，如下："}]},{"type":"element","tag":"pre","props":{"code":"    def registerNotification(self, notification):\n        self._notifications.append(notification)\n\n    def registerPlugin(self, p):\n        self._plugins.append(p)\n\n    def registerDialog(self, dialog):\n        self._dialog = dialog\n\n    def registerServices(self, services):\n        self._services = services\n\n    def registerPackager(self, packager):\n        self._packager = packager\n\n    def registerCommand(self, command):\n        self._command = command\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    def registerNotification(self, notification):\n        self._notifications.append(notification)\n\n    def registerPlugin(self, p):\n        self._plugins.append(p)\n\n    def registerDialog(self, dialog):\n        self._dialog = dialog\n\n    def registerServices(self, services):\n        self._services = services\n\n    def registerPackager(self, packager):\n        self._packager = packager\n\n    def registerCommand(self, command):\n        self._command = command\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"运行阶段"}]},{"type":"text","value":"分为三个步骤，加载插件、构建插件执行序列、按序列执行插件。"}]},{"type":"element","tag":"h5","props":{"id":"加载插件"},"children":[{"type":"text","value":"加载插件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"加载插件"}]},{"type":"text","value":"的主要工作是根据BASE/pluginGroups指定的目标插件组(needgroups)，去BASE/pluginPath路径下寻找。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在needgroups中，otopi会默认增加自己预定义的插件，即src/plugins/otopi目录。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内置的插件共22个"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"default_plugin","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi_default_plugins.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"找到对应的Plugin中后会调用Util.loadModule来加载该python模块，并执行该模块的_ _ init__.py中的createPlugins方法，该方法中定义了模块路径下所有的plugin入口。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所有定义的plugin都会继承PluginBase类，该类的_ _ init _ _ 方法中会调用registerPlugin，从而在context._plugins"},{"type":"element","tag":"span","props":{},"children":[]},{"type":"text","value":"中保存了所有注册的plugins，这是第二步骤的输入。"}]},{"type":"element","tag":"h5","props":{"id":"构建插件执行顺序"},"children":[{"type":"text","value":"构建插件执行顺序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"构建插件执行序列"}]},{"type":"text","value":"的主要工作是根据@util.event中的before和after来构建一个有向无环图(toposort)。每个plugin都可以定义before和after两个变量，设定当前的plguin为current。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据注释中 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"before=EVENTNAMESLIST -- place this event before the events with names EVENTNAMESLIST."}]},{"type":"text","value":" 的说明，那么可以产生(current,before)和(after,current)多个向量【经过分析代码验证相同】，通过全部插件的全部向量，我们可以绘制出多个有向无环图(需要错误检查)。同时使用prioty和stage两个参数来实现分组。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面随便寻找一个toposort group结果来示意下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行构建的方法是 _toposortBuildSequence ，简单的理解就是先根据"}]},{"type":"element","tag":"pre","props":{"code":" (current,before)\n (after,current)\n i.stage == j.stage && i.priority < j.priority ? (i, j) : ( j , i )\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" (current,before)\n (after,current)\n i.stage == j.stage && i.priority < j.priority ? (i, j) : ( j , i )\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来生成对应的向量，最后的结果如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"deps_vector","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi__toposortBuildSequence_deps.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"挑一些标出来的向量，如"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"红色 : (1,256) .  绿色 : (4, 73) .  蓝色 : (6,20) ."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样的就有了一堆的经过检查的向量。下面的就是将这些已定义的向量进行拓扑排序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"拓扑排序的方法是_toposort ， 算法学习详见"},{"type":"element","tag":"a","props":{"href":"http://note.youdao.com/noteshare?id=fc2dfe95bd2905d91185bafc91d7b149&sub=422857DAC7294892AD99F5E9A2D62326","rel":["nofollow"]},"children":[{"type":"text","value":"这篇"}]}]},{"type":"element","tag":"h5","props":{"id":"按序列执行插件"},"children":[{"type":"text","value":"按序列执行插件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"排序后得到的结果是一个二维list，这里的stage就是otopi预定的18个阶段的枚举值，这里的method 包含了plugin主要信息的结构体（包含了每个插件的method和condition）"}]},{"type":"element","tag":"pre","props":{"code":"[\n    {\n        stage0:[method0,method1,...]\n    },\n    {\n        stage1:[method0,method1,...]\n    },\n    ...\n]\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[\n    {\n        stage0:[method0,method1,...]\n    },\n    {\n        stage1:[method0,method1,...]\n    },\n    ...\n]\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后就是按前面说的安装顺序依次执行method"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这里注意2点："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每次执行method的时候需要先执行condition，condition由定义plugin时候指定"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每次执行method前需要保存oldEnvironment，因为Plugin在执行的过程中有可能会修改Environment，需改的部分都会被dump到日志中。"}]}]},{"type":"element","tag":"h4","props":{"id":"srcpluginsotopi"},"children":[{"type":"text","value":"src/plugins/otopi"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面针对otopi提供的几个内置的plugin来进行分析。内容也会涉及部分ovirt-engine的setup脚本，下面内容不做区分。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_boot:"}]},{"type":"element","tag":"pre","props":{"code":"根据environment定义dialog的模式（human/machine）\n注册一些信息到environment中，如包名、版本\n确定packager管理方式dnf/yum，默认推荐dnf\n//todo dnf和yum的代码逻辑 otopi.plugins.otopi.packagers.[dnfpackager/yumpackager]\n把密码设置为敏感字，在日志打印时候就会屏蔽不输出\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"根据environment定义dialog的模式（human/machine）\n注册一些信息到environment中，如包名、版本\n确定packager管理方式dnf/yum，默认推荐dnf\n//todo dnf和yum的代码逻辑 otopi.plugins.otopi.packagers.[dnfpackager/yumpackager]\n把密码设置为敏感字，在日志打印时候就会屏蔽不输出\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_init："}]},{"type":"element","tag":"pre","props":{"code":"找到所有需要解析的配置文件\notopi的初始化过程由每个Plugin执行对应的初始化来完成，如packager\\command\\transaction\n//todo transaction的代码逻辑 otopi.core.transaction\n初始化部分插件相关的environment，如cli/firewalld/iptables/ssh/clock/reboot/answerfile/hostile_service/selinux/fence_kdump_listener/db/java/....\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"找到所有需要解析的配置文件\notopi的初始化过程由每个Plugin执行对应的初始化来完成，如packager\\command\\transaction\n//todo transaction的代码逻辑 otopi.core.transaction\n初始化部分插件相关的environment，如cli/firewalld/iptables/ssh/clock/reboot/answerfile/hostile_service/selinux/fence_kdump_listener/db/java/....\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_setup"}]},{"type":"element","tag":"pre","props":{"code":"检测关键命令是否存在，如ip/firewall-cmd/reboot/openssl.....\n计算系统的一些信息，如最大内存\n连接数据库\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"检测关键命令是否存在，如ip/firewall-cmd/reboot/openssl.....\n计算系统的一些信息，如最大内存\n连接数据库\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_internal _packages"}]},{"type":"element","tag":"pre","props":{"code":"//todo  trascation相关\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//todo  trascation相关\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_programs"}]},{"type":"element","tag":"pre","props":{"code":"在PATH路径下找对应的命令\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"在PATH路径下找对应的命令\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_late _setup"}]},{"type":"element","tag":"pre","props":{"code":"nfs/websocket\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"nfs/websocket\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_customization"}]},{"type":"element","tag":"pre","props":{"code":"解析conf文件定义的变量，并覆盖现有的变量\n使用command进行customization\n用户通过输入plugin接收的参数来控制产品的形态，并影响对应的environment，engine的产品configure阶段就是在这个阶段来整合。\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"解析conf文件定义的变量，并覆盖现有的变量\n使用command进行customization\n用户通过输入plugin接收的参数来控制产品的形态，并影响对应的environment，engine的产品configure阶段就是在这个阶段来整合。\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_validation"}]},{"type":"element","tag":"pre","props":{"code":"检查写到Environment 里面的value的格式\n检查当前依赖的服务运行状态、系统信息、db权属、需要的文件和目录\n执行预写的脚本完成特定的任务，如taskcleaner\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"检查写到Environment 里面的value的格式\n检查当前依赖的服务运行状态、系统信息、db权属、需要的文件和目录\n执行预写的脚本完成特定的任务，如taskcleaner\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_transaction _begin"}]},{"type":"element","tag":"pre","props":{"code":"fence_kdump_listener/websocket/notifier service\n//todo ?? \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fence_kdump_listener/websocket/notifier service\n//todo ?? \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_early _misc"}]},{"type":"element","tag":"pre","props":{"code":"使用firewall-cmd重启服务\n//Fixing Engine database inconsistences\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"使用firewall-cmd重启服务\n//Fixing Engine database inconsistences\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_packages"}]},{"type":"element","tag":"pre","props":{"code":"这里可以用来安装依赖的外部packages\n//yum/dnf -- processTransaction()  ??\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"这里可以用来安装依赖的外部packages\n//yum/dnf -- processTransaction()  ??\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_misc"}]},{"type":"element","tag":"pre","props":{"code":"使用filetransaction来完成文件操作\n生成CA证书、数据库初始化或升级\n把其他plugin的更新信息加入到数据中\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"使用filetransaction来完成文件操作\n生成CA证书、数据库初始化或升级\n把其他plugin的更新信息加入到数据中\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_transaction _end"}]},{"type":"element","tag":"pre","props":{"code":"transaction.commit()\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"transaction.commit()\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_closeup"}]},{"type":"element","tag":"pre","props":{"code":"启动或重启服务\n打印总结信息\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"启动或重启服务\n打印总结信息\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_cleanup"}]},{"type":"element","tag":"pre","props":{"code":"显示日志路径、生成answer file\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"显示日志路径、生成answer file\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_pre _terminate"}]},{"type":"element","tag":"pre","props":{"code":"dump environment\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"dump environment\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_terminate"}]},{"type":"element","tag":"pre","props":{"code":"log/human/machine\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"log/human/machine\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Stage_reboot"}]},{"type":"element","tag":"pre","props":{"code":"或许重启系统\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"或许重启系统\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"otopi","depth":2,"text":"otopi","children":[{"id":"安装顺序","depth":3,"text":"安装顺序"},{"id":"插件组","depth":3,"text":"插件组"},{"id":"环境","depth":3,"text":"环境"},{"id":"对话框","depth":3,"text":"对话框"},{"id":"bundle","depth":3,"text":"bundle"}]},{"id":"源码分析","depth":2,"text":"源码分析","children":[{"id":"安装","depth":3,"text":"安装"},{"id":"目录","depth":3,"text":"目录"}]}]}},"_type":"markdown","_id":"content:blog:otopi:analyze.md","_source":"content","_file":"blog/otopi/analyze.md","_extension":"md"},{"_path":"/blog/otopi/otopi_in_ovirt_engine","_dir":"otopi","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine中otopi的使用","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine中otopi的使用"},"children":[{"type":"text","value":"ovirt-engine中otopi的使用"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"oVirt项目的几个关键组件如engine、vdsm，都是通过otopi来完成install、config、uninstall的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本篇重点介绍ovirt-engine是如何使用otopi的。"}]},{"type":"element","tag":"h2","props":{"id":"engine的脚本"},"children":[{"type":"text","value":"engine的脚本"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在完成ovirt-engine开发环境构建之后，在${PREFIX}/bin/目录下面，有一些可执行的脚步，其中包括engine-setup、engine-cleanup、engine-config等会经常使用的脚步。"}]},{"type":"element","tag":"pre","props":{"code":"ls -al\n//连接关系  ： engine-setup  ->    xxxxx/ovirt-engine-setup\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ls -al\n//连接关系  ： engine-setup  ->    xxxxx/ovirt-engine-setup\n"}]}]},{"type":"element","tag":"h3","props":{"id":"ovirt-engine-setup"},"children":[{"type":"text","value":"ovirt-engine-setup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是一个shell脚步，它的作用是准备setup的环境(ovirt-engine-setup.env)和参数(baseenv)，我们也可以通过 --help来查看我们可以传递进去的一些选项。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"命令的最终是执行"}]},{"type":"element","tag":"pre","props":{"code":"exec \"${otopidir}/otopi\" \"${baseenv} ${environment} ${otopienv}\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"exec \"${otopidir}/otopi\" \"${baseenv} ${environment} ${otopienv}\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在engine的packaging/setup目录下还提供了两个相关的重要内容。"}]},{"type":"element","tag":"pre","props":{"code":"ovirt_engine_setup  // python module\nplugins             // otopi中定义的插件\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ovirt_engine_setup  // python module\nplugins             // otopi中定义的插件\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ovirt_engine_setup"}]},{"type":"text","value":"模块的功能提供给plugins目录下面的插件所使用。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/ovirt_engine_packages_setup_plugins_list.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对应的关系是"}]},{"type":"element","tag":"pre","props":{"code":"./plugins/${groups}/[${directory}]/${plugins}/__init__.py\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"./plugins/${groups}/[${directory}]/${plugins}/__init__.py\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个_ _ init _ _.py文件里面定义了plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/ovirt_engine_packages_setup_plugins_plugin_createPlugins.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以最后都会通过otopi的context.registerPlugin来保存全部加载到的context变量_plugins中。"}]},{"type":"element","tag":"h3","props":{"id":"engine-setup-log"},"children":[{"type":"text","value":"engine-setup log"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"执行"}]},{"type":"element","tag":"pre","props":{"code":"./bin/engine-setup --log=./engine-setup.log\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"./bin/engine-setup --log=./engine-setup.log\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无论配置过程成功或失败，我们可以查看engine-setup.log文件。其中里面包含了 ENVIRONMENT 和 SEQUENCE的dump信息。\nENOVIRONMENT包含了各类环境变量。\nSEQUENCE里面就根据不同的阶段显示了所有需要执行的各类方法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"SEQUENCE 显示结构如下所示"}]},{"type":"element","tag":"pre","props":{"code":"STAGE  ${Stages.STAGE_XXXX}\n    METHOD  otopi.plugins.${groups}.[${directory}].${plugin}.Plugin.${method}\n    METHOD  otopi.plugins.${groups}.[${directory}].${plugin}.Plugin.${method}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"STAGE  ${Stages.STAGE_XXXX}\n    METHOD  otopi.plugins.${groups}.[${directory}].${plugin}.Plugin.${method}\n    METHOD  otopi.plugins.${groups}.[${directory}].${plugin}.Plugin.${method}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我们可以根据对应的关键信息在engine项目中找到对应的实现代码。"}]},{"type":"element","tag":"h3","props":{"id":"debug"},"children":[{"type":"text","value":"debug"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用调试工具可以帮助我们分析代码、理解原理。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面介绍如何调试 engine-setup程序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用Pycharm导入otopi项目\n新建一个Run/Debug Configurations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/otopi-debug-ovirt-engine-setup.png?raw=true"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"图中标号："}]},{"type":"element","tag":"h4","props":{"id":"_1"},"children":[{"type":"text","value":"1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"otopi 的入口是 otopi/src/bin/otopi的shell，最终执行"}]},{"type":"element","tag":"pre","props":{"code":"exec \"${OTOPI_PYTHON}\" -B -m otopi.__main__ \"${extraenv} $*\"\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"exec \"${OTOPI_PYTHON}\" -B -m otopi.__main__ \"${extraenv} $*\"\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"此处我们直接使用新建一个python 的run/debug ，入口程序就是exec python -B -m 后面对应的otopi._ _ main__"}]},{"type":"element","tag":"h4","props":{"id":"_2"},"children":[{"type":"text","value":"2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ovirt-engine项目中的engine-setup已经指定了传给otopi的参数，也可以在exec前面增加echo来查看"}]},{"type":"element","tag":"h4","props":{"id":"_3"},"children":[{"type":"text","value":"3"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"增加"}]},{"type":"element","tag":"pre","props":{"code":"OTOPI_DEBUG = 1 \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"OTOPI_DEBUG = 1 \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由于engine-setup执行的过程中import了部分engine里面的python lib, 地址如下："}]},{"type":"element","tag":"pre","props":{"code":"ovirt-engine/packaging/setup/ovirt_engine_setup\novirt-engine/packaging/pythonlib/ovirt-engine\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ovirt-engine/packaging/setup/ovirt_engine_setup\novirt-engine/packaging/pythonlib/ovirt-engine\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"需要相应的修改 PYTHONPATH"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样就可以执行调试了"}]},{"type":"element","tag":"h2","props":{"id":"为engine脚本添加一个plugin来完成指定工作"},"children":[{"type":"text","value":"为engine脚本添加一个plugin来完成指定工作"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先需要明确需要完成哪些功能，明白是哪个阶段来做这个工作"}]},{"type":"element","tag":"pre","props":{"code":"//todo\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//todo\n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"engine的脚本","depth":2,"text":"engine的脚本","children":[{"id":"ovirt-engine-setup","depth":3,"text":"ovirt-engine-setup"},{"id":"engine-setup-log","depth":3,"text":"engine-setup log"},{"id":"debug","depth":3,"text":"debug"}]},{"id":"为engine脚本添加一个plugin来完成指定工作","depth":2,"text":"为engine脚本添加一个plugin来完成指定工作"}]}},"_type":"markdown","_id":"content:blog:otopi:otopi_in_ovirt_engine.md","_source":"content","_file":"blog/otopi/otopi_in_ovirt_engine.md","_extension":"md"},{"_path":"/blog/ovirt/engine/development_environment","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"oVirt Engine 开发环境搭建","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-开发环境搭建"},"children":[{"type":"text","value":"oVirt Engine 开发环境搭建"}]},{"type":"element","tag":"h2","props":{"id":"基础环境"},"children":[{"type":"text","value":"基础环境"}]},{"type":"element","tag":"h3","props":{"id":"安装centos7"},"children":[{"type":"text","value":"安装Centos7"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/version.png?raw=true"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"安装jdk"},"children":[{"type":"text","value":"安装jdk"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下载最新"},{"type":"element","tag":"a","props":{"href":"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html/","rel":["nofollow"]},"children":[{"type":"text","value":"jdk8"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"选择jdk-xxxx-linux-x64.rpm版本"}]},{"type":"element","tag":"pre","props":{"code":"sudo rpm -ivh jdk-xxxx-linux-x64.rpm\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo rpm -ivh jdk-xxxx-linux-x64.rpm\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"修改JAVA环境变量"}]},{"type":"element","tag":"pre","props":{"code":"vim /etc/profile\n\n//在最后加上，然后wq!\nexport JAVA_HOME=/usr/java/jdk1.8.0_144\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n\n//启用配置\nsource /etc/profile\n\n//此时替换掉原有的centos7 java版本 选择你下载的版本\nsudo alternatives --config java\n\n//最后\njava -version\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"vim /etc/profile\n\n//在最后加上，然后wq!\nexport JAVA_HOME=/usr/java/jdk1.8.0_144\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n\n//启用配置\nsource /etc/profile\n\n//此时替换掉原有的centos7 java版本 选择你下载的版本\nsudo alternatives --config java\n\n//最后\njava -version\n"}]}]},{"type":"element","tag":"h3","props":{"id":"配置maven350"},"children":[{"type":"text","value":"配置maven3.5.0"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.cnblogs.com/HendSame-JMZ/p/6122188.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考"}]}]},{"type":"element","tag":"h3","props":{"id":"安装git"},"children":[{"type":"text","value":"安装git"}]},{"type":"element","tag":"pre","props":{"code":"sudo yum install git\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo yum install git\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"速度太慢 替换使用阿里源 "},{"type":"element","tag":"a","props":{"href":"http://mirrors.aliyun.com/help/centos","rel":["nofollow"]},"children":[{"type":"text","value":"参考"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ht内部源"},{"type":"element","tag":"a","props":{"href":"http://mirrors.ht.com/repo/help/centos.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考"}]}]},{"type":"element","tag":"h3","props":{"id":"克隆代码"},"children":[{"type":"text","value":"克隆代码"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"代码仓库有2个可选\n一个是"},{"type":"element","tag":"a","props":{"href":"https://github.com/oVirt/ovirt-engine","rel":["nofollow"]},"children":[{"type":"text","value":"github"}]},{"type":"text","value":"，另一个是ovirt项目开发用的"},{"type":"element","tag":"a","props":{"href":"https://gerrit.ovirt.org/#/admin/projects/ovirt-engine","rel":["nofollow"]},"children":[{"type":"text","value":"gerrit"}]}]},{"type":"element","tag":"pre","props":{"code":"cd /the/path/you/want/\ngit clone https://github.com/oVirt/ovirt-engine.git\ncd ovirt-engine\n//切换分支，我们这里使用ovirt-engine-4.0\ngit branch -a  //查看全部分支\ngit checkout -t origin/ovirt-engine-4.0 //切换分支\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"cd /the/path/you/want/\ngit clone https://github.com/oVirt/ovirt-engine.git\ncd ovirt-engine\n//切换分支，我们这里使用ovirt-engine-4.0\ngit branch -a  //查看全部分支\ngit checkout -t origin/ovirt-engine-4.0 //切换分支\n"}]}]},{"type":"element","tag":"h3","props":{"id":"导入项目"},"children":[{"type":"text","value":"导入项目"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下载安装intellij idea安装；完成后打开。"}]},{"type":"element","tag":"pre","props":{"code":"Import Project -> \n    选择克隆代码路径 -> \nimport project from external model ->\n    选择<maven> ->\nEnvironment settings... ->\n    选择3.5.0的MAVEN_HOME->\n    选择Override ->\n->next ... \n->选择新的jdk \n->next ...\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Import Project -> \n    选择克隆代码路径 -> \nimport project from external model ->\n    选择<maven> ->\nEnvironment settings... ->\n    选择3.5.0的MAVEN_HOME->\n    选择Override ->\n->next ... \n->选择新的jdk \n->next ...\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"全部完成后ide会自动去下载依赖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"觉得国外下载速度慢可以"},{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/u010717403/article/details/52188496","rel":["nofollow"]},"children":[{"type":"text","value":"参考"}]},{"type":"text","value":"替换成阿里源或者内部的源"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依赖导入完成后就可以阅读代码了"}]},{"type":"element","tag":"h2","props":{"id":"开发环境"},"children":[{"type":"text","value":"开发环境"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"阅读代码的下一步就是把项目跑起来"}]},{"type":"element","tag":"h3","props":{"id":"编译"},"children":[{"type":"text","value":"编译"}]},{"type":"element","tag":"pre","props":{"code":"//关闭单元测试，不然时间太久\nmake install-dev PREFIX=\"/the/path/you/want/\" BUILD_UT=0\n\n//建议时间戳来设置不同的安装目录，不然清理和重新配置的过程会有很多麻烦\n//第一次时间还是会比较久，因为会有一些临时下载的包\n//存在因为网络原因导致失败的情况，请耐心等待\n\n...\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//关闭单元测试，不然时间太久\nmake install-dev PREFIX=\"/the/path/you/want/\" BUILD_UT=0\n\n//建议时间戳来设置不同的安装目录，不然清理和重新配置的过程会有很多麻烦\n//第一次时间还是会比较久，因为会有一些临时下载的包\n//存在因为网络原因导致失败的情况，请耐心等待\n\n...\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"编译的时候我们可以先去做其他事情"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"成功的效果：\n"},{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/make_install_dev.png?raw=true"},"children":[]}]},{"type":"element","tag":"h3","props":{"id":"依赖服务"},"children":[{"type":"text","value":"依赖服务"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"参考ovirt-engine的readme文件"}]},{"type":"element","tag":"pre","props":{"code":"- jdk-8 / openjdk-8-jdk / icedtea-8\n- mime-types or mailcap\n- unzip\n- openssl\n- postgresql-server postgresql\n- python-m2crypto / m2crypto\n- python-psycopg2 / psycopg\n- python-jinja2 / Jinja2\n- libxml2-python / libxml2[python]\n- python-daemon\n- otopi >= 1.1.0\n- ovirt-host-deploy >= 1.1.0\n- ovirt-setup-lib\n- maven-3 (optional)\n- pyflakes (optional)\n- python-pep8 / pep8 (optional)\n- patternfly1 (optional)\n- python-docker-py (optional)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"- jdk-8 / openjdk-8-jdk / icedtea-8\n- mime-types or mailcap\n- unzip\n- openssl\n- postgresql-server postgresql\n- python-m2crypto / m2crypto\n- python-psycopg2 / psycopg\n- python-jinja2 / Jinja2\n- libxml2-python / libxml2[python]\n- python-daemon\n- otopi >= 1.1.0\n- ovirt-host-deploy >= 1.1.0\n- ovirt-setup-lib\n- maven-3 (optional)\n- pyflakes (optional)\n- python-pep8 / pep8 (optional)\n- patternfly1 (optional)\n- python-docker-py (optional)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"首先"}]},{"type":"element","tag":"pre","props":{"code":"sudo yum install http://plain.resources.ovirt.org/pub/yum-repo/ovirt-release40.rpm\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo yum install http://plain.resources.ovirt.org/pub/yum-repo/ovirt-release40.rpm\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然后执行"}]},{"type":"element","tag":"pre","props":{"code":"sudo yum install mailcap unzip m2crypto python-psycopg2 python-jinja2 libxml2-python python-daemon otopi ovirt-host-deploy ovirt-setup-lib postgresql-server ovirt-engine-wildfly ovirt-engine-wildfly-overlay patternfly1 pyflakes\n\n\n//\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo yum install mailcap unzip m2crypto python-psycopg2 python-jinja2 libxml2-python python-daemon otopi ovirt-host-deploy ovirt-setup-lib postgresql-server ovirt-engine-wildfly ovirt-engine-wildfly-overlay patternfly1 pyflakes\n\n\n//\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"找不到的包去"},{"type":"element","tag":"a","props":{"href":"https://rpmfind.net/","rel":["nofollow"]},"children":[{"type":"text","value":"rpmfind"}]},{"type":"text","value":"里面去下"}]},{"type":"element","tag":"h4","props":{"id":"配置postgresql"},"children":[{"type":"text","value":"配置postgresql"}]},{"type":"element","tag":"pre","props":{"code":"sudo -i\ncd /var/lib/pgsql/data\npostgresql-setup initdb\nvim pg_hba.conf  #增加允许的IP\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo -i\ncd /var/lib/pgsql/data\npostgresql-setup initdb\nvim pg_hba.conf  #增加允许的IP\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/postgresql1.png?raw=true"},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"vim postgresql.conf \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"vim postgresql.conf \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/postgresql2.png?raw=true"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"增加数据库用户"},"children":[{"type":"text","value":"增加数据库用户"}]},{"type":"element","tag":"pre","props":{"code":"systemctl restart postgresql.service\n\nsu postgres\n\npsql\n\n#create user\ncreate user engine password 'engine';\n#create database\ncreate database engine owner engine template template0 encoding 'UTF8' lc_collate 'en_US.UTF-8' lc_ctype 'en_US.UTF-8';\n#exit\n\\q  \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"systemctl restart postgresql.service\n\nsu postgres\n\npsql\n\n#create user\ncreate user engine password 'engine';\n#create database\ncreate database engine owner engine template template0 encoding 'UTF8' lc_collate 'en_US.UTF-8' lc_ctype 'en_US.UTF-8';\n#exit\n\\q  \n"}]}]},{"type":"element","tag":"h4","props":{"id":"增加jboss环境"},"children":[{"type":"text","value":"增加jboss环境"}]},{"type":"element","tag":"pre","props":{"code":"sudo vim /etc/profile\n\n#增加一段    \nexport JBOSS_HOME=/usr/share/ovirt-engine-wildfly\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"sudo vim /etc/profile\n\n#增加一段    \nexport JBOSS_HOME=/usr/share/ovirt-engine-wildfly\n"}]}]},{"type":"element","tag":"h3","props":{"id":"engine-服务启动"},"children":[{"type":"text","value":"engine 服务启动"}]},{"type":"element","tag":"h4","props":{"id":"engine-setup"},"children":[{"type":"text","value":"engine-setup"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在编译完成后，如果是第一次启动服务我们需要调用ovirt提供的setup脚步来配置初始化服务"}]},{"type":"element","tag":"pre","props":{"code":"cd /the/path/you/make/install-dev/\n\n./bin/engine-setup\n\n#后面根据个人需求配置\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"cd /the/path/you/make/install-dev/\n\n./bin/engine-setup\n\n#后面根据个人需求配置\n"}]}]},{"type":"element","tag":"h4","props":{"id":"start"},"children":[{"type":"text","value":"start"}]},{"type":"element","tag":"pre","props":{"code":"./share/ovirt-engine/services/ovirt-engine/ovirt-engine.py start\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"./share/ovirt-engine/services/ovirt-engine/ovirt-engine.py start\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"访问  ++"},{"type":"element","tag":"a","props":{"href":"http://127.0.0.1:8080/ovirt-engine/++","rel":["nofollow"]},"children":[{"type":"text","value":"http://127.0.0.1:8080/ovirt-engine/++"}]}]},{"type":"element","tag":"h4","props":{"id":"可能出现的错误的解决办法"},"children":[{"type":"text","value":"可能出现的错误的解决办法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://blog.csdn.net/wangjun_pfc/article/details/5528893","rel":["nofollow"]},"children":[{"type":"text","value":"错误1"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"登录效果"},{"type":"element","tag":"img","props":{"alt":"image","src":"https://github.com/ShaneDean/file/blob/master/blog/ovirt_engine_env/webadmin1.png?raw=true"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"调试环境"},"children":[{"type":"text","value":"调试环境"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"服务起来后的下一步就是启用调试环境，可以断点调试"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"基础环境","depth":2,"text":"基础环境","children":[{"id":"安装centos7","depth":3,"text":"安装Centos7"},{"id":"安装jdk","depth":3,"text":"安装jdk"},{"id":"配置maven350","depth":3,"text":"配置maven3.5.0"},{"id":"安装git","depth":3,"text":"安装git"},{"id":"克隆代码","depth":3,"text":"克隆代码"},{"id":"导入项目","depth":3,"text":"导入项目"}]},{"id":"开发环境","depth":2,"text":"开发环境","children":[{"id":"编译","depth":3,"text":"编译"},{"id":"依赖服务","depth":3,"text":"依赖服务"},{"id":"engine-服务启动","depth":3,"text":"engine 服务启动"}]},{"id":"调试环境","depth":2,"text":"调试环境"}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:development_environment.md","_source":"content","_file":"blog/ovirt/engine/development_environment.md","_extension":"md"},{"_path":"/blog/ovirt/engine/makefile","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine Makefile","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-makefile"},"children":[{"type":"text","value":"ovirt-engine Makefile"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"make 命令是GNU的工程化的编译工具，用于编译众多相互关联的源代码，通过工程化的管理来提供开发效率。ovirt-engine项目中有一个Makefile，这是理解项目代码的入口。"}]},{"type":"element","tag":"h2","props":{"id":"make"},"children":[{"type":"text","value":"make"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"make本身的资料很多，"},{"type":"element","tag":"a","props":{"href":"https://www.gnu.org/software/make/manual/make.html","rel":["nofollow"]},"children":[{"type":"text","value":"官网"}]},{"type":"text","value":","},{"type":"element","tag":"a","props":{"href":"http://www.ruanyifeng.com/blog/2015/02/make.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考1"}]},{"type":"text","value":","},{"type":"element","tag":"a","props":{"href":"https://docs.huihoo.com/gnu/linux/gmake.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考2"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"个人理解，可以把make看做一个将先定义任务再将任务拆分成小任务的工具，它有自己的简单语法和规则帮助你完成拆分和组织工作。它和bash配合紧密，我们可以通过bash和其他的工具、命令、语言来统筹配合完成更多的事情。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"就以ovirt-engine为例， engine使用了make命令来完成各类任务，如配置开发环境(install-dev)、打包(rpm)、开启gwt调试(gwt-debug)等。但后面实际的工作可能是mvn、rpmbuild、linux command、linux shell、python来完成的，make提供了入口，它定义并拆分了任务，再交由其他工具来完成具体的小任务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在工程组织方面，make只提供了最基础的功能，诸如"},{"type":"element","tag":"a","props":{"href":"https://cmake.org/","rel":["nofollow"]},"children":[{"type":"text","value":"cmake"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"https://www.gnu.org/software/automake/","rel":["nofollow"]},"children":[{"type":"text","value":"automake"}]},{"type":"text","value":"等工具则更加强大，但不是本文覆盖的范围，感兴趣的同志请自行阅读。"}]},{"type":"element","tag":"h2","props":{"id":"makefile"},"children":[{"type":"text","value":"Makefile"}]},{"type":"element","tag":"h3","props":{"id":"控制参数"},"children":[{"type":"text","value":"控制参数"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"engine在makefile 的开始 定义了很多控制参数，这些控制参数可以来影响make的流程。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BUILD_UT  是否开启单元测试"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BUILD_VALIDATION 是否进有效性检查。(shell-check.sh\\image-check.sh\\dbscripts-duplicate _upgrade _stripts.sh)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"DEV_BUILD _GWT _SUPER _DEV _MODE  是否开启"},{"type":"element","tag":"a","props":{"href":"http://www.gwtproject.org/articles/superdevmode.html","rel":["nofollow"]},"children":[{"type":"text","value":"GWT super Dev mode"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BUILD _ALL _USER _AGENTS  是否编译全部的浏览器代理类型"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"等等"}]}]},{"type":"element","tag":"h3","props":{"id":"目录层级定义"},"children":[{"type":"text","value":"目录层级定义"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"//略"}]},{"type":"element","tag":"h3","props":{"id":"变量"},"children":[{"type":"text","value":"变量"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"//略"}]},{"type":"element","tag":"h3","props":{"id":"目标"},"children":[{"type":"text","value":"目标"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"engine项目汇总的makefile里面定义了很多目标，开发者用的最多的应该是make install-dev 、make dist 、 make clean"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"make install-dev 负责安装ovirt-engine到一个PREFIX目录，如果是prod部署状态 这个PREFIX是 / 根目录。相应的，在install-dev的dev部署模式中，*.in文件中的变量都会替换成PREFIX的相对路径，这样就可以直接通过 $PREFIX/bin/engine-setup 来启动配置初始化工作 或 $PREFIX/xxxx/ovirt-engine.py start来启动系统服务等。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"make dist 则是修改ovirt-engine.spec.in文件,具备rpmbuild的条件"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"make clean 是执行mvn clean 和 rm $(BUILD _FILE) ${GENERATED _FILE)， 完成清理工作"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除此之花还包括很多其他任务目标，如："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":".in: 替换变量的占位符成实际计算出来的值"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven ： 传入 对应的otps或flags ，执行mvn install"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"copy-recursive: 地柜地将源目录文件复制到目的位置"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"install-packaging-files ： 将项目中的packaging目录 下为文件放到各自的指定目录 ，如  etc/pki/bin/services/dbscripts/pythonlib等"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"install-layout: 建立目录结构、文件结构"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"等"}]}]},{"type":"element","tag":"h2","props":{"id":"engine-makefile"},"children":[{"type":"text","value":"engine makefile"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"整理后的xmind"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"ovirt-engine-4.3-makefile-xmind","src":"https://github.com/ShaneDean/file/raw/7ca6fbc6e895ea99af34e66b945e257dc3ae8888/blog/ovirt_engine_env/ovirt-engine-Makefile.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"make","depth":2,"text":"make"},{"id":"makefile","depth":2,"text":"Makefile","children":[{"id":"控制参数","depth":3,"text":"控制参数"},{"id":"目录层级定义","depth":3,"text":"目录层级定义"},{"id":"变量","depth":3,"text":"变量"},{"id":"目标","depth":3,"text":"目标"}]},{"id":"engine-makefile","depth":2,"text":"engine makefile"}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:makefile.md","_source":"content","_file":"blog/ovirt/engine/makefile.md","_extension":"md"},{"_path":"/blog/ovirt/engine/maven","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine maven","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-maven"},"children":[{"type":"text","value":"ovirt-engine maven"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ovirt-engine是一个由maven组织起来java项目，其中也包括makefile、package或otopi plugin等其他手段来协助完成打包、验证、开发环境准备、初始化等工作，但主要的是maven，在分析梳理项目或导入项目的时候都可以以pom.xml为入口。一个大型项目通常都是由几个小项目或者模块组成的，通过pom.xml定义的关系和包含的mvn plugin可以快速的了解每个子项目的作用从而理解整个项目。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如来make install-dev中出现错误的时候，一般应当找到对应报错的maven项目，切换到该项目目录，分析出错的maven命令的原因，这样就可以了解深层次的错误原因而不是看到报错一筹莫展。"}]},{"type":"element","tag":"h2","props":{"id":"maven"},"children":[{"type":"text","value":"maven"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"maven的学习资料比较多，可以通过阅读"},{"type":"element","tag":"a","props":{"href":"https://segmentfault.com/a/1190000014136187","rel":["nofollow"]},"children":[{"type":"text","value":"参考1"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"https://juejin.im/entry/5b0fa70af265da090e3df499","rel":["nofollow"]},"children":[{"type":"text","value":"参考2"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"http://jolestar.com/dependency-management-tools-maven-gradle/","rel":["nofollow"]},"children":[{"type":"text","value":"参考3"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"http://www.cnblogs.com/davenkin/p/advanced-maven-multi-module-vs-inheritance.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考4"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"http://maven.apache.org/guides/getting-started/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"官网"}]},{"type":"text","value":"和"},{"type":"element","tag":"a","props":{"href":"https://item.jd.com/10476794.html","rel":["nofollow"]},"children":[{"type":"text","value":"书"}]},{"type":"text","value":"来学习。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"个人感觉可以和npm类比的学习"},{"type":"element","tag":"a","props":{"href":"https://codeday.me/bug/20181204/432991.html","rel":["nofollow"]},"children":[{"type":"text","value":"参考5"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"maven本只提供了一个执行环境，真正的操作项目的是由插件来执行的，例如编译java的compile插件、打包的jar插件等等。在安装完maven后会有内置的默认插件，全部定义在所有maven都需要集成的Super Pom里面。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了maven默认插件之外，熟练使用丰富的外部 plugin是学习maven的另一个重点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"每个plugin都可以通过mvn "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"plugin"}]},{"type":"text","value":":"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"action"}]},{"type":"text","value":"的方式使用其提供的服务。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"例如tomcat-maven-plugin："}]},{"type":"element","tag":"pre","props":{"code":"mvn tomcat:deploy   --部署一个web war包\nmvn tomcat:reload   --重新加载web war包\nmvn tomcat:start    --启动tomcat\nmvn tomcat:stop    --停止tomcat\nmvn tomcat:undeploy --停止一个war包\nmvn tomcat:run  --启动嵌入式tomcat ，并运行当前项目\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"mvn tomcat:deploy   --部署一个web war包\nmvn tomcat:reload   --重新加载web war包\nmvn tomcat:start    --启动tomcat\nmvn tomcat:stop    --停止tomcat\nmvn tomcat:undeploy --停止一个war包\nmvn tomcat:run  --启动嵌入式tomcat ，并运行当前项目\n"}]}]},{"type":"element","tag":"h2","props":{"id":"pomxml"},"children":[{"type":"text","value":"pom.xml"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在engine项目中的root pom.xml中定义了5个module，"}]},{"type":"element","tag":"pre","props":{"code":"build-tools-root： 包含静态检查的一些通用规则配置文件,如checkstyle\\findbugs\nbackend：   后台业务逻辑代码\nfrontend:   前台业务逻辑代码\near：          定义jboss运行时的内外部依赖和业务逻辑代码中不同子项目的打包方式、URL映射关系\nmavenmake:      执行make install-dev\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"build-tools-root： 包含静态检查的一些通用规则配置文件,如checkstyle\\findbugs\nbackend：   后台业务逻辑代码\nfrontend:   前台业务逻辑代码\near：          定义jboss运行时的内外部依赖和业务逻辑代码中不同子项目的打包方式、URL映射关系\nmavenmake:      执行make install-dev\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"详细分析见下图:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"ovirt-engine-maven-pom","src":"https://github.com/ShaneDean/file/raw/eb68d3da19b6bb1d293900288228650ee4b43f9b/blog/ovirt_engine_env/ovirt-engine-maven-pom.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"plugin"},"children":[{"type":"text","value":"plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"engine中各个项目中用到的插件汇总如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-resources-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-surefire-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-ejb-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-source-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-checkstyle-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-enforcer-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-war-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-deploy-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-javadoc-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ovirt-jboss-modules-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-compiler-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"findbugs-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-shade-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-dependency-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"exec-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-jaxb22-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"build-helper-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-antrun-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"libsass-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"gwt-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-processor-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-clean-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"lifecycle-mapping"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-ear-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"taglist-maven-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-jar-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maven-assembly-plugin"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"animal-sniffer-maven-plugin"}]}]},{"type":"element","tag":"h3","props":{"id":"ovirt-jboss-modules-maven-plugin"},"children":[{"type":"text","value":"ovirt-jboss-modules-maven-plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是ovirt项目团队写的一个maven插件，This plugin is intended to simplify the creation of JBoss Modules in Maven projects."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ovirt-engine使用是jdk1.8，java的原生module是在9才出现。JBOSS自己实现了一套module的机制，需要通过module.xml的文件来声明模块的依赖和资源。"},{"type":"element","tag":"a","props":{"href":"https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.1/html-single/development_guide/index#class_loading_and_modules","rel":["nofollow"]},"children":[{"type":"text","value":"jboss-module-参考资料"}]},{"type":"text","value":"，在engine里面的"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"maven","depth":2,"text":"maven"},{"id":"pomxml","depth":2,"text":"pom.xml"},{"id":"plugin","depth":2,"text":"plugin","children":[{"id":"ovirt-jboss-modules-maven-plugin","depth":3,"text":"ovirt-jboss-modules-maven-plugin"}]}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:maven.md","_source":"content","_file":"blog/ovirt/engine/maven.md","_extension":"md"},{"_path":"/blog/ovirt/engine/schedulingmanager","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine SchedulingManager","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-schedulingmanager"},"children":[{"type":"text","value":"ovirt-engine SchedulingManager"}]},{"type":"element","tag":"h2","props":{"id":"调度策略"},"children":[{"type":"text","value":"调度策略"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"管网文档定义：调度策略是一组规则，它定义了虚拟机在应用这个调度的集群中的主机间的分配逻辑。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调度策略主要由下面三类对象组成。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"filter:用来过滤不符合条件的host"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"weighting:用来增加符合条件的host的权重"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"load balancing:上两者的集合，代表一个执行策略。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的三类对象都由policyUnitImpl对象的子类来完成。\nfilter 的都是xxxUnit\nweighting 的都是xxxWightPolicyUnit\nload balancing的都是 xxxbalancePolicyUnit"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PolicyUnitImpl是一个abstract类，它有很多具体的实现子类。\n其中包括CpuPiningPolicyUnit,CompatibilityVersionFilterPolicyUnit等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在InternalPolicyUnits内部定义internal的内可用的策略，放在enabledUnits中。\n并且ovirt定义了一个接口注解， SchedulingUnit ，用来标志policyUnit"}]},{"type":"element","tag":"pre","props":{"code":"@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface SchedulingUnit {\n    String guid(); \n    \n    //每个unit名称，可以在手册中的1.5找到描述的功能说明\n    String name(); \n    PolicyUnitType type() default PolicyUnitType.FILTER;\n    \n    //每一个策略单元的具体功能可以通过这个属性来快速了解\n    String description() default \"\";\n    PolicyUnitParameter[] parameters() default {};\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface SchedulingUnit {\n    String guid(); \n    \n    //每个unit名称，可以在手册中的1.5找到描述的功能说明\n    String name(); \n    PolicyUnitType type() default PolicyUnitType.FILTER;\n    \n    //每一个策略单元的具体功能可以通过这个属性来快速了解\n    String description() default \"\";\n    PolicyUnitParameter[] parameters() default {};\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在InternalPolicyUnits.instantiate中检测了每一个policyUnit是否在InternalPolicyUnits.enabledUnits中定义、是否被SchedulingUnit注解标志出来"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调度策略对应的对象是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ClusterPolicy"}]},{"type":"text","value":"，负责保存主机选择和负载均衡的BE。"}]},{"type":"element","tag":"pre","props":{"code":"private Guid id;\nprivate String name;\nprivate String description;\n\n//true表示是保留的内置策略\nprivate boolean locked;\n//true表示没有可用的特定policy，使用默认\nprivate boolean defaultPolicy;\n//可用的filters的id列表\nprivate ArrayList<Guid> filters;\n //上面filter的对应顺序，可接受的value包括  first(-1) | last(1) | no position(0)\nprivate Map<Guid, Integer> filterPositionMap;\n//定义了每个权重的分数\nprivate ArrayList<Pair<Guid, Integer>> functions;\n//一个loadbalance\nprivate Guid balance;\n//提供的参数集\nprivate Map<String, String> parameterMap;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private Guid id;\nprivate String name;\nprivate String description;\n\n//true表示是保留的内置策略\nprivate boolean locked;\n//true表示没有可用的特定policy，使用默认\nprivate boolean defaultPolicy;\n//可用的filters的id列表\nprivate ArrayList<Guid> filters;\n //上面filter的对应顺序，可接受的value包括  first(-1) | last(1) | no position(0)\nprivate Map<Guid, Integer> filterPositionMap;\n//定义了每个权重的分数\nprivate ArrayList<Pair<Guid, Integer>> functions;\n//一个loadbalance\nprivate Guid balance;\n//提供的参数集\nprivate Map<String, String> parameterMap;\n"}]}]},{"type":"element","tag":"h2","props":{"id":"schedulingmanager"},"children":[{"type":"text","value":"SchedulingManager"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"继承自BackendService，主要作用于系统的集群调度策略。"}]},{"type":"element","tag":"h3","props":{"id":"成员分析"},"children":[{"type":"text","value":"成员分析"}]},{"type":"element","tag":"pre","props":{"code":"@Inject\nprivate AuditLogDirector auditLogDirector;\n@Inject\nprivate ResourceManager resourceManager;//todo\n@Inject\nprivate MigrationHandler migrationHandler;//todo\n@Inject\nprivate ExternalSchedulerDiscovery exSchedulerDiscovery;//用来发现外部的policy\n@Inject\nprivate DbFacade dbFacade;//用来返回vds\\cluster\\policyunit\\clusterpolicy等dao来查询数据库\n@Inject\nprivate NetworkDeviceHelper networkDeviceHelper;//todo\n@Inject\nprivate HostDeviceManager hostDeviceManager;//todo\n\nprivate PendingResourceManager pendingResourceManager;\n\n/**\n * [policy id, policy] map\n */\nprivate final ConcurrentHashMap<Guid, ClusterPolicy> policyMap;\n/**\n * [policy unit id, policy unit] map\n */\nprivate volatile ConcurrentHashMap<Guid, PolicyUnitImpl> policyUnits;\n\nprivate final Object policyUnitsLock = new Object();\n\nprivate final ConcurrentHashMap<Guid, Semaphore> clusterLockMap = new ConcurrentHashMap<>();\n\nprivate final VdsFreeMemoryChecker noWaitingMemoryChecker = new VdsFreeMemoryChecker(new NonWaitingDelayer());\n\nprivate final Map<Guid, Boolean> clusterId2isHaReservationSafe = new HashMap<>();\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@Inject\nprivate AuditLogDirector auditLogDirector;\n@Inject\nprivate ResourceManager resourceManager;//todo\n@Inject\nprivate MigrationHandler migrationHandler;//todo\n@Inject\nprivate ExternalSchedulerDiscovery exSchedulerDiscovery;//用来发现外部的policy\n@Inject\nprivate DbFacade dbFacade;//用来返回vds\\cluster\\policyunit\\clusterpolicy等dao来查询数据库\n@Inject\nprivate NetworkDeviceHelper networkDeviceHelper;//todo\n@Inject\nprivate HostDeviceManager hostDeviceManager;//todo\n\nprivate PendingResourceManager pendingResourceManager;\n\n/**\n * [policy id, policy] map\n */\nprivate final ConcurrentHashMap<Guid, ClusterPolicy> policyMap;\n/**\n * [policy unit id, policy unit] map\n */\nprivate volatile ConcurrentHashMap<Guid, PolicyUnitImpl> policyUnits;\n\nprivate final Object policyUnitsLock = new Object();\n\nprivate final ConcurrentHashMap<Guid, Semaphore> clusterLockMap = new ConcurrentHashMap<>();\n\nprivate final VdsFreeMemoryChecker noWaitingMemoryChecker = new VdsFreeMemoryChecker(new NonWaitingDelayer());\n\nprivate final Map<Guid, Boolean> clusterId2isHaReservationSafe = new HashMap<>();\n\n"}]}]},{"type":"element","tag":"h3","props":{"id":"初始化分析"},"children":[{"type":"text","value":"初始化分析"}]},{"type":"element","tag":"pre","props":{"code":"    @PostConstruct\n    public void init() {\n        log.info(\"Initializing Scheduling manager\");\n        //负责获取各类变化的资源情况，操作对象是所有继承PendingResource类的资源类，比如CPU、内存等\n        initializePendingResourceManager();\n        //加载内部外部policyUnit;内部在enabledUnits里面定义;外部在db里面查询;\n        loadPolicyUnits();\n        //加载内部外部ClusterPolicies;内部由createBuilder构建;外部在db里面查询;\n        loadClusterPolicies();\n        //加载外部的scheduler,默认关闭;如果发现就重新加载policyUnit\n        loadExternalScheduler();\n        //启动loadBalance,默认开启;使用quartz定时器调用performLoadBalancing();\n        enableLoadBalancer();\n        //启用HA检查，默认开启;使用quartz定时器调用performHaResevationCheck();\n        enableHaReservationCheck();\n        log.info(\"Initialized Scheduling manager\");\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    @PostConstruct\n    public void init() {\n        log.info(\"Initializing Scheduling manager\");\n        //负责获取各类变化的资源情况，操作对象是所有继承PendingResource类的资源类，比如CPU、内存等\n        initializePendingResourceManager();\n        //加载内部外部policyUnit;内部在enabledUnits里面定义;外部在db里面查询;\n        loadPolicyUnits();\n        //加载内部外部ClusterPolicies;内部由createBuilder构建;外部在db里面查询;\n        loadClusterPolicies();\n        //加载外部的scheduler,默认关闭;如果发现就重新加载policyUnit\n        loadExternalScheduler();\n        //启动loadBalance,默认开启;使用quartz定时器调用performLoadBalancing();\n        enableLoadBalancer();\n        //启用HA检查，默认开启;使用quartz定时器调用performHaResevationCheck();\n        enableHaReservationCheck();\n        log.info(\"Initialized Scheduling manager\");\n    }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"pendingresource"},"children":[{"type":"text","value":"PendingResource"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用作所有trackable pending resource一个基础类模板\n实现一个静态方法给PendingResourceManager来调用，完成收集每台host和VM的数据信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"子类包括"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingCpuCores"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n核心数量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingMemory"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nhost内存大小，单位MB"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingOvercommitMemory"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingVm"}]}]},{"type":"element","tag":"h3","props":{"id":"pendingresourcemanager"},"children":[{"type":"text","value":"PendingResourceManager"}]},{"type":"element","tag":"pre","props":{"code":"//Tracking service for all pending resources\npublic class PendingResourceManager{\n    ...\n    // All internal structures have to be thread-safe for concurrent access\n    private final Map<Guid, Set<PendingResource>> resourcesByHost = new ConcurrentHashMap<>();\n    private final Map<Guid, Set<PendingResource>> resourcesByVm = new ConcurrentHashMap<>();\n    private final Map<PendingResource, PendingResource> pendingResources = new ConcurrentHashMap<>();\n    \n    private final ResourceManager resourceManager;\n    \n    ...\n    \n    public void addPending(PendingResource resource) { ... }\n    \n    public void clearHost(VDS host) { ... }\n    \n    public void clearVm(VmStatic vm) { ... } \n    \n    public <T extends PendingResource> Iterable<T> pendingResources(Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingHostResources(Guid host, Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingVmResources(Guid vm, Class<T> type) { ... } \n    \n    public void notifyHostManagers(Guid hostId) { ... }\n    \n    public <T extends PendingResource> T getExactPendingResource(T template) { ... }\n}\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//Tracking service for all pending resources\npublic class PendingResourceManager{\n    ...\n    // All internal structures have to be thread-safe for concurrent access\n    private final Map<Guid, Set<PendingResource>> resourcesByHost = new ConcurrentHashMap<>();\n    private final Map<Guid, Set<PendingResource>> resourcesByVm = new ConcurrentHashMap<>();\n    private final Map<PendingResource, PendingResource> pendingResources = new ConcurrentHashMap<>();\n    \n    private final ResourceManager resourceManager;\n    \n    ...\n    \n    public void addPending(PendingResource resource) { ... }\n    \n    public void clearHost(VDS host) { ... }\n    \n    public void clearVm(VmStatic vm) { ... } \n    \n    public <T extends PendingResource> Iterable<T> pendingResources(Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingHostResources(Guid host, Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingVmResources(Guid vm, Class<T> type) { ... } \n    \n    public void notifyHostManagers(Guid hostId) { ... }\n    \n    public <T extends PendingResource> T getExactPendingResource(T template) { ... }\n}\n\n"}]}]},{"type":"element","tag":"h3","props":{"id":"internalpolicyunits"},"children":[{"type":"text","value":"InternalPolicyUnits"}]},{"type":"element","tag":"h3","props":{"id":"internalclusterpolicies"},"children":[{"type":"text","value":"InternalClusterPolicies"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过createBuilder来构建了5个预定义的集群策略。代码逻辑如下："}]},{"type":"element","tag":"pre","props":{"code":"createBuilder(\"xxxx-a7ac-4d5f-xxxx\")            //传入uuid\n    .name(\"NAME\")                               //传入集群策略名称\n    .isDefault()                                //制定当前策略是默认策略\n    .setBalancer(XXXBalancePolicyUnit.class)    //设置balancer\n\n    .addFilters(XXXPolicyUnit.class)            //设置filter\n    ...\n\n    .addFunction(1, xxxWeightPolicyUnit.class)  //设置weight和权重值\n    ...\n    \n    .set(PolicyUnitParameter.XXX , 'VALUE')     //设置调度策略的参数和值\n    \n    .register();                                //注册集群调度策略到InternalClusterPolicies里面内置的clusterPolicies中\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"createBuilder(\"xxxx-a7ac-4d5f-xxxx\")            //传入uuid\n    .name(\"NAME\")                               //传入集群策略名称\n    .isDefault()                                //制定当前策略是默认策略\n    .setBalancer(XXXBalancePolicyUnit.class)    //设置balancer\n\n    .addFilters(XXXPolicyUnit.class)            //设置filter\n    ...\n\n    .addFunction(1, xxxWeightPolicyUnit.class)  //设置weight和权重值\n    ...\n    \n    .set(PolicyUnitParameter.XXX , 'VALUE')     //设置调度策略的参数和值\n    \n    .register();                                //注册集群调度策略到InternalClusterPolicies里面内置的clusterPolicies中\n        \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过这种方式定义的集群调度策略有5个："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Evenly_Distributed"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"InClusterUpgrade"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"None"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Power_Saving"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"VM_Evenly_Distributed"}]}]},{"type":"element","tag":"h2","props":{"id":"涉及的entity"},"children":[{"type":"text","value":"涉及的entity"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AffinityGroup ：\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保留一些VMs和属性。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个VM可以关联几个AffinityGroup"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个VM由调度逻辑取决于它所属的AffinityGroup的规则"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ClusterPolicy :\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保存主机选择和load balancing的逻辑"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"内部clusterPolicy是由ovirt内置存在的,用户可以自己添加外部的ClusterPolicy,由is_locked的字段来标识这个区别"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PolicyUnit\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"filter,weight,balance三类方法"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PerHostMessages\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"pre","props":{"code":"  Map<Guid, List<String>> message; //保存各个host的消息list\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Map<Guid, List<String>> message; //保存各个host的消息list\n"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OptimizationType\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定义集群优化的三种方案：none,optimize_for_speed,allow_overbooking"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"//TODO 三者区别"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"调度策略","depth":2,"text":"调度策略"},{"id":"schedulingmanager","depth":2,"text":"SchedulingManager","children":[{"id":"成员分析","depth":3,"text":"成员分析"},{"id":"初始化分析","depth":3,"text":"初始化分析"}]},{"id":"pendingresource","depth":2,"text":"PendingResource","children":[{"id":"pendingresourcemanager","depth":3,"text":"PendingResourceManager"},{"id":"internalpolicyunits","depth":3,"text":"InternalPolicyUnits"},{"id":"internalclusterpolicies","depth":3,"text":"InternalClusterPolicies"}]},{"id":"涉及的entity","depth":2,"text":"涉及的entity"}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:schedulingManager.md","_source":"content","_file":"blog/ovirt/engine/schedulingManager.md","_extension":"md"},{"_path":"/blog/ovirt/engine/spec","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine spec","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-spec"},"children":[{"type":"text","value":"ovirt-engine spec"}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以 ovirt-enigne-4.3为例，分析engine是如何打包成 rpm 的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://rpm.org/user_doc/macros.html","rel":["nofollow"]},"children":[{"type":"text","value":"spec-macro"}]},{"type":"text","value":","}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://rpm-packaging-guide.github.io/","rel":["nofollow"]},"children":[{"type":"text","value":"rpm-package-guide"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://ftp.rpm.org/max-rpm/index.html","rel":["nofollow"]},"children":[{"type":"text","value":"maximum-rpm"}]}]},{"type":"element","tag":"h2","props":{"id":"rpm"},"children":[{"type":"text","value":"rpm"}]},{"type":"element","tag":"h2","props":{"id":"spec"},"children":[{"type":"text","value":"spec"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"spec 文件是rpmbuild的工作手册，手册里面定义了构建系统在各个阶段中执行的命令。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"spec文件由不同的条目组成，具体如下："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"注释    comments    人类阅读使用，rpm会忽略"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"标签    tags        定义数据"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"脚本    scripts     包含了特定时间执行的命令"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"宏      macros"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%files列表          pkg需要包含的文件列表"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"指令    directives  处理%files列表的方式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"条件    conditionals    执行系统、架构相关的预处理工作"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注释："}]},{"type":"element","tag":"pre","props":{"code":"# 后面的内容\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# 后面的内容\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注释也可以展开 但需要使用%%进行转义"}]},{"type":"element","tag":"h3","props":{"id":"标签-tags"},"children":[{"type":"text","value":"标签 tags"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"格式"}]},{"type":"element","tag":"pre","props":{"code":"<something>:<something-else>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"<something>:<something-else>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"somethin"}]},{"type":"text","value":" 大小写、距离 都不敏感"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"内置："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Preamble    变量，Package Naming Tags\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Name        包名"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Version     包版本"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Release     发布次数，每次发布递增，新版本产生式时重置为1，1%{?dist}"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Summary"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"License     license版权"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"URL"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Source0     上游的源代码，应当是远程可靠的访问地址"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Patch0      上游补丁，应当是远程可靠的访问地址"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BuildArch   如果pkg架构无关，则为noarch，如果相关则为架构缩写"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BuildRequires   构建依赖"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Requires    运行依赖"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ExcludeArch 不支持架构"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Body        指令集合， Descriptive Tags\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%description    包描述内容"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%files          会被install的文件列表"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%changelog      发型记录"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"脚本-script"},"children":[{"type":"text","value":"脚本 script"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"分类"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%prep           一系列命令来准备软件的构建环境"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%build          一系列命令来执行软件的构建"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%install        一系列命令来完成从%builddir到%buildroot目录的拷贝 （这里只有在创建pkg的时候，不是实际的用户环境的安装过程）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%check          一些列命令来测试软件，比如包括 unit test case"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%pre            在安装pkg之前执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%post           在安装pkg之后执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%preun          在卸载pkg之前执行"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%postun         在卸载pkg之后执行"}]}]},{"type":"element","tag":"h3","props":{"id":"宏-macro"},"children":[{"type":"text","value":"宏 macro"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"spec内置2个简单的宏来执行特定的任务"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%setup      用来解压源代码，需要SOURCE"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%patch      用来给代码打补丁, 需要PATCH"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时用户可以自己定义宏， 包含两种宏。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simple Macros : 直接的文本替换"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Parameterized Macros ： 包含选项字段，将下一行用空格分隔的字段设为args"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"定义"}]},{"type":"element","tag":"pre","props":{"code":"%define <name>[(opts)] <body>\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"%define <name>[(opts)] <body>\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"包围body的空格都会被移除。 name 可以是字母数字和_组成，长度最少是3个字符。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果没有opts,macro只执行展开操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果opts中有参数的话，它的处理方式是"},{"type":"element","tag":"a","props":{"href":"https://linux.die.net/man/3/getopt","rel":["nofollow"]},"children":[{"type":"text","value":"getopt"}]},{"type":"text","value":"。宏中的可用变量是："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%0      被调用宏的名称"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%*      所有参数，不包括处理标志"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%**     所有参数，包括处理标志"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%#      参数数量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{-f}   调用出现时,标志f的本身"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{-f*}  调用出现时,标志f指向的参数"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%1, %2  参数本身"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"无参数宏的情况下上面的变量都会废弃。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"%{flag} 取flag"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"%{?flag:X} 如果flag出现则为falg,不出现则为X"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"%{!?flag:X} 和上面相反"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"%(shell command) 执行结果即输出 ， 如%(date +%%y%%m%%d) ，这里的%%转义为命令执行中的% 避免再次展开"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"下面是可用来执行内嵌宏"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%trace          打印扩展前后的调试信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%dump           打印可用宏列表"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%getncpus       可用cpu数量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%dnl            放弃下一行，不展开(>=4.15.0)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{echo:...}     打印到stdout"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{warn:...}     打印到stderr"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{error:...}    打印到stderr，并报错"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%define ...     定义宏，lazy展开"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%undefine ...   取消宏定义"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%global ...     定义全局可用宏 ， eager展开"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{load:...}     加载宏文件(>=4.12.0)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{expand:...}   再次展开"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{shrink:...}   消除环绕的空格成一个空格(>=4.14.0)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{quote:...}    引用一个参数宏作为参数，传递空字符或由空格分隔的字符串"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{lua:...}      用lua来展开"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{uncompress:...}   用文件方式展开，并检查文件是否压缩，支持未压缩、gzip、bzip3种"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{basename:...} "},{"type":"element","tag":"a","props":{"href":"http://man7.org/linux/man-pages/man1/basename.1.html","rel":["nofollow"]},"children":[{"type":"text","value":"basename"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"${dirname:...}  "},{"type":"element","tag":"a","props":{"href":"http://man7.org/linux/man-pages/man1/dirname.1.html","rel":["nofollow"]},"children":[{"type":"text","value":"dirname"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{suffix:...}    expand to suffix part of a file name"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{url2path:...} 转换url为本地路径"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{getenv:...}   "},{"type":"element","tag":"a","props":{"href":"http://man7.org/linux/man-pages/man3/getenv.3.html","rel":["nofollow"]},"children":[{"type":"text","value":"getenv"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{getconfdir:...}   rpm的home目录"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{S:...}        expand ... to "},{"type":"element","tag":"source","props":{},"children":[]},{"type":"text","value":" file name"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{P:...}        expand ... to "},{"type":"element","tag":"patch","props":{},"children":[{"type":"text","value":" file name"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%{F:...}        expand ... to "},{"type":"element","tag":"file","props":{},"children":[{"type":"text","value":" file name"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"默认变量地址 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"/usr/lib/rpm/macros"}]},{"type":"text","value":"   "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"/etc/rpm/"}]}]},{"type":"element","tag":"pre","props":{"code":"rpm --eval '<macro expression>'   # 查看宏\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"rpm --eval '<macro expression>'   # 查看宏\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用宏"}]},{"type":"element","tag":"pre","props":{"code":"%{<name>}       #直接展开成txt\n%<name> ...     #如果有参数则进行调用\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"%{<name>}       #直接展开成txt\n%<name> ...     #如果有参数则进行调用\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"eg"}]},{"type":"element","tag":"pre","props":{"code":"%define mymacro() (echo -n \"My arg is %1\" ; sleep %1 ; echo done.)\n%mymacro 5\n(echo -n \"My arg is 5\" ; sleep 5 ; echo done.)\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"%define mymacro() (echo -n \"My arg is %1\" ; sleep %1 ; echo done.)\n%mymacro 5\n(echo -n \"My arg is 5\" ; sleep 5 ; echo done.)\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"autoconf中的宏变量"}]},{"type":"element","tag":"pre","props":{"code":"    %_prefix            /usr\n    %_exec_prefix       %{_prefix}\n    %_bindir            %{_exec_prefix}/bin\n    %_sbindir           %{_exec_prefix}/sbin\n    %_libexecdir        %{_exec_prefix}/libexec\n    %_datadir           %{_prefix}/share\n    %_sysconfdir        %{_prefix}/etc\n    %_sharedstatedir    %{_prefix}/com\n    %_localstatedir     %{_prefix}/vars\n    %_libdir            %{_exec_prefix}/lib\n    %_includedir        %{_prefix}/include\n    %_oldincludedir     /usr/include\n    %_infodir           %{_prefix}/info\n    %_mandir            %{_prefix}/man\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    %_prefix            /usr\n    %_exec_prefix       %{_prefix}\n    %_bindir            %{_exec_prefix}/bin\n    %_sbindir           %{_exec_prefix}/sbin\n    %_libexecdir        %{_exec_prefix}/libexec\n    %_datadir           %{_prefix}/share\n    %_sysconfdir        %{_prefix}/etc\n    %_sharedstatedir    %{_prefix}/com\n    %_localstatedir     %{_prefix}/vars\n    %_libdir            %{_exec_prefix}/lib\n    %_includedir        %{_prefix}/include\n    %_oldincludedir     /usr/include\n    %_infodir           %{_prefix}/info\n    %_mandir            %{_prefix}/man\n"}]}]},{"type":"element","tag":"h3","props":{"id":"files"},"children":[{"type":"text","value":"%files"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"指向需要在构建系统中打包进rpm中的文件列表。 这些文件都会被作为参数执行2次，第一次是构建系统的路径，第二次是安装到目标系统的路径"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"%files包含了一些可用的指令"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"明确配置文件、文档"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"检查文件的权限"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"控制pkg验证阶段的文件需要被检查的方面"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"消除一些创建%files列表时候的繁琐工作"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"具体包括"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%attr   ("},{"type":"element","tag":"mode","props":{},"children":[{"type":"text","value":","},{"type":"element","tag":"user","props":{},"children":[{"type":"text","value":","},{"type":"element","tag":"group","props":{},"children":[{"type":"text","value":")"}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%defattr ("},{"type":"element","tag":"file-mode","props":{},"children":[{"type":"text","value":","},{"type":"element","tag":"user","props":{},"children":[{"type":"text","value":","},{"type":"element","tag":"group","props":{},"children":[{"type":"text","value":","},{"type":"element","tag":"dir-mode","props":{},"children":[{"type":"text","value":")"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%doc"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%config"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%ghost  rpm知道但不在pkg的文件，如log"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%docdir"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%dir    指定目录下的所有信息都属于pkg，不用衍生的打印目录下的信息"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"-f "},{"type":"element","tag":"file","props":{},"children":[{"type":"text","value":"   文件中的每一行都是文件路径"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%verify     验证特殊的文件，如设备文件\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"owner"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"group"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"mode"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"md5"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"size"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maj"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"min"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"symlink"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"mtime"}]}]}]}]},{"type":"element","tag":"h3","props":{"id":"条件-conditionals"},"children":[{"type":"text","value":"条件 conditionals"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"条件包括"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%ifarch"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%ifnarch"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%ifos"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%ifnos"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%else"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"%endif"}]}]},{"type":"element","tag":"h2","props":{"id":"engine"},"children":[{"type":"text","value":"engine"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"根据上面的一些知识点 初步整理的engine的spec文件情况如下图"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"ovirt-engine-spec","src":"https://raw.githubusercontent.com/ShaneDean/file/a66e4024f1769b5dc16dde24d04dc443fdd768d6/blog/ovirt_engine_env/ovirt-engine-spec.png"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"前言","depth":2,"text":"前言"},{"id":"rpm","depth":2,"text":"rpm"},{"id":"spec","depth":2,"text":"spec","children":[{"id":"标签-tags","depth":3,"text":"标签 tags"},{"id":"脚本-script","depth":3,"text":"脚本 script"},{"id":"宏-macro","depth":3,"text":"宏 macro"},{"id":"files","depth":3,"text":"%files"},{"id":"条件-conditionals","depth":3,"text":"条件 conditionals"}]},{"id":"engine","depth":2,"text":"engine"}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:spec.md","_source":"content","_file":"blog/ovirt/engine/spec.md","_extension":"md"}],"navigation":[{"title":"Blog","_path":"/blog","children":[{"title":"联系我","_path":"/blog/about"},{"title":"Algorithm","_path":"/blog/algorithm","children":[{"title":"拓扑排序","_path":"/blog/algorithm/toposort"}]},{"title":"Cs","_path":"/blog/cs","children":[{"title":"BSD Packet Filter","_path":"/blog/cs/bpf"},{"title":"图解密码学","_path":"/blog/cs/cryptology"}]},{"title":"Java","_path":"/blog/java","children":[{"title":"Inject","_path":"/blog/java/inject","children":[{"title":"依赖注入","_path":"/blog/java/inject/intro"}]}]},{"title":"Linux","_path":"/blog/linux","children":[{"title":"autoconf 和 automake","_path":"/blog/linux/autoconf_automake"},{"title":"kbuild","_path":"/blog/linux/kbuild"},{"title":"libseccomp","_path":"/blog/linux/libseccomp"},{"title":"shell","_path":"/blog/linux/shell"}]},{"title":"Otopi","_path":"/blog/otopi","children":[{"title":"otopi源码分析","_path":"/blog/otopi/analyze"},{"title":"ovirt-engine中otopi的使用","_path":"/blog/otopi/otopi_in_ovirt_engine"}]},{"title":"Ovirt","_path":"/blog/ovirt","children":[{"title":"Engine","_path":"/blog/ovirt/engine","children":[{"title":"oVirt Engine 开发环境搭建","_path":"/blog/ovirt/engine/development_environment"},{"title":"ovirt-engine Makefile","_path":"/blog/ovirt/engine/makefile"},{"title":"ovirt-engine maven","_path":"/blog/ovirt/engine/maven"},{"title":"ovirt-engine SchedulingManager","_path":"/blog/ovirt/engine/schedulingmanager"},{"title":"ovirt-engine spec","_path":"/blog/ovirt/engine/spec"}]}]}]}]}