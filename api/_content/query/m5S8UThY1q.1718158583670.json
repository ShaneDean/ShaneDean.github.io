{"_path":"/blog/linux/libseccomp","_dir":"linux","_draft":false,"_partial":false,"_locale":"","title":"libseccomp","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"libseccomp"},"children":[{"type":"text","value":"libseccomp"}]},{"type":"element","tag":"h2","props":{"id":"说明"},"children":[{"type":"text","value":"说明"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"seccomp(全称securecomputing mode) 是linuxkernel从2.6.23版本开始所支持的一种安全机制。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在Linux系统里,大量的系统调用(systemcall)直接暴露给用户态程序。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但是,并不是所有的系统调用都被需要,而且不安全的代码滥用系统调用会对系统造成安全威胁。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过seccomp,我们限制程序使用某些系统调用,这样可以减少系统的暴露面,同时是程序进入一种“安全”的状态。"}]},{"type":"element","tag":"h2","props":{"id":"编译"},"children":[{"type":"text","value":"编译"}]},{"type":"element","tag":"pre","props":{"code":"git clone https://github.com/seccomp/libseccomp.git\n//自己选择 tag 或 branch 默认最新\n./autogen.sh            //需要autoconf automake\n./configure\nmake V=1\nmake install\nmake check\n\n在构建完成之后，doc/man目录下面有可以参考的手册，通过man xxxx 来查询详细的使用用法\n\n其他的一些参考资料\nDocumentation/prctl/seccomp_filter.txt\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\nhttp://man7.org/linux/man-pages/man2/seccomp.2.html\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"git clone https://github.com/seccomp/libseccomp.git\n//自己选择 tag 或 branch 默认最新\n./autogen.sh            //需要autoconf automake\n./configure\nmake V=1\nmake install\nmake check\n\n在构建完成之后，doc/man目录下面有可以参考的手册，通过man xxxx 来查询详细的使用用法\n\n其他的一些参考资料\nDocumentation/prctl/seccomp_filter.txt\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\nhttp://man7.org/linux/man-pages/man2/seccomp.2.html\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"项目构建"},"children":[{"type":"text","value":"项目构建"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"libseccomp是由 automake 组织构建的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"先看 configure.ac文件"}]},{"type":"element","tag":"pre","props":{"code":"\nAC_INIT([libseccomp], [2.3.3])      //定义了包名和版本号\n\nAC_CONFIG_AUX_DIR([build-aux])      //辅助工具的存放路径\n\nAC_CONFIG_HEADERS([configure.h])    //宏定义变量的变量集合\n\nAC_CONFIG_MACRO_DIR([m4])           //指定本地autoconf宏的位置,m4文件夹下定义了check-code-coverage\n\n\n//m4 中  define (name, [expansion])\nm4_define([serial_tests], [\n    //m4 中  esyscmd(shell-command)\n    m4_esyscmd([automake --version |\n                head -1 |\n                awk '{split ($NF,a,\".\"); if (a[1] == 1 && a[2] >= 12) { print \"serial-tests\" }}'\n    ])\n])\n//根据automake的版本去\n\n\nAM_INIT_AUTOMAKE(-Wall foreign subdir-objects tar-pax serial_tests)     //增加make  的 options\n\n\nAC_PROG_CC              //检查要使用的c编译器\nAM_PROG_CC_C_O          //测试上面的次编译器的 -c 和 -o\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([shared pic-only])      //启用libtool\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])       //减少构建输出\n\n\nAM_CPPFLAGS=\"-I\\${top_srcdir}/include\"      //cpp flags\nAM_CFLAGS=\"-Wall\"                           //c   flags\nAM_LDFLAGS=\"-Wl,-z -Wl,relro\"               //ld  flags\nAC_SUBST([AM_CPPFLAGS])             //加入变量\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n\nAC_CHECK_HEADERS_ONCE([linux/seccomp.h])        //检查下这个文件是否存在\n\n\n//获取版本信息\nVERSION_MAJOR=$(echo ${VERSION} | cut -d'.' -f 1)\nVERSION_MINOR=$(echo ${VERSION} | cut -d'.' -f 2)\nVERSION_MICRO=$(echo ${VERSION} | cut -d'.' -f 3)\nAC_SUBST([VERSION_MAJOR])\nAC_SUBST([VERSION_MINOR])\nAC_SUBST([VERSION_MICRO])\n\n// cython checks   略\n// python binding checks   略\n// coverity checks 略\n// code coverage checks\n\n//指明需要版本信息来生成的文件\nAC_CONFIG_FILES([\n    libseccomp.pc\n    include/seccomp.h\n])\n\n//指明需要生成的各级Makefile\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    src/Makefile\n    src/python/Makefile\n    tools/Makefile\n    tests/Makefile\n    doc/Makefile\n])\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\nAC_INIT([libseccomp], [2.3.3])      //定义了包名和版本号\n\nAC_CONFIG_AUX_DIR([build-aux])      //辅助工具的存放路径\n\nAC_CONFIG_HEADERS([configure.h])    //宏定义变量的变量集合\n\nAC_CONFIG_MACRO_DIR([m4])           //指定本地autoconf宏的位置,m4文件夹下定义了check-code-coverage\n\n\n//m4 中  define (name, [expansion])\nm4_define([serial_tests], [\n    //m4 中  esyscmd(shell-command)\n    m4_esyscmd([automake --version |\n                head -1 |\n                awk '{split ($NF,a,\".\"); if (a[1] == 1 && a[2] >= 12) { print \"serial-tests\" }}'\n    ])\n])\n//根据automake的版本去\n\n\nAM_INIT_AUTOMAKE(-Wall foreign subdir-objects tar-pax serial_tests)     //增加make  的 options\n\n\nAC_PROG_CC              //检查要使用的c编译器\nAM_PROG_CC_C_O          //测试上面的次编译器的 -c 和 -o\nm4_ifdef([AM_PROG_AR], [AM_PROG_AR])\n\nLT_INIT([shared pic-only])      //启用libtool\n\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])       //减少构建输出\n\n\nAM_CPPFLAGS=\"-I\\${top_srcdir}/include\"      //cpp flags\nAM_CFLAGS=\"-Wall\"                           //c   flags\nAM_LDFLAGS=\"-Wl,-z -Wl,relro\"               //ld  flags\nAC_SUBST([AM_CPPFLAGS])             //加入变量\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n\nAC_CHECK_HEADERS_ONCE([linux/seccomp.h])        //检查下这个文件是否存在\n\n\n//获取版本信息\nVERSION_MAJOR=$(echo ${VERSION} | cut -d'.' -f 1)\nVERSION_MINOR=$(echo ${VERSION} | cut -d'.' -f 2)\nVERSION_MICRO=$(echo ${VERSION} | cut -d'.' -f 3)\nAC_SUBST([VERSION_MAJOR])\nAC_SUBST([VERSION_MINOR])\nAC_SUBST([VERSION_MICRO])\n\n// cython checks   略\n// python binding checks   略\n// coverity checks 略\n// code coverage checks\n\n//指明需要版本信息来生成的文件\nAC_CONFIG_FILES([\n    libseccomp.pc\n    include/seccomp.h\n])\n\n//指明需要生成的各级Makefile\nAC_CONFIG_FILES([\n    Makefile\n    include/Makefile\n    src/Makefile\n    src/python/Makefile\n    tools/Makefile\n    tests/Makefile\n    doc/Makefile\n])\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"再看 makefile.am文件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"顶层目录的makefile"}]},{"type":"element","tag":"pre","props":{"code":"    ACLOCAL_AMFLAGS =-I m4      //需要引用的宏的地址\n    SUBDIRS = include src tools tests doc   //下级 makefile.am地址\n    \n    pkgconfdir = ${libdir}/pkgconfig    \n    pkgconf_DATA = libseccomp.pc\n    \n    EXTRA_DIST = CHANGELOG CREDITS LICENSE README.md SUBMITTING_PATCHES     //规范中没有定义，但是选上的文件\n\n    \n    //配置静默安装\n    AM_MAKEFLAGS_0 = --quiet --no-print-directory\n    AM_MAKEFLAGS_1 =\n    AM_MAKEFLAGS_ = ${AM_MAKEFLAGS_0}\n    AM_MAKEFLAGS = ${AM_MAKEFLAGS_@AM_V@}\n    \n    \n    //切到src和tests中构建\n    check-build: all\n    ${MAKE} ${AM_MAKEFLAGS} -C src check-build      \n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-build\n    \n    check-syntax:\n    @./tools/check-syntax       //使用astyle来优化代码格式\n    \n    check-code-coverage: check-build\n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-code-coverage    \n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    ACLOCAL_AMFLAGS =-I m4      //需要引用的宏的地址\n    SUBDIRS = include src tools tests doc   //下级 makefile.am地址\n    \n    pkgconfdir = ${libdir}/pkgconfig    \n    pkgconf_DATA = libseccomp.pc\n    \n    EXTRA_DIST = CHANGELOG CREDITS LICENSE README.md SUBMITTING_PATCHES     //规范中没有定义，但是选上的文件\n\n    \n    //配置静默安装\n    AM_MAKEFLAGS_0 = --quiet --no-print-directory\n    AM_MAKEFLAGS_1 =\n    AM_MAKEFLAGS_ = ${AM_MAKEFLAGS_0}\n    AM_MAKEFLAGS = ${AM_MAKEFLAGS_@AM_V@}\n    \n    \n    //切到src和tests中构建\n    check-build: all\n    ${MAKE} ${AM_MAKEFLAGS} -C src check-build      \n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-build\n    \n    check-syntax:\n    @./tools/check-syntax       //使用astyle来优化代码格式\n    \n    check-code-coverage: check-build\n    ${MAKE} ${AM_MAKEFLAGS} -C tests check-code-coverage    \n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"按照SUBDIRS的顺序依次进入子目录， 首先是include。"}]},{"type":"element","tag":"pre","props":{"code":"    include_HEADERS = seccomp.h\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    include_HEADERS = seccomp.h\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"src目录"}]},{"type":"element","tag":"pre","props":{"code":"    //看是否开启Python，开启的话则增加PYTHON到子目录中\n    SUBDIRS = .\n    if ENABLE_PYTHON\n    SUBDIRS += python\n    endif  \n    \n    SOURCE_ALL = ...    //所有的源文件\n    \n    EXTRA_DIST = arch-syscall-validate\n\n    TESTS = arch-syscall-check\n    \n    check_PROGRAMS = arch-syscall-check arch-syscall-dump   //指定系统的测试程序\n    \n    lib_LTLIBRARIES = libseccomp.la\n    \n    arch_syscall_dump_SOURCES = arch-syscall-dump.c ${SOURCES_ALL}\n\n    arch_syscall_check_SOURCES = arch-syscall-check.c ${SOURCES_ALL}\n\n    libseccomp_la_SOURCES = ${SOURCES_ALL}\n    libseccomp_la_CPPFLAGS = ${AM_CPPFLAGS} ${CODE_COVERAGE_CPPFLAGS} \\\n        -I${top_builddir}/include\n    libseccomp_la_CFLAGS = ${AM_CFLAGS} ${CODE_COVERAGE_CFLAGS} ${CFLAGS} \\\n        -fPIC -DPIC -fvisibility=hidden\n    libseccomp_la_LDFLAGS = ${AM_LDFLAGS} ${CODE_COVERAGE_LDFLAGS} ${LDFLAGS} \\\n        -version-number ${VERSION_MAJOR}:${VERSION_MINOR}:${VERSION_MICRO}\n    \n    check-build:\n        ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}       \n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    //看是否开启Python，开启的话则增加PYTHON到子目录中\n    SUBDIRS = .\n    if ENABLE_PYTHON\n    SUBDIRS += python\n    endif  \n    \n    SOURCE_ALL = ...    //所有的源文件\n    \n    EXTRA_DIST = arch-syscall-validate\n\n    TESTS = arch-syscall-check\n    \n    check_PROGRAMS = arch-syscall-check arch-syscall-dump   //指定系统的测试程序\n    \n    lib_LTLIBRARIES = libseccomp.la\n    \n    arch_syscall_dump_SOURCES = arch-syscall-dump.c ${SOURCES_ALL}\n\n    arch_syscall_check_SOURCES = arch-syscall-check.c ${SOURCES_ALL}\n\n    libseccomp_la_SOURCES = ${SOURCES_ALL}\n    libseccomp_la_CPPFLAGS = ${AM_CPPFLAGS} ${CODE_COVERAGE_CPPFLAGS} \\\n        -I${top_builddir}/include\n    libseccomp_la_CFLAGS = ${AM_CFLAGS} ${CODE_COVERAGE_CFLAGS} ${CFLAGS} \\\n        -fPIC -DPIC -fvisibility=hidden\n    libseccomp_la_LDFLAGS = ${AM_LDFLAGS} ${CODE_COVERAGE_LDFLAGS} ${LDFLAGS} \\\n        -version-number ${VERSION_MAJOR}:${VERSION_MINOR}:${VERSION_MICRO}\n    \n    check-build:\n        ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}       \n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"tools的makefile.am"}]},{"type":"element","tag":"pre","props":{"code":"AM_CPPFLAGS = -I${top_builddir}/include\n\nnoinst_LTLIBRARIES = util.la        //lib_LTLIBRARIES\nutil_la_SOURCES = util.c util.h bpf.h\nutil_la_LDFLAGS = -module\n\n    //安装的程序\nbin_PROGRAMS = \\\n    scmp_sys_resolver\n    \n    //没有安装的程序\nnoinst_PROGRAMS = \\\n    scmp_arch_detect \\\n    scmp_bpf_disasm \\\n    scmp_bpf_sim\n    \nEXTRA_DIST = check-syntax scmp_app_inspector\n\nscmp_bpf_disasm_SOURCES = scmp_bpf_disasm.c bpf.h util.h\nscmp_bpf_sim_SOURCES = scmp_bpf_sim.c bpf.h util.h\n\nscmp_sys_resolver_LDADD = ../src/libseccomp.la\nscmp_sys_resolver_LDFLAGS = -static\nscmp_arch_detect_LDADD = ../src/libseccomp.la\nscmp_arch_detect_LDFLAGS = -static\nscmp_bpf_disasm_LDADD = util.la\nscmp_bpf_sim_LDADD = util.la\n\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"AM_CPPFLAGS = -I${top_builddir}/include\n\nnoinst_LTLIBRARIES = util.la        //lib_LTLIBRARIES\nutil_la_SOURCES = util.c util.h bpf.h\nutil_la_LDFLAGS = -module\n\n    //安装的程序\nbin_PROGRAMS = \\\n    scmp_sys_resolver\n    \n    //没有安装的程序\nnoinst_PROGRAMS = \\\n    scmp_arch_detect \\\n    scmp_bpf_disasm \\\n    scmp_bpf_sim\n    \nEXTRA_DIST = check-syntax scmp_app_inspector\n\nscmp_bpf_disasm_SOURCES = scmp_bpf_disasm.c bpf.h util.h\nscmp_bpf_sim_SOURCES = scmp_bpf_sim.c bpf.h util.h\n\nscmp_sys_resolver_LDADD = ../src/libseccomp.la\nscmp_sys_resolver_LDFLAGS = -static\nscmp_arch_detect_LDADD = ../src/libseccomp.la\nscmp_arch_detect_LDFLAGS = -static\nscmp_bpf_disasm_LDADD = util.la\nscmp_bpf_sim_LDADD = util.la\n\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"test中的makefile.am"}]},{"type":"element","tag":"pre","props":{"code":"\n//code_coverage_rules  略\n\nLDADD = util.la ../src/libseccomp.la \n\ncheck_LTLIBRARIES = util.la\nutil_la_SOURCES = util.c util.h\nutil_la_LDFLAGS = -module\n\nTESTS = regression    //主体的测试程序\n\ncheck_PROGRAMS = ...\n\nEXTRA_DIST_TESTPYTHON = ...\n\nEXTRA_DIST_TESTCFGS = ...\n\nEXTRA_DIST_TESTSCRIPTS = regression testdiff testgen    // 3个测试脚本\n\nEXTRA_DIST_TESTVALGRIND = valgrind_test.supp\n\nnodist_00_test_SOURCES = 00-test.c\nEXTRA_PROGRAMS = 00-test\n\ncheck-build:\n    ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}\n\nclean-local:\n    ${RM} -f 00-test *.pyc\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"\n//code_coverage_rules  略\n\nLDADD = util.la ../src/libseccomp.la \n\ncheck_LTLIBRARIES = util.la\nutil_la_SOURCES = util.c util.h\nutil_la_LDFLAGS = -module\n\nTESTS = regression    //主体的测试程序\n\ncheck_PROGRAMS = ...\n\nEXTRA_DIST_TESTPYTHON = ...\n\nEXTRA_DIST_TESTCFGS = ...\n\nEXTRA_DIST_TESTSCRIPTS = regression testdiff testgen    // 3个测试脚本\n\nEXTRA_DIST_TESTVALGRIND = valgrind_test.supp\n\nnodist_00_test_SOURCES = 00-test.c\nEXTRA_PROGRAMS = 00-test\n\ncheck-build:\n    ${MAKE} ${AM_MAKEFLAGS} ${check_PROGRAMS}\n\nclean-local:\n    ${RM} -f 00-test *.pyc\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"doc的就略过了，  筛选出关键的外部程序或脚本"}]},{"type":"element","tag":"pre","props":{"code":"    regression \n    \n    testdiff \\ testgen   // compare test output from different test runs  \n\n    check-syntax   //  a basic C style/format checking tool\n    \n    scmp_app_inspector  //a simple syscall inspector based on strace\n\n    scmp_sys_resolver \\ scmp_arch_detect \\   scmp_bpf_disasm \\  scmp_bpf_sim\n    \n    arch-syscall-validate       //a simple syscall validation tool\n\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    regression \n    \n    testdiff \\ testgen   // compare test output from different test runs  \n\n    check-syntax   //  a basic C style/format checking tool\n    \n    scmp_app_inspector  //a simple syscall inspector based on strace\n\n    scmp_sys_resolver \\ scmp_arch_detect \\   scmp_bpf_disasm \\  scmp_bpf_sim\n    \n    arch-syscall-validate       //a simple syscall validation tool\n\n    \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进入tests目录"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"发现   "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"数字"}]},{"type":"text","value":"-"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"名称"}]},{"type":"text","value":"."},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"c\\py\\tests"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这是   regression脚本对上面的文件进行libseccomp的测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中  .c和 .py是测试的主题逻辑"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":".test文件则是参与测试的样例数据"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"其中主体的测试控制程序是 regression ， 可以通过 -h 来查看使用方法，默认不增加参数即可开启测试"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"regression是一个shell程序，分析其代码："}]},{"type":"element","tag":"pre","props":{"code":"        run_tests\n        |-->    run_test $batch_name $testnum $line $test_type\n        |       //其中举例 01-sim-allow.tests\n        |       //         01-sim-allow  01 \"01-sim-allow   all  0-350  N   N   N   N   N   N   ALLOW\"  bpf-sim\n            |-->\n                    |       run_test_basic\n                    |       run_test_bpf_sim_fuzz\n                    |       run_test_bpf_valgrind\n                    |       run_test_live\n                    |-->    run_test_bpf_sim     01-sim-allow  01   \"01-sim-allow    all    0-350   N   N   N   N   N   N   ALLOW\" \n                            |--> run_test_command \"$testnumstr\" \"./$testname\" \"-b\" 4 \"\"\n                                    |-->  01-sim-allow\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        run_tests\n        |-->    run_test $batch_name $testnum $line $test_type\n        |       //其中举例 01-sim-allow.tests\n        |       //         01-sim-allow  01 \"01-sim-allow   all  0-350  N   N   N   N   N   N   ALLOW\"  bpf-sim\n            |-->\n                    |       run_test_basic\n                    |       run_test_bpf_sim_fuzz\n                    |       run_test_bpf_valgrind\n                    |       run_test_live\n                    |-->    run_test_bpf_sim     01-sim-allow  01   \"01-sim-allow    all    0-350   N   N   N   N   N   N   ALLOW\" \n                            |--> run_test_command \"$testnumstr\" \"./$testname\" \"-b\" 4 \"\"\n                                    |-->  01-sim-allow\n\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"注意:由于参数较多，组合起来的测试方案多种多样，所以"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"xxxx.tests"}]},{"type":"text","value":"文件中定义 range的模式，比0-300表示 0 到 300，regression会将这些表示拆开，然后分别执行，在对比日志的时候可以得到佐证。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"regression的最后通过调用 run_test_command 最后进入了 c的测试程序，在进入c的测试程序之前，我们需要熟悉下libseccomp 的一些api。"}]},{"type":"element","tag":"pre","props":{"code":"        //初始化seccomp filter state\n        scmp_filter_ctx seccomp_init(uint32_t def_action);\n        int seccomp_reset(scmp_filter_ctx ctx, unit32_t def_action);\n            def_action：\n                SCMP_ACT_KILL , SCMP_ACT_TRAP , ACMP_ACT_ERRNO , SCMP_ACT_TRACE , SCMP_ACT_ALLOW\n                \n        //释放seccomp filter state  ,已经loaded into kernel不受影响\n        void seccomp_release(scmp_filter_ctx ctx);\n        //合并两个seccomp filter,src会被释放，不需要在调用 seccomp_release\n        //filter值需要一致，架构需要重叠\n        int seccomp_merge(scmp_filter_ctx dst, scmp_filter_ctx src);\n        \n        \n        //架构管理\n       uint32_t seccomp_arch_resolve_name(const char *arch_name);\n       uint32_t seccomp_arch_native();\n       int seccomp_arch_exist(const scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_add(scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_remove(scmp_filter_ctx ctx, uint32_t arch_token);\n        \n            uint32_t arch_token 由 SCMP_ARCH_* 定义的常量\n            SCMP_ARCH_NATIVE 常量总是指向本地编译的架构\n            当一个新的架构加进来的时候，老 的filter和它没关系，但是后面新增的filter都跟他相关。\n            \n        //属性管理\n        int seccomp_attr_set(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t value)\n        int seccomp_attr_get(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t *value)\n        \n            可选的scmp_filter_attr为\n            \n                SCMP_FLTATR_ACT_DEFAULT\n                    只读属性\n                SCMP_FLTATR_ACT_BADARCH     //def_action\n                    如果架构不匹配，那么默认 SCMP_ACT_KILL\n                SCMP_FLTATR_CTL_NNP         //boolean\n                    定义NO_NEW_PRIVS在filter加载到内核之前就应该被启动。如果这个为0，那么会去检查 CAP_SYS_ADMIN，不然失败。默认1。\n                SCMP_FLTATR_CTL_TSYNC       //boolean\n                    设置表示seccomp_load调用的时候需要全部同步filter\n                SCMP_FLTATR_ATL_TSKIP       //boolean\n                    设置表示可以创建 -1的syscall \n        //导出seccomp filter\n        int seccomp_export_bpf(const scmp_filter_ctx, int fd);      //bpf   --> Berkley Packet Filter\n        int seccomp_export_pfc(const scmp_filter_ctx, int fd);      //pfc  --> Pseudo Filter Code\n            \n        //装载filter到kernel中\n        int seccomp_load(scmp_filter_ctx ctx);  //成功的加载\n        \n        //增加 seccomp filter rule\n        int SCMP_SYS(syscall_name);\n        struct scmp_arg_cmp SCMP_CMP(unsigned int arg, enum scmp_compare op, ...);\n        struct scmp_arg_cmp SCMP_A0(enum scmp_compare op, ...);\n        ...\n        struct scmp_arg_cmp SCMP_A5(enum scmp_compare op, ...);\n        int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action , int syscall, unsigned int arg_cnt, ...);\n        int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,    int syscall, unsigned int arg_cnt, ...);\n        \n        int seccomp_rule_add_array(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        int seccomp_rule_add_exact_array(scmp_filter_ctx ctx, uint32_t action, int syscal, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        \n            新加入的filter rule需要load进 kernel才会生效\n            SCMP_CMP（） 和 SCMP_A{0-5}()宏 生成一个 scmp_arg_cmp结构用到上面的函数中。\n    \n        \n            //区分 seccomp filter 中的 syscall\n            int seccomp_syscall_priority(scmp_filter_ctx ctx, int syscall, uint8_t priority);\n            //解析syscall名称\n            int seccomp_syscall_resolve_name(const char *name);\n            int seccomp_syscall_resolve_name_arch(uint32_t arch_token, const char *name);\n            int seccomp_syscall_resolve_name_rewrite(uint32_t arch_token, const char *name);\n            char *seccomp_syscall_resolve_num_arch(uint32_t arch_torken, int num);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"        //初始化seccomp filter state\n        scmp_filter_ctx seccomp_init(uint32_t def_action);\n        int seccomp_reset(scmp_filter_ctx ctx, unit32_t def_action);\n            def_action：\n                SCMP_ACT_KILL , SCMP_ACT_TRAP , ACMP_ACT_ERRNO , SCMP_ACT_TRACE , SCMP_ACT_ALLOW\n                \n        //释放seccomp filter state  ,已经loaded into kernel不受影响\n        void seccomp_release(scmp_filter_ctx ctx);\n        //合并两个seccomp filter,src会被释放，不需要在调用 seccomp_release\n        //filter值需要一致，架构需要重叠\n        int seccomp_merge(scmp_filter_ctx dst, scmp_filter_ctx src);\n        \n        \n        //架构管理\n       uint32_t seccomp_arch_resolve_name(const char *arch_name);\n       uint32_t seccomp_arch_native();\n       int seccomp_arch_exist(const scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_add(scmp_filter_ctx ctx, uint32_t arch_token);\n       int seccomp_arch_remove(scmp_filter_ctx ctx, uint32_t arch_token);\n        \n            uint32_t arch_token 由 SCMP_ARCH_* 定义的常量\n            SCMP_ARCH_NATIVE 常量总是指向本地编译的架构\n            当一个新的架构加进来的时候，老 的filter和它没关系，但是后面新增的filter都跟他相关。\n            \n        //属性管理\n        int seccomp_attr_set(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t value)\n        int seccomp_attr_get(scmp_filter_ctx ctx,\n                                enum scmp_filter_attr attr, uint32_t *value)\n        \n            可选的scmp_filter_attr为\n            \n                SCMP_FLTATR_ACT_DEFAULT\n                    只读属性\n                SCMP_FLTATR_ACT_BADARCH     //def_action\n                    如果架构不匹配，那么默认 SCMP_ACT_KILL\n                SCMP_FLTATR_CTL_NNP         //boolean\n                    定义NO_NEW_PRIVS在filter加载到内核之前就应该被启动。如果这个为0，那么会去检查 CAP_SYS_ADMIN，不然失败。默认1。\n                SCMP_FLTATR_CTL_TSYNC       //boolean\n                    设置表示seccomp_load调用的时候需要全部同步filter\n                SCMP_FLTATR_ATL_TSKIP       //boolean\n                    设置表示可以创建 -1的syscall \n        //导出seccomp filter\n        int seccomp_export_bpf(const scmp_filter_ctx, int fd);      //bpf   --> Berkley Packet Filter\n        int seccomp_export_pfc(const scmp_filter_ctx, int fd);      //pfc  --> Pseudo Filter Code\n            \n        //装载filter到kernel中\n        int seccomp_load(scmp_filter_ctx ctx);  //成功的加载\n        \n        //增加 seccomp filter rule\n        int SCMP_SYS(syscall_name);\n        struct scmp_arg_cmp SCMP_CMP(unsigned int arg, enum scmp_compare op, ...);\n        struct scmp_arg_cmp SCMP_A0(enum scmp_compare op, ...);\n        ...\n        struct scmp_arg_cmp SCMP_A5(enum scmp_compare op, ...);\n        int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action , int syscall, unsigned int arg_cnt, ...);\n        int seccomp_rule_add_exact(scmp_filter_ctx ctx, uint32_t action,    int syscall, unsigned int arg_cnt, ...);\n        \n        int seccomp_rule_add_array(scmp_filter_ctx ctx, uint32_t action, int syscall, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        int seccomp_rule_add_exact_array(scmp_filter_ctx ctx, uint32_t action, int syscal, unsigned int arg_cnt, const struct scmp_arg_cmp *arg_array);\n        \n            新加入的filter rule需要load进 kernel才会生效\n            SCMP_CMP（） 和 SCMP_A{0-5}()宏 生成一个 scmp_arg_cmp结构用到上面的函数中。\n    \n        \n            //区分 seccomp filter 中的 syscall\n            int seccomp_syscall_priority(scmp_filter_ctx ctx, int syscall, uint8_t priority);\n            //解析syscall名称\n            int seccomp_syscall_resolve_name(const char *name);\n            int seccomp_syscall_resolve_name_arch(uint32_t arch_token, const char *name);\n            int seccomp_syscall_resolve_name_rewrite(uint32_t arch_token, const char *name);\n            char *seccomp_syscall_resolve_num_arch(uint32_t arch_torken, int num);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"进入 01-sim-alloc.c 代码"}]},{"type":"element","tag":"pre","props":{"code":"    ...\n    ctx = seccomp_init(SCMP_ACT_ALLOW);\n    ...\n    rc = util_filter_output(&opts,ctx);\n         |--> _ctx_valid(ctx)\n         |--> program = gen_bpf_generate((struct db_filter_col *) ctx);\n                |--> _gen_bpf_build_bpf(stcut bpf_state *state,const struct db_filter_col *col)\n                            |--> ???\n    \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    ...\n    ctx = seccomp_init(SCMP_ACT_ALLOW);\n    ...\n    rc = util_filter_output(&opts,ctx);\n         |--> _ctx_valid(ctx)\n         |--> program = gen_bpf_generate((struct db_filter_col *) ctx);\n                |--> _gen_bpf_build_bpf(stcut bpf_state *state,const struct db_filter_col *col)\n                            |--> ???\n    \n"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"说明","depth":2,"text":"说明"},{"id":"编译","depth":2,"text":"编译"},{"id":"项目构建","depth":2,"text":"项目构建"}]}},"_type":"markdown","_id":"content:blog:linux:libseccomp.md","_source":"content","_file":"blog/linux/libseccomp.md","_extension":"md"}