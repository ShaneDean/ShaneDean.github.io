{"_path":"/blog/java/inject/intro","_dir":"inject","_draft":false,"_partial":false,"_locale":"","title":"依赖注入","description":"转载原文","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"依赖注入"},"children":[{"type":"text","value":"依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"转载"},{"type":"element","tag":"a","props":{"href":"https://github.com/android-cn/blog/blob/master/java/dependency-injection/README.md","rel":["nofollow"]},"children":[{"type":"text","value":"原文"}]}]},{"type":"element","tag":"h1","props":{"id":"依赖注入-1"},"children":[{"type":"text","value":"依赖注入"}]},{"type":"element","tag":"h3","props":{"id":"_1-依赖"},"children":[{"type":"text","value":"1. 依赖"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。"}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    Father father;\n    ...\n    public Human() {\n        father = new Father();\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human() {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"        father = new Father();\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":8},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"仔细看这段代码我们会发现存在一些问题：\n(1). 如果现在要改变 father 生成方式，如需要用"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new Father(String name)"}]},{"type":"text","value":"初始化 father，需要修改 Human 代码；\n(2). 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中；\n(3). 如果"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"new Father()"}]},{"type":"text","value":"过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。"}]},{"type":"element","tag":"h3","props":{"id":"_2-依赖注入"},"children":[{"type":"text","value":"2. 依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下："}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    Father father;\n    ...\n    public Human(Father father) {\n        this.father = father;\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human(Father father) {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"        this.father = father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":8},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。"}]},{"type":"text","value":"\n现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处：\n(1). 解耦，将依赖之间解耦。\n(2). 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。"}]},{"type":"element","tag":"h3","props":{"id":"_3-java-中的依赖注入"},"children":[{"type":"text","value":"3. Java 中的依赖注入"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。"}]},{"type":"element","tag":"pre","props":{"className":"language-java shiki shiki-themes github-dark","code":"public class Human {\n    ...\n    @Inject Father father;\n    ...\n    public Human() {\n    }\n}\n","language":"java","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"public class Human {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":3},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    @Inject Father father;\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":4},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    ...\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":5},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    public Human() {\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":6},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"    }\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":7},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"}\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面这段代码看起来很神奇：只是增加了一个注解，\nFather 对象就能自动注入了？这个注入过程是怎么完成的？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。\n现在 Java 语言中较流行的依赖注入框架有 "},{"type":"element","tag":"a","props":{"href":"https://github.com/google/guice","rel":["nofollow"]},"children":[{"type":"text","value":"Google Guice"}]},{"type":"text","value":"、\n"},{"type":"element","tag":"a","props":{"href":"http://projects.spring.io/spring-framework/","rel":["nofollow"]},"children":[{"type":"text","value":"Spring"}]},{"type":"text","value":" 等，而在 Android 上比较流行的有\n"},{"type":"element","tag":"a","props":{"href":"https://github.com/roboguice/roboguice","rel":["nofollow"]},"children":[{"type":"text","value":"RoboGuice"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"http://square.github.io/dagger/","rel":["nofollow"]},"children":[{"type":"text","value":"Dagger"}]},{"type":"text","value":" 等。其中 Dagger 是我现在正在项目中使用的。\n如果感兴趣，你可以到 "},{"type":"element","tag":"a","props":{"href":"https://github.com/android-cn/android-open-project-analysis/tree/master/dagger","rel":["nofollow"]},"children":[{"type":"text","value":"Dagger 实现原理解析"}]},{"type":"text","value":" 了解更多依赖注入和 Dagger 实现原理相关信息。"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"_1-依赖","depth":3,"text":"1. 依赖"},{"id":"_2-依赖注入","depth":3,"text":"2. 依赖注入"},{"id":"_3-java-中的依赖注入","depth":3,"text":"3. Java 中的依赖注入"}]}},"_type":"markdown","_id":"content:blog:java:inject:intro.md","_source":"content","_file":"blog/java/inject/intro.md","_extension":"md"}