{"_path":"/blog/ovirt/engine/schedulingmanager","_dir":"engine","_draft":false,"_partial":false,"_locale":"","title":"ovirt-engine SchedulingManager","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"ovirt-engine-schedulingmanager"},"children":[{"type":"text","value":"ovirt-engine SchedulingManager"}]},{"type":"element","tag":"h2","props":{"id":"调度策略"},"children":[{"type":"text","value":"调度策略"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"管网文档定义：调度策略是一组规则，它定义了虚拟机在应用这个调度的集群中的主机间的分配逻辑。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调度策略主要由下面三类对象组成。"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"filter:用来过滤不符合条件的host"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"weighting:用来增加符合条件的host的权重"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"load balancing:上两者的集合，代表一个执行策略。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上的三类对象都由policyUnitImpl对象的子类来完成。\nfilter 的都是xxxUnit\nweighting 的都是xxxWightPolicyUnit\nload balancing的都是 xxxbalancePolicyUnit"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PolicyUnitImpl是一个abstract类，它有很多具体的实现子类。\n其中包括CpuPiningPolicyUnit,CompatibilityVersionFilterPolicyUnit等"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在InternalPolicyUnits内部定义internal的内可用的策略，放在enabledUnits中。\n并且ovirt定义了一个接口注解， SchedulingUnit ，用来标志policyUnit"}]},{"type":"element","tag":"pre","props":{"code":"@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface SchedulingUnit {\n    String guid(); \n    \n    //每个unit名称，可以在手册中的1.5找到描述的功能说明\n    String name(); \n    PolicyUnitType type() default PolicyUnitType.FILTER;\n    \n    //每一个策略单元的具体功能可以通过这个属性来快速了解\n    String description() default \"\";\n    PolicyUnitParameter[] parameters() default {};\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface SchedulingUnit {\n    String guid(); \n    \n    //每个unit名称，可以在手册中的1.5找到描述的功能说明\n    String name(); \n    PolicyUnitType type() default PolicyUnitType.FILTER;\n    \n    //每一个策略单元的具体功能可以通过这个属性来快速了解\n    String description() default \"\";\n    PolicyUnitParameter[] parameters() default {};\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在InternalPolicyUnits.instantiate中检测了每一个policyUnit是否在InternalPolicyUnits.enabledUnits中定义、是否被SchedulingUnit注解标志出来"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"调度策略对应的对象是"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"ClusterPolicy"}]},{"type":"text","value":"，负责保存主机选择和负载均衡的BE。"}]},{"type":"element","tag":"pre","props":{"code":"private Guid id;\nprivate String name;\nprivate String description;\n\n//true表示是保留的内置策略\nprivate boolean locked;\n//true表示没有可用的特定policy，使用默认\nprivate boolean defaultPolicy;\n//可用的filters的id列表\nprivate ArrayList<Guid> filters;\n //上面filter的对应顺序，可接受的value包括  first(-1) | last(1) | no position(0)\nprivate Map<Guid, Integer> filterPositionMap;\n//定义了每个权重的分数\nprivate ArrayList<Pair<Guid, Integer>> functions;\n//一个loadbalance\nprivate Guid balance;\n//提供的参数集\nprivate Map<String, String> parameterMap;\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"private Guid id;\nprivate String name;\nprivate String description;\n\n//true表示是保留的内置策略\nprivate boolean locked;\n//true表示没有可用的特定policy，使用默认\nprivate boolean defaultPolicy;\n//可用的filters的id列表\nprivate ArrayList<Guid> filters;\n //上面filter的对应顺序，可接受的value包括  first(-1) | last(1) | no position(0)\nprivate Map<Guid, Integer> filterPositionMap;\n//定义了每个权重的分数\nprivate ArrayList<Pair<Guid, Integer>> functions;\n//一个loadbalance\nprivate Guid balance;\n//提供的参数集\nprivate Map<String, String> parameterMap;\n"}]}]},{"type":"element","tag":"h2","props":{"id":"schedulingmanager"},"children":[{"type":"text","value":"SchedulingManager"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"继承自BackendService，主要作用于系统的集群调度策略。"}]},{"type":"element","tag":"h3","props":{"id":"成员分析"},"children":[{"type":"text","value":"成员分析"}]},{"type":"element","tag":"pre","props":{"code":"@Inject\nprivate AuditLogDirector auditLogDirector;\n@Inject\nprivate ResourceManager resourceManager;//todo\n@Inject\nprivate MigrationHandler migrationHandler;//todo\n@Inject\nprivate ExternalSchedulerDiscovery exSchedulerDiscovery;//用来发现外部的policy\n@Inject\nprivate DbFacade dbFacade;//用来返回vds\\cluster\\policyunit\\clusterpolicy等dao来查询数据库\n@Inject\nprivate NetworkDeviceHelper networkDeviceHelper;//todo\n@Inject\nprivate HostDeviceManager hostDeviceManager;//todo\n\nprivate PendingResourceManager pendingResourceManager;\n\n/**\n * [policy id, policy] map\n */\nprivate final ConcurrentHashMap<Guid, ClusterPolicy> policyMap;\n/**\n * [policy unit id, policy unit] map\n */\nprivate volatile ConcurrentHashMap<Guid, PolicyUnitImpl> policyUnits;\n\nprivate final Object policyUnitsLock = new Object();\n\nprivate final ConcurrentHashMap<Guid, Semaphore> clusterLockMap = new ConcurrentHashMap<>();\n\nprivate final VdsFreeMemoryChecker noWaitingMemoryChecker = new VdsFreeMemoryChecker(new NonWaitingDelayer());\n\nprivate final Map<Guid, Boolean> clusterId2isHaReservationSafe = new HashMap<>();\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"@Inject\nprivate AuditLogDirector auditLogDirector;\n@Inject\nprivate ResourceManager resourceManager;//todo\n@Inject\nprivate MigrationHandler migrationHandler;//todo\n@Inject\nprivate ExternalSchedulerDiscovery exSchedulerDiscovery;//用来发现外部的policy\n@Inject\nprivate DbFacade dbFacade;//用来返回vds\\cluster\\policyunit\\clusterpolicy等dao来查询数据库\n@Inject\nprivate NetworkDeviceHelper networkDeviceHelper;//todo\n@Inject\nprivate HostDeviceManager hostDeviceManager;//todo\n\nprivate PendingResourceManager pendingResourceManager;\n\n/**\n * [policy id, policy] map\n */\nprivate final ConcurrentHashMap<Guid, ClusterPolicy> policyMap;\n/**\n * [policy unit id, policy unit] map\n */\nprivate volatile ConcurrentHashMap<Guid, PolicyUnitImpl> policyUnits;\n\nprivate final Object policyUnitsLock = new Object();\n\nprivate final ConcurrentHashMap<Guid, Semaphore> clusterLockMap = new ConcurrentHashMap<>();\n\nprivate final VdsFreeMemoryChecker noWaitingMemoryChecker = new VdsFreeMemoryChecker(new NonWaitingDelayer());\n\nprivate final Map<Guid, Boolean> clusterId2isHaReservationSafe = new HashMap<>();\n\n"}]}]},{"type":"element","tag":"h3","props":{"id":"初始化分析"},"children":[{"type":"text","value":"初始化分析"}]},{"type":"element","tag":"pre","props":{"code":"    @PostConstruct\n    public void init() {\n        log.info(\"Initializing Scheduling manager\");\n        //负责获取各类变化的资源情况，操作对象是所有继承PendingResource类的资源类，比如CPU、内存等\n        initializePendingResourceManager();\n        //加载内部外部policyUnit;内部在enabledUnits里面定义;外部在db里面查询;\n        loadPolicyUnits();\n        //加载内部外部ClusterPolicies;内部由createBuilder构建;外部在db里面查询;\n        loadClusterPolicies();\n        //加载外部的scheduler,默认关闭;如果发现就重新加载policyUnit\n        loadExternalScheduler();\n        //启动loadBalance,默认开启;使用quartz定时器调用performLoadBalancing();\n        enableLoadBalancer();\n        //启用HA检查，默认开启;使用quartz定时器调用performHaResevationCheck();\n        enableHaReservationCheck();\n        log.info(\"Initialized Scheduling manager\");\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"    @PostConstruct\n    public void init() {\n        log.info(\"Initializing Scheduling manager\");\n        //负责获取各类变化的资源情况，操作对象是所有继承PendingResource类的资源类，比如CPU、内存等\n        initializePendingResourceManager();\n        //加载内部外部policyUnit;内部在enabledUnits里面定义;外部在db里面查询;\n        loadPolicyUnits();\n        //加载内部外部ClusterPolicies;内部由createBuilder构建;外部在db里面查询;\n        loadClusterPolicies();\n        //加载外部的scheduler,默认关闭;如果发现就重新加载policyUnit\n        loadExternalScheduler();\n        //启动loadBalance,默认开启;使用quartz定时器调用performLoadBalancing();\n        enableLoadBalancer();\n        //启用HA检查，默认开启;使用quartz定时器调用performHaResevationCheck();\n        enableHaReservationCheck();\n        log.info(\"Initialized Scheduling manager\");\n    }\n"}]}]},{"type":"element","tag":"h2","props":{"id":"pendingresource"},"children":[{"type":"text","value":"PendingResource"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"用作所有trackable pending resource一个基础类模板\n实现一个静态方法给PendingResourceManager来调用，完成收集每台host和VM的数据信息。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"子类包括"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingCpuCores"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n核心数量"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingMemory"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\nhost内存大小，单位MB"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingOvercommitMemory"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PendingVm"}]}]},{"type":"element","tag":"h3","props":{"id":"pendingresourcemanager"},"children":[{"type":"text","value":"PendingResourceManager"}]},{"type":"element","tag":"pre","props":{"code":"//Tracking service for all pending resources\npublic class PendingResourceManager{\n    ...\n    // All internal structures have to be thread-safe for concurrent access\n    private final Map<Guid, Set<PendingResource>> resourcesByHost = new ConcurrentHashMap<>();\n    private final Map<Guid, Set<PendingResource>> resourcesByVm = new ConcurrentHashMap<>();\n    private final Map<PendingResource, PendingResource> pendingResources = new ConcurrentHashMap<>();\n    \n    private final ResourceManager resourceManager;\n    \n    ...\n    \n    public void addPending(PendingResource resource) { ... }\n    \n    public void clearHost(VDS host) { ... }\n    \n    public void clearVm(VmStatic vm) { ... } \n    \n    public <T extends PendingResource> Iterable<T> pendingResources(Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingHostResources(Guid host, Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingVmResources(Guid vm, Class<T> type) { ... } \n    \n    public void notifyHostManagers(Guid hostId) { ... }\n    \n    public <T extends PendingResource> T getExactPendingResource(T template) { ... }\n}\n\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"//Tracking service for all pending resources\npublic class PendingResourceManager{\n    ...\n    // All internal structures have to be thread-safe for concurrent access\n    private final Map<Guid, Set<PendingResource>> resourcesByHost = new ConcurrentHashMap<>();\n    private final Map<Guid, Set<PendingResource>> resourcesByVm = new ConcurrentHashMap<>();\n    private final Map<PendingResource, PendingResource> pendingResources = new ConcurrentHashMap<>();\n    \n    private final ResourceManager resourceManager;\n    \n    ...\n    \n    public void addPending(PendingResource resource) { ... }\n    \n    public void clearHost(VDS host) { ... }\n    \n    public void clearVm(VmStatic vm) { ... } \n    \n    public <T extends PendingResource> Iterable<T> pendingResources(Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingHostResources(Guid host, Class<T> type) { ... }\n    \n    public <T extends PendingResource> Iterable<T> pendingVmResources(Guid vm, Class<T> type) { ... } \n    \n    public void notifyHostManagers(Guid hostId) { ... }\n    \n    public <T extends PendingResource> T getExactPendingResource(T template) { ... }\n}\n\n"}]}]},{"type":"element","tag":"h3","props":{"id":"internalpolicyunits"},"children":[{"type":"text","value":"InternalPolicyUnits"}]},{"type":"element","tag":"h3","props":{"id":"internalclusterpolicies"},"children":[{"type":"text","value":"InternalClusterPolicies"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过createBuilder来构建了5个预定义的集群策略。代码逻辑如下："}]},{"type":"element","tag":"pre","props":{"code":"createBuilder(\"xxxx-a7ac-4d5f-xxxx\")            //传入uuid\n    .name(\"NAME\")                               //传入集群策略名称\n    .isDefault()                                //制定当前策略是默认策略\n    .setBalancer(XXXBalancePolicyUnit.class)    //设置balancer\n\n    .addFilters(XXXPolicyUnit.class)            //设置filter\n    ...\n\n    .addFunction(1, xxxWeightPolicyUnit.class)  //设置weight和权重值\n    ...\n    \n    .set(PolicyUnitParameter.XXX , 'VALUE')     //设置调度策略的参数和值\n    \n    .register();                                //注册集群调度策略到InternalClusterPolicies里面内置的clusterPolicies中\n        \n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"createBuilder(\"xxxx-a7ac-4d5f-xxxx\")            //传入uuid\n    .name(\"NAME\")                               //传入集群策略名称\n    .isDefault()                                //制定当前策略是默认策略\n    .setBalancer(XXXBalancePolicyUnit.class)    //设置balancer\n\n    .addFilters(XXXPolicyUnit.class)            //设置filter\n    ...\n\n    .addFunction(1, xxxWeightPolicyUnit.class)  //设置weight和权重值\n    ...\n    \n    .set(PolicyUnitParameter.XXX , 'VALUE')     //设置调度策略的参数和值\n    \n    .register();                                //注册集群调度策略到InternalClusterPolicies里面内置的clusterPolicies中\n        \n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过这种方式定义的集群调度策略有5个："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Evenly_Distributed"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"InClusterUpgrade"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"None"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Power_Saving"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"VM_Evenly_Distributed"}]}]},{"type":"element","tag":"h2","props":{"id":"涉及的entity"},"children":[{"type":"text","value":"涉及的entity"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"AffinityGroup ：\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保留一些VMs和属性。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个VM可以关联几个AffinityGroup"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每个VM由调度逻辑取决于它所属的AffinityGroup的规则"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ClusterPolicy :\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"保存主机选择和load balancing的逻辑"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"内部clusterPolicy是由ovirt内置存在的,用户可以自己添加外部的ClusterPolicy,由is_locked的字段来标识这个区别"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PolicyUnit\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"filter,weight,balance三类方法"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"PerHostMessages\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"pre","props":{"code":"  Map<Guid, List<String>> message; //保存各个host的消息list\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"  Map<Guid, List<String>> message; //保存各个host的消息list\n"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"OptimizationType\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"定义集群优化的三种方案：none,optimize_for_speed,allow_overbooking"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"//TODO 三者区别"}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"调度策略","depth":2,"text":"调度策略"},{"id":"schedulingmanager","depth":2,"text":"SchedulingManager","children":[{"id":"成员分析","depth":3,"text":"成员分析"},{"id":"初始化分析","depth":3,"text":"初始化分析"}]},{"id":"pendingresource","depth":2,"text":"PendingResource","children":[{"id":"pendingresourcemanager","depth":3,"text":"PendingResourceManager"},{"id":"internalpolicyunits","depth":3,"text":"InternalPolicyUnits"},{"id":"internalclusterpolicies","depth":3,"text":"InternalClusterPolicies"}]},{"id":"涉及的entity","depth":2,"text":"涉及的entity"}]}},"_type":"markdown","_id":"content:blog:ovirt:engine:schedulingManager.md","_source":"content","_file":"blog/ovirt/engine/schedulingManager.md","_extension":"md"}